<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conway&#39;s Game of Life · AlgebraicRewriting.jl</title><meta name="title" content="Conway&#39;s Game of Life · AlgebraicRewriting.jl"/><meta property="og:title" content="Conway&#39;s Game of Life · AlgebraicRewriting.jl"/><meta property="twitter:title" content="Conway&#39;s Game of Life · AlgebraicRewriting.jl"/><meta name="description" content="Documentation for AlgebraicRewriting.jl."/><meta property="og:description" content="Documentation for AlgebraicRewriting.jl."/><meta property="twitter:description" content="Documentation for AlgebraicRewriting.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AlgebraicRewriting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AlgebraicRewriting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">AlgebraicRewriting.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../full_demo/">Full Demo</a></li><li class="is-active"><a class="tocitem" href>Conway&#39;s Game of Life</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Ontology"><span>Ontology</span></a></li><li class="toplevel"><a class="tocitem" href="#Data-migration-functors"><span>Data migration functors</span></a></li><li class="toplevel"><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Assembling-rules-into-a-recipe"><span>Assembling rules into a recipe</span></a></li><li><a class="tocitem" href="#Running-the-simulation"><span>Running the simulation</span></a></li></ul></li><li><a class="tocitem" href="../lotka_volterra/">Lotka Volterra</a></li><li><a class="tocitem" href="../ptg_simple/">Slice Bread</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Conway&#39;s Game of Life</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conway&#39;s Game of Life</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/main/docs/literate/game_of_life.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conway&#39;s-Game-of-Life"><a class="docs-heading-anchor" href="#Conway&#39;s-Game-of-Life">Conway&#39;s Game of Life</a><a id="Conway&#39;s-Game-of-Life-1"></a><a class="docs-heading-anchor-permalink" href="#Conway&#39;s-Game-of-Life" title="Permalink"></a></h1><p>This is a demonstration of the game of life as an agent-based model.</p><p>We start with importing some libraries.</p><pre><code class="language-julia hljs">using AlgebraicRewriting
using Catlab, Catlab.Graphs, Catlab.CategoricalAlgebra, Catlab.Theories
import Catlab.Graphics: to_graphviz
using Catlab.Graphics.Graphviz: Attributes, Statement, Node, Edge, Digraph
using PrettyTables
using Luxor</code></pre><p>The game of life has two rules: one which turns living things dead, and one that brings dead things to life. We model the terrain as a symmetric graph: cells are vertices. Neighboring cells have edges between them.</p><p>Implementation wise, if we are going to update cells one at a time, we must keep track of two bits of information (the cell&#39;s living status for the <em>current</em> timestep and whether it will be alive in the <em>next</em> timestep). Thus we need helper rule to overwrite the &quot;current&quot; life status with the &quot;next&quot; life status at the end of each timestep.</p><h1 id="Ontology"><a class="docs-heading-anchor" href="#Ontology">Ontology</a><a id="Ontology-1"></a><a class="docs-heading-anchor-permalink" href="#Ontology" title="Permalink"></a></h1><p>Defining an ontology is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a <code>Presentation</code>, i.e. a database schema. Objects (<code>Ob</code>, or tables) are types of entities. Homs (<code>Hom</code>, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to <code>Ob</code> via attributes (<code>Attr</code>).</p><p>The schema below extends the schema for directed symmetric graphs, which consists in two tables (<code>E</code> and <code>V</code>, for edges and vertices) and two homs (<code>src</code> and <code>tgt</code>, <code>E→V</code>). Furthermore a hom <code>inv: E→E</code> enforces that each edge is paired with its opposite-pointing edge.</p><p>The schema below says there are two more types of entities, <code>Curr</code> and <code>Next</code>. Think of these as little tokens that can be assigned to vertices to mark them as currently-alive or to-be-alive-in-the-next-timestep, respectively. Thus, we can also thinking of them as picking out <em>subsets</em> of <code>V</code> via the maps <code>curr</code> and <code>next</code>.</p><pre><code class="language-julia hljs">@present SchLife &lt;: SchSymmetricGraph begin
  (Curr, Next)::Ob
  curr::Hom(Curr, V)
  next::Hom(Next, V)
end

@acset_type Life(SchLife, part_type=BitSetParts) &lt;: AbstractSymmetricGraph

to_graphviz(SchLife; prog=&quot;dot&quot;)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="246pt" height="131pt"
 viewBox="0.00 0.00 246.00 131.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 127)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-127 242,-127 242,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="116" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="116" y="-14.3" font-family="Times,serif" font-size="14.00">V</text>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="27" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-101.3" font-family="Times,serif" font-size="14.00">E</text>
</g>
<!-- n2&%2345;&gt;n1 -->
<g id="edge1" class="edge">
<title>n2&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M29.36,-87.03C31.59,-76.48 35.87,-63.21 44,-54 53.99,-42.68 68.47,-34.66 81.82,-29.19"/>
<polygon fill="black" stroke="black" points="83.14,-32.43 91.27,-25.64 80.68,-25.88 83.14,-32.43"/>
<text text-anchor="middle" x="55" y="-57.8" font-family="Times,serif" font-size="14.00">src</text>
</g>
<!-- n2&%2345;&gt;n1 -->
<g id="edge2" class="edge">
<title>n2&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M42.74,-90.22C49.91,-83.85 58.47,-76.13 66,-69 75.51,-59.99 85.78,-49.8 94.53,-40.98"/>
<polygon fill="black" stroke="black" points="97.23,-43.23 101.76,-33.65 92.25,-38.31 97.23,-43.23"/>
<text text-anchor="middle" x="92" y="-57.8" font-family="Times,serif" font-size="14.00">tgt</text>
</g>
<!-- n2&%2345;&gt;n2 -->
<g id="edge3" class="edge">
<title>n2&%2345;&gt;n2</title>
<path fill="none" stroke="black" d="M51.53,-112.75C62.51,-113.49 72,-110.91 72,-105 72,-101.03 67.72,-98.56 61.57,-97.59"/>
<polygon fill="black" stroke="black" points="61.65,-94.09 51.53,-97.25 61.41,-101.09 61.65,-94.09"/>
<text text-anchor="middle" x="83" y="-101.3" font-family="Times,serif" font-size="14.00">inv</text>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="139" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="139" y="-101.3" font-family="Times,serif" font-size="14.00">Curr</text>
</g>
<!-- n3&%2345;&gt;n1 -->
<g id="edge4" class="edge">
<title>n3&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M134.46,-87.21C131.24,-75.33 126.87,-59.17 123.19,-45.56"/>
<polygon fill="black" stroke="black" points="126.53,-44.5 120.53,-35.76 119.77,-46.33 126.53,-44.5"/>
<text text-anchor="middle" x="143.5" y="-57.8" font-family="Times,serif" font-size="14.00">curr</text>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="none" stroke="black" cx="211" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="211" y="-101.3" font-family="Times,serif" font-size="14.00">Next</text>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="edge5" class="edge">
<title>n4&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M197.74,-88.93C188.43,-78.66 175.45,-64.99 163,-54 156.67,-48.42 149.51,-42.77 142.71,-37.7"/>
<polygon fill="black" stroke="black" points="144.54,-34.7 134.4,-31.62 140.41,-40.35 144.54,-34.7"/>
<text text-anchor="middle" x="194" y="-57.8" font-family="Times,serif" font-size="14.00">next</text>
</g>
</g>
</svg>
'/><p>We can further extend this schema with an additional attribute of (x,y) coordinates for every vertex. This is nice for visualization but is otherwise unnecessary when doing the actual agent-based modeling. So what we will do is <em>build</em> our model with the Life schema and then <em>run</em> our model with the LifeCoords schema.</p><pre><code class="language-julia hljs">@present SchLifeCoords &lt;: SchLife begin
  Coords::AttrType
  coords::Attr(V, Coords)
end

@acset_type AbsLifeCoords(SchLifeCoords, part_type=BitSetParts) &lt;: AbstractSymmetricGraph

const LifeCoords = AbsLifeCoords{Tuple{Int,Int}};</code></pre><h1 id="Data-migration-functors"><a class="docs-heading-anchor" href="#Data-migration-functors">Data migration functors</a><a id="Data-migration-functors-1"></a><a class="docs-heading-anchor-permalink" href="#Data-migration-functors" title="Permalink"></a></h1><p>We ought to be able to take a state of the world (with no coordinate information) and obtain a state of the world with coordinates (the canonical way to do this is to assign &quot;variables&quot; for the values of the coordinates).</p><pre><code class="language-julia hljs">F = Migrate(SchLifeCoords, LifeCoords; delta=false); # adds coordinates</code></pre><p>F⁻¹ = DeltaMigration(FinFunctor(idₒ, idₘ, SchLife, SchLifeCoords)); # removes coordinates</p><h1 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h1><p>Functions to help us create a grid.</p><pre><code class="language-julia hljs">function make_grid(curr::AbstractMatrix, next=nothing)
  n, m = size(curr)
  n == m || error(&quot;Must be square&quot;)
  X, coords = LifeCoords(), Dict()
  for i in 1:n
    for j in 1:n
      coords[i=&gt;j] = add_vertex!(X; coords=(i, j))
      if Bool(curr[i, j])
        add_part!(X, :Curr, curr=coords[i=&gt;j])
      end
      if !isnothing(next) &amp;&amp; Bool(next[i, j])
        add_part!(X, :Curr, curr=coords[i=&gt;j])
      end
    end
  end
  for i in 1:n
    for j in 1:n
      if i &lt; n
        add_edge!(X, coords[i=&gt;j], coords[i+1=&gt;j])
      end
      if j &lt; n
        add_edge!(X, coords[i=&gt;j], coords[i=&gt;j+1])
      end
      if i &lt; n &amp;&amp; j &lt; n
        add_edge!(X, coords[i=&gt;j], coords[i+1=&gt;j+1])
      end
      if i &lt; n &amp;&amp; j &gt; 1
        add_edge!(X, coords[i=&gt;j], coords[i+1=&gt;j-1])
      end
    end
  end
  X
end

make_grid(n::Int, random=false) = make_grid((random ? rand : zeros)(Bool, (n, n)));</code></pre><p>Functions to help us visualize a grid. Although we have no such constraint, we&#39;ll expect any <code>LifeCoords</code> instance to be a regular grid (for the purposes of visualization). When that&#39;s the case, we can visualize the game state using plaintext.</p><pre><code class="language-julia hljs">function view_life(f::ACSetTransformation, pth=tempname())
  v = collect(f[:V])
  view_life(codom(f), pth; star=isempty(v) ? nothing : only(v))
end

function view_life(X::LifeCoords, pth=tempname(); star=nothing)
  n = Int(sqrt(nparts(X, :V)))
  coords = Dict([(i, j) =&gt; findfirst(==((i, j)), X[:coords])
                 for (i, j) in Iterators.product(1:n, 1:n)])
  mat = pretty_table(String, reduce(hcat, map(1:n) do i
      map(1:n) do j
        c, x = [!isempty(incident(X, coords[(i, j)], x)) for x in [:curr, :next]]
        res = c ? (x ? &quot;O&quot; : &quot;o&quot;) : (x ? &quot;X&quot; : &quot;x&quot;)
        return res * ((star == coords[(i, j)]) ? &quot;.&quot; : &quot;&quot;)
      end
    end); show_header=false, tf=tf_markdown)
  open(pth, &quot;w&quot;) do io
    write(io, mat)
  end
  return mat
end

init = make_grid(3,  true)
view_life(init) |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">| o | x | o |
| x | x | x |
| x | o | x |</code></pre><p>We can also visualize a grid with a distinguished <em>agent</em>. Here an agent living in a game state <code>X</code> is a map <code>A → X</code> where <code>A</code> is the shape of the agent. The only kind of agent we&#39;ll consider in this model is that of a lone vertex.</p><p>Note that <code>A</code> below is defined without coordinates, whereas <code>init</code> is an instance of <code>LifeCoords</code>. So in order to relate them via a mapping (which requires them to share a schema) we promote <code>A</code> to <code>LifeCoords</code> using the data migration, <code>F</code>.</p><pre><code class="language-julia hljs">A = Life(1)
view_life(homomorphism(F(A), init)) |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">| o. | x | o |
|  x | x | x |
|  x | o | x |</code></pre><p>We must also work with miniature game states that are <em>not</em> grids in order for us to define the dynamics, as they are what the patterns and replacements of rewrite rules are made of. In order to visualize these, we will use another visualization function.</p><pre><code class="language-julia hljs">function view_life_graph(X::Union{Life,LifeCoords}, pth=tempname(); star=nothing)
  pg = PropertyGraph{Any}(; prog=&quot;neato&quot;, graph=Dict(),
    node=Dict(:shape =&gt; &quot;circle&quot;, :style =&gt; &quot;filled&quot;, :margin =&gt; &quot;0&quot;),
    edge=Dict(:dir =&gt; &quot;none&quot;, :minlen =&gt; &quot;1&quot;))
  add_vertices!(pg, nparts(X, :V))
  for v in vertices(X)
    set_vprop!(pg, v, :fillcolor, isempty(incident(X, v, :curr)) ? &quot;red&quot; : &quot;green&quot;)
    isempty(incident(X, v, :next)) || set_vprop!(pg, v, :penwidth, &quot;4.0&quot;)
    set_vprop!(pg, v, :label, star == v ? &quot;*&quot; : &quot;&quot;)
  end
  for e in filter(e -&gt; X[e, :inv] &gt; e, edges(X))
    add_edge!(pg, X[e, :src], X[e, :tgt])
  end
  G = to_graphviz(pg)
  open(pth, &quot;w&quot;) do io
    show(io, &quot;image/svg+xml&quot;, G)
  end
  G
end;

view_life_graph(init)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="218pt" height="218pt"
 viewBox="0.00 0.00 217.57 217.51" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 213.51)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-213.51 213.57,-213.51 213.57,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="green" stroke="black" cx="119.41" cy="-191.51" rx="18" ry="18"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="red" stroke="black" cx="154.28" cy="-139.8" rx="18" ry="18"/>
</g>
<!-- n1&%2345;&gt;n2 -->
<g id="edge2" class="edge">
<title>n1&%2345;&gt;n2</title>
<path fill="none" stroke="black" d="M129.49,-176.55C134.08,-169.75 139.5,-161.72 144.09,-154.9"/>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="red" stroke="black" cx="69.66" cy="-154.14" rx="18" ry="18"/>
</g>
<!-- n1&%2345;&gt;n4 -->
<g id="edge1" class="edge">
<title>n1&%2345;&gt;n4</title>
<path fill="none" stroke="black" d="M104.75,-180.5C98.33,-175.68 90.81,-170.03 84.38,-165.2"/>
</g>
<!-- n5 -->
<g id="node5" class="node">
<title>n5</title>
<ellipse fill="red" stroke="black" cx="104.94" cy="-104.75" rx="18" ry="18"/>
</g>
<!-- n1&%2345;&gt;n5 -->
<g id="edge3" class="edge">
<title>n1&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M116.41,-173.53C113.93,-158.64 110.41,-137.58 107.93,-122.7"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="red" stroke="black" cx="191.57" cy="-89.87" rx="18" ry="18"/>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge5" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M165.06,-125.36C169.97,-118.79 175.76,-111.03 180.68,-104.45"/>
</g>
<!-- n2&%2345;&gt;n4 -->
<g id="edge7" class="edge">
<title>n2&%2345;&gt;n4</title>
<path fill="none" stroke="black" d="M136.33,-142.84C121.97,-145.28 101.93,-148.67 87.58,-151.11"/>
</g>
<!-- n2&%2345;&gt;n5 -->
<g id="edge4" class="edge">
<title>n2&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M139.47,-129.28C133.23,-124.85 125.97,-119.69 119.73,-115.26"/>
</g>
<!-- n6 -->
<g id="node6" class="node">
<title>n6</title>
<ellipse fill="green" stroke="black" cx="139.88" cy="-55.13" rx="18" ry="18"/>
</g>
<!-- n2&%2345;&gt;n6 -->
<g id="edge6" class="edge">
<title>n2&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M151.22,-121.84C148.78,-107.47 145.37,-87.42 142.93,-73.06"/>
</g>
<!-- n3&%2345;&gt;n5 -->
<g id="edge9" class="edge">
<title>n3&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M173.62,-92.95C158.75,-95.5 137.73,-99.11 122.87,-101.67"/>
</g>
<!-- n3&%2345;&gt;n6 -->
<g id="edge8" class="edge">
<title>n3&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M176.62,-79.82C169.82,-75.25 161.79,-69.85 154.97,-65.27"/>
</g>
<!-- n4&%2345;&gt;n5 -->
<g id="edge11" class="edge">
<title>n4&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M80.24,-139.32C84.71,-133.07 89.9,-125.81 94.36,-119.56"/>
</g>
<!-- n7 -->
<g id="node7" class="node">
<title>n7</title>
<ellipse fill="green" stroke="black" cx="18" cy="-119.2" rx="18" ry="18"/>
</g>
<!-- n4&%2345;&gt;n7 -->
<g id="edge10" class="edge">
<title>n4&%2345;&gt;n7</title>
<path fill="none" stroke="black" d="M54.72,-144.04C47.92,-139.44 39.9,-134.01 33.09,-129.4"/>
</g>
<!-- n8 -->
<g id="node8" class="node">
<title>n8</title>
<ellipse fill="red" stroke="black" cx="55.55" cy="-69.79" rx="18" ry="18"/>
</g>
<!-- n4&%2345;&gt;n8 -->
<g id="edge12" class="edge">
<title>n4&%2345;&gt;n8</title>
<path fill="none" stroke="black" d="M66.67,-136.25C64.27,-121.94 60.93,-101.96 58.54,-87.65"/>
</g>
<!-- n5&%2345;&gt;n6 -->
<g id="edge14" class="edge">
<title>n5&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M115.42,-89.86C119.84,-83.58 124.98,-76.28 129.4,-70"/>
</g>
<!-- n5&%2345;&gt;n7 -->
<g id="edge16" class="edge">
<title>n5&%2345;&gt;n7</title>
<path fill="none" stroke="black" d="M86.92,-107.74C72,-110.22 50.9,-113.73 35.99,-116.21"/>
</g>
<!-- n5&%2345;&gt;n8 -->
<g id="edge13" class="edge">
<title>n5&%2345;&gt;n8</title>
<path fill="none" stroke="black" d="M90.12,-94.26C83.87,-89.83 76.61,-84.69 70.36,-80.27"/>
</g>
<!-- n9 -->
<g id="node9" class="node">
<title>n9</title>
<ellipse fill="red" stroke="black" cx="89.69" cy="-18" rx="18" ry="18"/>
</g>
<!-- n5&%2345;&gt;n9 -->
<g id="edge15" class="edge">
<title>n5&%2345;&gt;n9</title>
<path fill="none" stroke="black" d="M101.78,-86.77C99.16,-71.88 95.46,-50.83 92.84,-35.95"/>
</g>
<!-- n6&%2345;&gt;n8 -->
<g id="edge18" class="edge">
<title>n6&%2345;&gt;n8</title>
<path fill="none" stroke="black" d="M121.99,-58.24C107.68,-60.72 87.71,-64.2 73.41,-66.68"/>
</g>
<!-- n6&%2345;&gt;n9 -->
<g id="edge17" class="edge">
<title>n6&%2345;&gt;n9</title>
<path fill="none" stroke="black" d="M125.36,-44.39C118.76,-39.51 110.96,-33.74 104.35,-28.84"/>
</g>
<!-- n7&%2345;&gt;n8 -->
<g id="edge19" class="edge">
<title>n7&%2345;&gt;n8</title>
<path fill="none" stroke="black" d="M29.06,-104.64C33.91,-98.27 39.59,-90.8 44.44,-84.41"/>
</g>
<!-- n8&%2345;&gt;n9 -->
<g id="edge20" class="edge">
<title>n8&%2345;&gt;n9</title>
<path fill="none" stroke="black" d="M65.61,-54.53C70.01,-47.85 75.17,-40.02 79.58,-33.33"/>
</g>
</g>
</svg>
'/><p>Now we make some helper functions to construct important ACSets and maps between them. We start with a single vertex which is marked as to-be-alive in the next time step.</p><pre><code class="language-julia hljs">Next() = @acset Life begin V = 1; Next = 1; next = 1 end;

view_life_graph(Next())</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="44pt" height="44pt"
 viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="red" stroke="black" stroke-width="4" cx="18" cy="-18" rx="18" ry="18"/>
</g>
</g>
</svg>
'/><p>We also want to refer to a vertex which is alive in the current time step</p><pre><code class="language-julia hljs">Curr() = @acset Life begin V = 1; Curr = 1; curr = 1 end;
view_life_graph(Curr())</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="44pt" height="44pt"
 viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="green" stroke="black" cx="18" cy="-18" rx="18" ry="18"/>
</g>
</g>
</svg>
'/><p>We also want these where we have a morphism incoming from a vertex.</p><pre><code class="language-julia hljs">to_next() = homomorphism(Life(1), Next());
to_curr() = homomorphism(Life(1), Curr());</code></pre><p>We make a helper for cells connected to <code>n</code> living neighbors</p><pre><code class="language-julia hljs">function living_neighbors(n::Int; alive=false)
  X = Life(1)
  alive &amp;&amp;  add_part!(X, :Curr, curr=1)
  for _ in 1:n
    v = add_part!(X, :V)
    add_part!(X, :Curr, curr=v)
    add_edge!(X, v, 1)
  end
  X
end

view_life_graph(living_neighbors(3))</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="168pt" height="176pt"
 viewBox="0.00 0.00 167.76 175.70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 171.7)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-171.7 163.76,-171.7 163.76,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="red" stroke="black" cx="65.88" cy="-89.71" rx="18" ry="18"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="green" stroke="black" cx="141.76" cy="-101.49" rx="18" ry="18"/>
</g>
<!-- n2&%2345;&gt;n1 -->
<g id="edge1" class="edge">
<title>n2&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M123.78,-98.7C111.68,-96.82 95.8,-94.36 83.74,-92.48"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="green" stroke="black" cx="38.51" cy="-18" rx="18" ry="18"/>
</g>
<!-- n3&%2345;&gt;n1 -->
<g id="edge2" class="edge">
<title>n3&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M44.99,-34.99C49.36,-46.43 55.09,-61.43 59.44,-72.84"/>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="green" stroke="black" cx="18" cy="-149.7" rx="18" ry="18"/>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="edge3" class="edge">
<title>n4&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M29.35,-135.48C36.98,-125.92 47,-113.37 54.62,-103.83"/>
</g>
</g>
</svg>
'/><p>We can control whether the central cell is itself alive or not</p><pre><code class="language-julia hljs">view_life_graph(living_neighbors(3; alive=true))</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="168pt" height="176pt"
 viewBox="0.00 0.00 167.76 175.70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 171.7)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-171.7 163.76,-171.7 163.76,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="green" stroke="black" cx="65.88" cy="-89.71" rx="18" ry="18"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="green" stroke="black" cx="141.76" cy="-101.49" rx="18" ry="18"/>
</g>
<!-- n2&%2345;&gt;n1 -->
<g id="edge1" class="edge">
<title>n2&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M123.78,-98.7C111.68,-96.82 95.8,-94.36 83.74,-92.48"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="green" stroke="black" cx="38.51" cy="-18" rx="18" ry="18"/>
</g>
<!-- n3&%2345;&gt;n1 -->
<g id="edge2" class="edge">
<title>n3&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M44.99,-34.99C49.36,-46.43 55.09,-61.43 59.44,-72.84"/>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="green" stroke="black" cx="18" cy="-149.7" rx="18" ry="18"/>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="edge3" class="edge">
<title>n4&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M29.35,-135.48C36.98,-125.92 47,-113.37 54.62,-103.83"/>
</g>
</g>
</svg>
'/><h1 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h1><p>We have finished specifying what makes up a simulation state, and next is to define what sorts of transitions are possible. This is done by declaring rewrite rules.</p><h3 id="A-dead-cell-becomes-alive-iff-exactly-3-living-neighbors"><a class="docs-heading-anchor" href="#A-dead-cell-becomes-alive-iff-exactly-3-living-neighbors">A dead cell becomes alive iff exactly 3 living neighbors</a><a id="A-dead-cell-becomes-alive-iff-exactly-3-living-neighbors-1"></a><a class="docs-heading-anchor-permalink" href="#A-dead-cell-becomes-alive-iff-exactly-3-living-neighbors" title="Permalink"></a></h3><pre><code class="language-julia hljs">BirthP1 = living_neighbors(3) # must have 3 neighbors
BirthN1 = living_neighbors(4) # forbid the cell to have 4 neighbors
BirthN2 = Curr() # forbid the cell to be alive (i.e. it&#39;s currently dead)
BP1, BN1, BN2 = homomorphism.(Ref(Life(1)), [BirthP1, BirthN1, BirthN2])
bac = [AppCond(BP1; monic=true), AppCond.([BN1, BN2], false; monic=true)...]
Birth = Rule(id(Life(1)), to_next(); ac=bac);</code></pre><h3 id="A-living-cell-stays-alive-iff-2-or-3-living-neighbors"><a class="docs-heading-anchor" href="#A-living-cell-stays-alive-iff-2-or-3-living-neighbors">A living cell stays alive iff 2 or 3 living neighbors</a><a id="A-living-cell-stays-alive-iff-2-or-3-living-neighbors-1"></a><a class="docs-heading-anchor-permalink" href="#A-living-cell-stays-alive-iff-2-or-3-living-neighbors" title="Permalink"></a></h3><pre><code class="language-julia hljs">PersistR = @acset Life begin
  V = 1; Curr = 1; Next = 1; curr = 1; next = 1
end
PersistP1 = living_neighbors(2; alive=true)
PersistN1 = living_neighbors(4; alive=true)
DR, DP1, DN1 = homomorphism.(Ref(Curr()), [PersistR, PersistP1, PersistN1])
pac = [AppCond(DP1; monic=true), AppCond(DN1, false; monic=true)]
Persist = Rule(id(Curr()), DR; ac=pac);</code></pre><h3 id="remove-&quot;Curr&quot;-status"><a class="docs-heading-anchor" href="#remove-&quot;Curr&quot;-status">remove &quot;Curr&quot; status</a><a id="remove-&quot;Curr&quot;-status-1"></a><a class="docs-heading-anchor-permalink" href="#remove-&quot;Curr&quot;-status" title="Permalink"></a></h3><pre><code class="language-julia hljs">ClearCurr = Rule(to_curr(), id(Life(1)));</code></pre><h3 id="remove-&quot;Next&quot;-status"><a class="docs-heading-anchor" href="#remove-&quot;Next&quot;-status">remove &quot;Next&quot; status</a><a id="remove-&quot;Next&quot;-status-1"></a><a class="docs-heading-anchor-permalink" href="#remove-&quot;Next&quot;-status" title="Permalink"></a></h3><pre><code class="language-julia hljs">ClearNext = Rule(to_next(), id(Life(1)));</code></pre><h3 id="Copy-&quot;Next&quot;-to-&quot;Curr&quot;"><a class="docs-heading-anchor" href="#Copy-&quot;Next&quot;-to-&quot;Curr&quot;">Copy &quot;Next&quot; to &quot;Curr&quot;</a><a id="Copy-&quot;Next&quot;-to-&quot;Curr&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-&quot;Next&quot;-to-&quot;Curr&quot;" title="Permalink"></a></h3><pre><code class="language-julia hljs">CopyNext = Rule(to_next(), to_curr());</code></pre><h2 id="Assembling-rules-into-a-recipe"><a class="docs-heading-anchor" href="#Assembling-rules-into-a-recipe">Assembling rules into a recipe</a><a id="Assembling-rules-into-a-recipe-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-rules-into-a-recipe" title="Permalink"></a></h2><p>Now we can assemble our building blocks into a large wiring diagram characterizing the flow of the overall ABM simulation. In addition to the blue rewrite rule blocks, we have yellow <code>Query</code> blocks which execute subroutines once per agent (the second output wire) before exiting (the first output wire).</p><p>Give symbolic names to the rewrite rules from before</p><pre><code class="language-julia hljs">rules = [:Birth =&gt; Birth, :Persist =&gt; Persist, :ClearCurr =&gt; ClearCurr,
  :ClearNext =&gt; ClearNext, :CopyNext =&gt; CopyNext];</code></pre><p>All rules have interface of a single distinguished cell, i.e. they are executed from the perspective an agent which is a particular distinguished vertex.</p><p>Normally we can consider branching possibilities depending on whether or not the rewrite is successful, but in this simulation we don&#39;t do this. <code>tryrule</code> simply merges the two output wires from a rewrite rule box into a single output wire.</p><pre><code class="language-julia hljs">rBirth, rPersist, rClearCurr, rClearNext, rCopyNext =
  [tryrule(RuleApp(n, r, Life(1))) for (n, r) in rules]

view_sched(rBirth)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="56pt" height="107pt"
 viewBox="0.00 0.00 56.00 107.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 103)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-103 52,-103 52,4 -4,4"/>
<!-- n0in1 -->
<!-- n1 -->
<!-- Birth -->
<g id="n1" class="node">
<title>n1</title>
<polygon fill="lightblue" stroke="transparent" points="48,-62 0,-62 0,-37 48,-37 48,-62"/>
<polygon fill="none" stroke="black" points="0,-36.5 0,-61.5 48,-61.5 48,-36.5 0,-36.5"/>
<text text-anchor="start" x="5.5" y="-45.3" font-family="Serif" font-size="14.00">Birth</text>
</g>
<!-- n0in1&%2345;&gt;n1 -->
<g id="e1" class="edge">
<title>n0in1:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M24,-98C24,-83.88 24,-79.1 24,-67.17"/>
<polygon fill="black" stroke="black" points="25.75,-67 24,-62 22.25,-67 25.75,-67"/>
</g>
<!-- n0out1 -->
<!-- n1&%2345;&gt;n0out1 -->
<g id="e2" class="edge">
<title>n1:s&%2345;&gt;n0out1:n</title>
<path fill="none" stroke="black" d="M12,-37C12,-21.98 21.52,-18.54 23.6,-6.05"/>
<polygon fill="black" stroke="black" points="25.35,-6.12 24,-1 21.86,-5.85 25.35,-6.12"/>
</g>
<!-- n1&%2345;&gt;n0out1 -->
<g id="e3" class="edge">
<title>n1:s&%2345;&gt;n0out1:n</title>
<path fill="none" stroke="black" d="M36,-37C36,-21.98 26.48,-18.54 24.4,-6.05"/>
<polygon fill="black" stroke="black" points="26.14,-5.85 24,-1 22.65,-6.12 26.14,-5.85"/>
</g>
</g>
</svg>
'/><p>The first <code>for</code> loop is computing <code>next</code> for all cells</p><pre><code class="language-julia hljs">update_next = agent(rBirth ⋅ rPersist, Life(1); n=:Cell)

view_sched(update_next)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="228pt" height="229pt"
 viewBox="0.00 0.00 227.50 229.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 225)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-225 223.5,-225 223.5,4 -4,4"/>
<!-- n0in1 -->
<!-- n1 -->
<!-- Query Cell -->
<g id="n1" class="node">
<title>n1</title>
<polygon fill="yellow" stroke="transparent" points="144,-184 58,-184 58,-159 144,-159 144,-184"/>
<polygon fill="none" stroke="black" points="58,-158.5 58,-183.5 144,-183.5 144,-158.5 58,-158.5"/>
<text text-anchor="start" x="63" y="-167.3" font-family="Serif" font-size="14.00">Query Cell</text>
</g>
<!-- n0in1&%2345;&gt;n1 -->
<g id="e1" class="edge">
<title>n0in1:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M79,-220C79,-205.88 79,-201.1 79,-189.17"/>
<polygon fill="black" stroke="black" points="80.75,-189 79,-184 77.25,-189 80.75,-189"/>
</g>
<!-- n0out1 -->
<!-- n1&%2345;&gt;n0out1 -->
<g id="e8" class="edge">
<title>n1:s&%2345;&gt;n0out1:n</title>
<path fill="none" stroke="black" d="M72,-159C72,-141.83 64.14,-139.03 58,-123 37.92,-70.58 13.58,-59.61 12.07,-6.29"/>
<polygon fill="black" stroke="black" points="13.82,-5.98 12,-1 10.32,-6.02 13.82,-5.98"/>
</g>
<!-- n2 -->
<!-- Fail -->
<g id="n2" class="node">
<title>n2</title>
<polygon fill="red" stroke="transparent" points="219.5,-123 182.5,-123 182.5,-98 219.5,-98 219.5,-123"/>
<polygon fill="none" stroke="black" points="183,-97.5 183,-122.5 220,-122.5 220,-97.5 183,-97.5"/>
<text text-anchor="start" x="188" y="-106.3" font-family="Serif" font-size="14.00">Fail</text>
</g>
<!-- n1&%2345;&gt;n2 -->
<g id="e5" class="edge">
<title>n1:s&%2345;&gt;n2:n</title>
<path fill="none" stroke="black" d="M130,-159C130,-125.18 194.34,-155.1 201.38,-128.25"/>
<polygon fill="black" stroke="black" points="203.15,-128.17 202,-123 199.67,-127.76 203.15,-128.17"/>
</g>
<!-- n3 -->
<!-- Birth -->
<g id="n3" class="node">
<title>n3</title>
<polygon fill="lightblue" stroke="transparent" points="126,-123 78,-123 78,-98 126,-98 126,-123"/>
<polygon fill="none" stroke="black" points="78,-97.5 78,-122.5 126,-122.5 126,-97.5 78,-97.5"/>
<text text-anchor="start" x="83.5" y="-106.3" font-family="Serif" font-size="14.00">Birth</text>
</g>
<!-- n1&%2345;&gt;n3 -->
<g id="e2" class="edge">
<title>n1:s&%2345;&gt;n3:n</title>
<path fill="none" stroke="black" d="M102,-159C102,-144.88 102,-140.1 102,-128.17"/>
<polygon fill="black" stroke="black" points="103.75,-128 102,-123 100.25,-128 103.75,-128"/>
</g>
<!-- n4 -->
<!-- Persist -->
<g id="n4" class="node">
<title>n4</title>
<polygon fill="lightblue" stroke="transparent" points="132,-62 72,-62 72,-37 132,-37 132,-62"/>
<polygon fill="none" stroke="black" points="72,-36.5 72,-61.5 132,-61.5 132,-36.5 72,-36.5"/>
<text text-anchor="start" x="77" y="-45.3" font-family="Serif" font-size="14.00">Persist</text>
</g>
<!-- n3&%2345;&gt;n4 -->
<g id="e3" class="edge">
<title>n3:s&%2345;&gt;n4:n</title>
<path fill="none" stroke="black" d="M114,-98C114,-82.98 104.48,-79.54 102.4,-67.05"/>
<polygon fill="black" stroke="black" points="104.14,-66.85 102,-62 100.65,-67.12 104.14,-66.85"/>
</g>
<!-- n3&%2345;&gt;n4 -->
<g id="e4" class="edge">
<title>n3:s&%2345;&gt;n4:n</title>
<path fill="none" stroke="black" d="M90,-98C90,-82.98 99.52,-79.54 101.6,-67.05"/>
<polygon fill="black" stroke="black" points="103.35,-67.12 102,-62 99.86,-66.85 103.35,-67.12"/>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="e6" class="edge">
<title>n4:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M87,-35.5C87,-28.82 76.68,-31.73 72,-36.5 53.14,-55.7 59.5,-107.9 69,-123 88.69,-154.29 124.31,-127.71 144,-159 149.8,-168.22 151.51,-175.62 144,-183.5 139.16,-188.57 129.77,-191.85 125.37,-189.24"/>
<polygon fill="black" stroke="black" points="126.81,-188.19 123,-184.5 123.68,-189.75 126.81,-188.19"/>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="e7" class="edge">
<title>n4:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M117,-35.5C117,-28.82 127.2,-31.85 132,-36.5 171.28,-74.58 141.33,-104.36 144,-159 144.53,-169.88 151.51,-175.62 144,-183.5 139.16,-188.57 129.77,-191.85 125.37,-189.24"/>
<polygon fill="black" stroke="black" points="126.81,-188.19 123,-184.5 123.68,-189.75 126.81,-188.19"/>
</g>
</g>
</svg>
'/><p>The second <code>for</code> loop is overwriting <code>curr</code> with <code>next</code> for all cells</p><pre><code class="language-julia hljs">next_step = agent(compose(rClearCurr, rCopyNext, rClearNext), Life(1); n=:Cell)

view_sched(next_step)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="262pt" height="290pt"
 viewBox="0.00 0.00 261.50 290.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 286)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-286 257.5,-286 257.5,4 -4,4"/>
<!-- n0in1 -->
<!-- n1 -->
<!-- Query Cell -->
<g id="n1" class="node">
<title>n1</title>
<polygon fill="yellow" stroke="transparent" points="161,-245 75,-245 75,-220 161,-220 161,-245"/>
<polygon fill="none" stroke="black" points="75,-219.5 75,-244.5 161,-244.5 161,-219.5 75,-219.5"/>
<text text-anchor="start" x="80" y="-228.3" font-family="Serif" font-size="14.00">Query Cell</text>
</g>
<!-- n0in1&%2345;&gt;n1 -->
<g id="e1" class="edge">
<title>n0in1:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M96,-281C96,-266.88 96,-262.1 96,-250.17"/>
<polygon fill="black" stroke="black" points="97.75,-250 96,-245 94.25,-250 97.75,-250"/>
</g>
<!-- n0out1 -->
<!-- n1&%2345;&gt;n0out1 -->
<g id="e10" class="edge">
<title>n1:s&%2345;&gt;n0out1:n</title>
<path fill="none" stroke="black" d="M89,-220C89,-196.74 62.54,-204.2 51,-184 39.98,-164.71 14.23,-50.21 12.14,-6.24"/>
<polygon fill="black" stroke="black" points="13.88,-5.95 12,-1 10.38,-6.04 13.88,-5.95"/>
</g>
<!-- n2 -->
<!-- Fail -->
<g id="n2" class="node">
<title>n2</title>
<polygon fill="red" stroke="transparent" points="253.5,-184 216.5,-184 216.5,-159 253.5,-159 253.5,-184"/>
<polygon fill="none" stroke="black" points="217,-158.5 217,-183.5 254,-183.5 254,-158.5 217,-158.5"/>
<text text-anchor="start" x="222" y="-167.3" font-family="Serif" font-size="14.00">Fail</text>
</g>
<!-- n1&%2345;&gt;n2 -->
<g id="e9" class="edge">
<title>n1:s&%2345;&gt;n2:n</title>
<path fill="none" stroke="black" d="M147,-220C147,-179.16 228.52,-222.6 235.52,-189.01"/>
<polygon fill="black" stroke="black" points="237.27,-189.14 236,-184 233.78,-188.81 237.27,-189.14"/>
</g>
<!-- n3 -->
<!-- ClearCurr -->
<g id="n3" class="node">
<title>n3</title>
<polygon fill="lightblue" stroke="transparent" points="160,-184 78,-184 78,-159 160,-159 160,-184"/>
<polygon fill="none" stroke="black" points="78,-158.5 78,-183.5 160,-183.5 160,-158.5 78,-158.5"/>
<text text-anchor="start" x="83" y="-167.3" font-family="Serif" font-size="14.00">ClearCurr</text>
</g>
<!-- n1&%2345;&gt;n3 -->
<g id="e8" class="edge">
<title>n1:s&%2345;&gt;n3:n</title>
<path fill="none" stroke="black" d="M119,-220C119,-205.88 119,-201.1 119,-189.17"/>
<polygon fill="black" stroke="black" points="120.75,-189 119,-184 117.25,-189 120.75,-189"/>
</g>
<!-- n4 -->
<!-- CopyNext -->
<g id="n4" class="node">
<title>n4</title>
<polygon fill="lightblue" stroke="transparent" points="159.5,-123 78.5,-123 78.5,-98 159.5,-98 159.5,-123"/>
<polygon fill="none" stroke="black" points="79,-97.5 79,-122.5 160,-122.5 160,-97.5 79,-97.5"/>
<text text-anchor="start" x="84" y="-106.3" font-family="Serif" font-size="14.00">CopyNext</text>
</g>
<!-- n3&%2345;&gt;n4 -->
<g id="e2" class="edge">
<title>n3:s&%2345;&gt;n4:n</title>
<path fill="none" stroke="black" d="M140,-159C140,-142.56 123.86,-141.38 120.58,-128.03"/>
<polygon fill="black" stroke="black" points="122.31,-127.77 120,-123 118.83,-128.17 122.31,-127.77"/>
</g>
<!-- n3&%2345;&gt;n4 -->
<g id="e3" class="edge">
<title>n3:s&%2345;&gt;n4:n</title>
<path fill="none" stroke="black" d="M98,-159C98,-142.15 115.76,-141.65 119.37,-128.13"/>
<polygon fill="black" stroke="black" points="121.12,-128.18 120,-123 117.65,-127.75 121.12,-128.18"/>
</g>
<!-- n5 -->
<!-- ClearNext -->
<g id="n5" class="node">
<title>n5</title>
<polygon fill="lightblue" stroke="transparent" points="159.5,-62 76.5,-62 76.5,-37 159.5,-37 159.5,-62"/>
<polygon fill="none" stroke="black" points="77,-36.5 77,-61.5 160,-61.5 160,-36.5 77,-36.5"/>
<text text-anchor="start" x="82" y="-45.3" font-family="Serif" font-size="14.00">ClearNext</text>
</g>
<!-- n4&%2345;&gt;n5 -->
<g id="e4" class="edge">
<title>n4:s&%2345;&gt;n5:n</title>
<path fill="none" stroke="black" d="M140,-98C140,-81.36 123.05,-80.51 119.61,-67.08"/>
<polygon fill="black" stroke="black" points="121.33,-66.76 119,-62 117.85,-67.17 121.33,-66.76"/>
</g>
<!-- n4&%2345;&gt;n5 -->
<g id="e5" class="edge">
<title>n4:s&%2345;&gt;n5:n</title>
<path fill="none" stroke="black" d="M99,-98C99,-81.56 115.14,-80.38 118.42,-67.03"/>
<polygon fill="black" stroke="black" points="120.17,-67.17 119,-62 116.69,-66.77 120.17,-67.17"/>
</g>
<!-- n5&%2345;&gt;n1 -->
<g id="e6" class="edge">
<title>n5:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M98,-35.5C98,-25.93 83.51,-29.99 76.5,-36.5 28.38,-81.14 32,-129.78 69,-184 93.75,-220.27 136.25,-183.73 161,-220 167.14,-228.99 168.51,-236.62 161,-244.5 156.16,-249.57 146.77,-252.85 142.37,-250.24"/>
<polygon fill="black" stroke="black" points="143.81,-249.19 140,-245.5 140.68,-250.75 143.81,-249.19"/>
</g>
<!-- n5&%2345;&gt;n1 -->
<g id="e7" class="edge">
<title>n5:s&%2345;&gt;n1:n</title>
<path fill="none" stroke="black" d="M140,-35.5C140,-26.82 153.06,-30.68 159.5,-36.5 180.03,-55.03 166.88,-70.42 169,-98 169.36,-102.65 176.93,-229.85 161,-244.5 155.84,-249.24 146.61,-252.69 142.31,-250.18"/>
<polygon fill="black" stroke="black" points="143.79,-249.2 140,-245.5 140.65,-250.76 143.79,-249.2"/>
</g>
</g>
</svg>
'/><p>We then compose these together and wrap in an overall <code>for</code> loop with a counter.</p><pre><code class="language-julia hljs">life(n::Int) = for_schedule(update_next ⋅ next_step, n) |&gt; F

const L = life(1) # Game of life simulation that runs just one (global) timestep

view_sched(L)</code></pre><img src="f4218140.svg" alt="Example block output"/><h2 id="Running-the-simulation"><a class="docs-heading-anchor" href="#Running-the-simulation">Running the simulation</a><a id="Running-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-simulation" title="Permalink"></a></h2><p>Make an initial state</p><pre><code class="language-julia hljs">G = make_grid([1 0 1 0 1; 0 1 0 1 0; 0 1 0 1 0; 1 0 1 0 1; 1 0 1 0 1])

view_life_graph(G)</code></pre><img src="a9979819.svg" alt="Example block output"/><p>(or, viewed in plaintext)</p><pre><code class="language-julia hljs">view_life(G) |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">| o | x | x | o | o |
| x | o | o | x | x |
| o | x | x | o | o |
| x | o | o | x | x |
| o | x | x | o | o |</code></pre><p>Run the simulation</p><pre><code class="language-julia hljs">res = interpret(L, G; maxstep=1000);</code></pre><p>Look at the end state</p><pre><code class="language-julia hljs">res[end][1] |&gt; codom |&gt; view_life |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">| x | o | o | o | x |
| o | o | o | x | x |
| o | x | x | o | x |
| o | o | o | x | x |
| x | o | o | o | x |</code></pre><p>Visualize the results in the <code>traj</code> folder</p><pre><code class="language-julia hljs">view_traj(L, res[1:10], view_life; agent=true)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../full_demo/">« Full Demo</a><a class="docs-footer-nextpage" href="../lotka_volterra/">Lotka Volterra »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 2 June 2024 01:10">Sunday 2 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
