var documenterSearchIndex = {"docs":
[{"location":"generated/game_of_life/#Conway's-Game-of-Life","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This is a demonstration of the game of life as an agent-based model.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We start with importing some libraries.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"using AlgebraicRewriting, Catlab, Test\nimport Catlab.Graphics: to_graphviz\nusing Catlab.Graphics.Graphviz: Attributes, Statement, Node, Edge, Digraph\nusing PrettyTables","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The game of life has two rules: one which turns living things dead, and one that brings dead things to life. We model the terrain as a symmetric graph: cells are vertices. Neighboring cells have edges between them.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Implementation wise, if we are going to update cells one at a time, we must keep track of two bits of information (the cell's living status for the current timestep and whether it will be alive in the next timestep). Thus we need helper rule to overwrite the \"current\" life status with the \"next\" life status at the end of each timestep.","category":"page"},{"location":"generated/game_of_life/#Ontology","page":"Conway's Game of Life","title":"Ontology","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Defining an ontology is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a Presentation, i.e. a database schema. Objects (Ob, or tables) are types of entities. Homs (Hom, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to Ob via attributes (Attr).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The schema below extends the schema for directed symmetric graphs, which consists in two tables (E and V, for edges and vertices) and two homs (src and tgt, E‚ÜíV). Furthermore a hom inv: E‚ÜíE enforces that each edge is paired with its opposite-pointing edge.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The schema below says there are two more types of entities, Curr and Next. Think of these as little tokens that can be assigned to vertices to mark them as currently-alive or to-be-alive-in-the-next-timestep, respectively. Thus, we can also thinking of them as picking out subsets of V via the maps curr and next.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@present SchLife <: SchSymmetricGraph begin\n  (Curr, Next)::Ob\n  curr::Hom(Curr, V)\n  next::Hom(Next, V)\nend\n\n@acset_type Life(SchLife, part_type=BitSetParts) <: AbstractSymmetricGraph\n\n\nconst ùí¢ = ACSetCategory(MADCSetCat(Life()))\n\nto_graphviz(SchLife; prog=\"dot\")","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We can further extend this schema with an additional attribute of (x,y) coordinates for every vertex. This is nice for visualization but is otherwise unnecessary when doing the actual agent-based modeling. So what we will do is build our model with the Life schema and then run our model with the LifeCoords schema.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@present SchLifeCoords <: SchLife begin\n  Coords::AttrType\n  coords::Attr(V, Coords)\nend\n\n@acset_type AbsLifeCoords(SchLifeCoords, part_type=BitSetParts) <: AbstractSymmetricGraph\n\nconst LifeCoords = AbsLifeCoords{Tuple{Int,Int}};\n\nconst ùí¢‚Ä≤ = ACSetCategory(MADVarACSetCat(LifeCoords()))","category":"page"},{"location":"generated/game_of_life/#Data-migration-functors","page":"Conway's Game of Life","title":"Data migration functors","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We ought to be able to take a state of the world (with no coordinate information) and obtain a state of the world with coordinates (the canonical way to do this is to assign \"variables\" for the values of the coordinates).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"F = Migrate(ùí¢‚Ä≤, SchLifeCoords, LifeCoords; delta=false); # adds coordinates\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"F‚Åª¬π = DeltaMigration(FinFunctor(id‚Çí, id‚Çò, SchLife, SchLifeCoords)); # removes coordinates","category":"page"},{"location":"generated/game_of_life/#Helper-functions","page":"Conway's Game of Life","title":"Helper functions","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Functions to help us create a grid.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function make_grid(curr::AbstractMatrix, next=nothing)\n  n, m = size(curr)\n  n == m || error(\"Must be square\")\n  X, coords = LifeCoords(), Dict()\n  for i in 1:n\n    for j in 1:n\n      coords[i=>j] = add_vertex!(X; coords=(i, j))\n      if Bool(curr[i, j])\n        add_part!(X, :Curr, curr=coords[i=>j])\n      end\n      if !isnothing(next) && Bool(next[i, j])\n        add_part!(X, :Curr, curr=coords[i=>j])\n      end\n    end\n  end\n  for i in 1:n\n    for j in 1:n\n      if i < n\n        add_edge!(X, coords[i=>j], coords[i+1=>j])\n      end\n      if j < n\n        add_edge!(X, coords[i=>j], coords[i=>j+1])\n      end\n      if i < n && j < n\n        add_edge!(X, coords[i=>j], coords[i+1=>j+1])\n      end\n      if i < n && j > 1\n        add_edge!(X, coords[i=>j], coords[i+1=>j-1])\n      end\n    end\n  end\n  X\nend\n\nmake_grid(n::Int, random=false) = make_grid((random ? rand : zeros)(Bool, (n, n)));\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Functions to help us visualize a grid. Although we have no such constraint, we'll expect any LifeCoords instance to be a regular grid (for the purposes of visualization). When that's the case, we can visualize the game state using plaintext.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function view_life(f::ACSetTransformation, pth=tempname())\n  v = collect(f[:V])\n  view_life(codom(f), pth; star=isempty(v) ? nothing : only(v))\nend\n\nfunction view_life(X::LifeCoords, pth=tempname(); star=nothing)\n  n = Int(sqrt(nparts(X, :V)))\n  coords = Dict([(i, j) => findfirst(==((i, j)), X[:coords])\n                 for (i, j) in Iterators.product(1:n, 1:n)])\n  mat = pretty_table(String, reduce(hcat, map(1:n) do i\n      map(1:n) do j\n        c, x = [!isempty(incident(X, coords[(i, j)], x)) for x in [:curr, :next]]\n        res = c ? (x ? \"O\" : \"o\") : (x ? \"X\" : \"x\")\n        return res * ((star == coords[(i, j)]) ? \".\" : \"\")\n      end\n    end); show_header=false, tf=tf_markdown)\n  open(pth, \"w\") do io\n    write(io, mat)\n  end\n  return mat\nend\n\ninit = make_grid(3,  true)\nview_life(init) |> println","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We can also visualize a grid with a distinguished agent. Here an agent living in a game state X is a map A ‚Üí X where A is the shape of the agent. The only kind of agent we'll consider in this model is that of a lone vertex.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Note that A below is defined without coordinates, whereas init is an instance of LifeCoords. So in order to relate them via a mapping (which requires them to share a schema) we promote A to LifeCoords using the data migration, F.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"A = Life(1)\nview_life(homomorphism(F(A), init; any=true)) |> println","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We must also work with miniature game states that are not grids in order for us to define the dynamics, as they are what the patterns and replacements of rewrite rules are made of. In order to visualize these, we will use another visualization function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function view_life_graph(X::Union{Life,LifeCoords}, pth=tempname(); star=nothing)\n  pg = PropertyGraph{Any}(; prog=\"neato\", graph=Dict(),\n    node=Dict(:shape => \"circle\", :style => \"filled\", :margin => \"0\"),\n    edge=Dict(:dir => \"none\", :minlen => \"1\"))\n  add_vertices!(pg, nparts(X, :V))\n  for v in vertices(X)\n    set_vprop!(pg, v, :fillcolor, isempty(incident(X, v, :curr)) ? \"red\" : \"green\")\n    isempty(incident(X, v, :next)) || set_vprop!(pg, v, :penwidth, \"4.0\")\n    set_vprop!(pg, v, :label, star == v ? \"*\" : \"\")\n  end\n  for e in filter(e -> X[e, :inv] > e, edges(X))\n    add_edge!(pg, X[e, :src], X[e, :tgt])\n  end\n  G = to_graphviz(pg)\n  open(pth, \"w\") do io\n    show(io, \"image/svg+xml\", G)\n  end\n  G\nend;\n\nview_life_graph(init)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Now we make some helper functions to construct important ACSets and maps between them. We start with a single vertex which is marked as to-be-alive in the next time step.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Next() = @acset Life begin V = 1; Next = 1; next = 1 end;\n\nview_life_graph(Next())","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We also want to refer to a vertex which is alive in the current time step","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Curr() = @acset Life begin V = 1; Curr = 1; curr = 1 end;\nview_life_graph(Curr())","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We also want these where we have a morphism incoming from a vertex.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"to_next() = homomorphism(Life(1), Next());\nto_curr() = homomorphism(Life(1), Curr());\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We make a helper for cells connected to n living neighbors","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function living_neighbors(n::Int; alive=false)\n  X = Life(1)\n  alive &&  add_part!(X, :Curr, curr=1)\n  for _ in 1:n\n    v = add_part!(X, :V)\n    add_part!(X, :Curr, curr=v)\n    add_edge!(X, v, 1)\n  end\n  X\nend\n\nview_life_graph(living_neighbors(3))","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We can control whether the central cell is itself alive or not","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"view_life_graph(living_neighbors(3; alive=true))","category":"page"},{"location":"generated/game_of_life/#Rules","page":"Conway's Game of Life","title":"Rules","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We have finished specifying what makes up a simulation state, and next is to define what sorts of transitions are possible. This is done by declaring rewrite rules.","category":"page"},{"location":"generated/game_of_life/#A-dead-cell-becomes-alive-iff-exactly-3-living-neighbors","page":"Conway's Game of Life","title":"A dead cell becomes alive iff exactly 3 living neighbors","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"BirthP1 = living_neighbors(3) # must have 3 neighbors\nBirthN1 = living_neighbors(4) # forbid the cell to have 4 neighbors\nBirthN2 = Curr() # forbid the cell to be alive (i.e. it's currently dead)\nBP1, BN1, BN2 = homomorphism.(Ref(Life(1)), [BirthP1, BirthN1, BirthN2]; initial=(V=[1],))\nbac = [PAC(BP1; monic=true), NAC.([BN1, BN2]; monic=true)...]\nBirth = Rule(id[ùí¢](Life(1)), to_next(); ac=bac, cat=ùí¢);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#A-living-cell-stays-alive-iff-2-or-3-living-neighbors","page":"Conway's Game of Life","title":"A living cell stays alive iff 2 or 3 living neighbors","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"PersistR = @acset Life begin\n  V = 1; Curr = 1; Next = 1; curr = 1; next = 1\nend\nPersistP1 = living_neighbors(2; alive=true)\nPersistN1 = living_neighbors(4; alive=true)\nDR, DP1, DN1 = homomorphism.(Ref(Curr()), [PersistR, PersistP1, PersistN1]; initial=(V=[1],))\npac = [PAC(DP1; monic=true), NAC(DN1; monic=true)]\nPersist = Rule(id[ùí¢](Curr()), DR; ac=pac, cat=ùí¢);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#remove-\"Curr\"-status","page":"Conway's Game of Life","title":"remove \"Curr\" status","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"ClearCurr = Rule(to_curr(), id[ùí¢](Life(1)); cat=ùí¢);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#remove-\"Next\"-status","page":"Conway's Game of Life","title":"remove \"Next\" status","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"ClearNext = Rule(to_next(), id[ùí¢](Life(1)); cat=ùí¢);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Copy-\"Next\"-to-\"Curr\"","page":"Conway's Game of Life","title":"Copy \"Next\" to \"Curr\"","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"CopyNext = Rule(to_next(), to_curr(); cat=ùí¢);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Assembling-rules-into-a-recipe","page":"Conway's Game of Life","title":"Assembling rules into a recipe","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Now we can assemble our building blocks into a large wiring diagram characterizing the flow of the overall ABM simulation. In addition to the blue rewrite rule blocks, we have yellow Query blocks which execute subroutines once per agent (the second output wire) before exiting (the first output wire).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Give symbolic names to the rewrite rules from before","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"rules = [:Birth => Birth, :Persist => Persist, :ClearCurr => ClearCurr,\n  :ClearNext => ClearNext, :CopyNext => CopyNext];\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"All rules have interface of a single distinguished cell, i.e. they are executed from the perspective an agent which is a particular distinguished vertex.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Normally we can consider branching possibilities depending on whether or not the rewrite is successful, but in this simulation we don't do this. tryrule simply merges the two output wires from a rewrite rule box into a single output wire.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"rBirth, rPersist, rClearCurr, rClearNext, rCopyNext =\n  [tryrule(RuleApp(n, r, Life(1))) for (n, r) in rules]\n\nview_sched(rBirth)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The first for loop is computing next for all cells","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"update_next = agent(rBirth ‚ãÖ rPersist, Life(1); n=:Cell)\n\nview_sched(update_next)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The second for loop is overwriting curr with next for all cells","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"next_step = agent(compose(rClearCurr, compose(rCopyNext, rClearNext)), Life(1); n=:Cell)\n\nview_sched(next_step)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We then compose these together and wrap in an overall for loop with a counter.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"life(n::Int) = for_schedule(update_next ‚ãÖ next_step, n) |> F\n\nconst L1 = life(1); # Game of life simulation that runs just one (global) timestep\n\nview_sched(L1)","category":"page"},{"location":"generated/game_of_life/#Running-the-simulation","page":"Conway's Game of Life","title":"Running the simulation","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Make an initial state","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"G = make_grid([1 0 1 0 1; 0 1 0 1 0; 0 1 0 1 0; 1 0 1 0 1; 1 0 1 0 1])\n\nview_life_graph(G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"(or, viewed in plaintext)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"view_life(G) |> println","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Run the simulation","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"res = interpret(L1, G; maxstep=1000, cat=ùí¢‚Ä≤);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Look at the end state","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"res[end][1] |> codom |> view_life |> println","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Visualize the results in the traj folder","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"view_traj(L1, res[1:10], view_life; agent=true)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Rewrite","page":"Library Reference","title":"Rewrite","text":"","category":"section"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{CGraph}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate","text":"Apply migration to all literals in the constraint\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.BoolAnd","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.BoolAnd","text":"Conjunction of multiple expressions\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.BoolConst","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.BoolConst","text":"Constant, independent of context\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.BoolExpr","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.BoolExpr","text":"Something that, in a context, can be evaluated to a bool\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.BoolNot","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.BoolNot","text":"Negation of an expression\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.BoolOr","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.BoolOr","text":"Disjunction of multiple expressions\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.CGraph","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.CGraph","text":"\"nothing\" means something that will be determined via a quantifier Ints are explicit arguments provided when apply_constraint is called\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.Commutes","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.Commutes","text":"A commutative diagram with multiple parallel paths, asserted to either  commute or to not commute\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.Constraint","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.Constraint","text":"A constraint graph and a BoolExpr (which refers to the constraint graph)\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.Quantifier","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.Quantifier","text":"Quantified edge\n\ne - which edge is filled in kind - Exists, Forall, or Exists!  st - \"such that\", restrict the domain of quantification via a condition monic - restrict domain of quanitification to only monic matches\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.AppCond","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.AppCond","text":"Constraint a constraint that asserts (or denies) the existence of a  triangle commuting.\n\n f‚ÇÅ\n\n(1) <- (2)    ‚àÉ‚ÇÇ‚Üò  ‚Üì Œª‚ÇÉ       (3)\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.LiftCond-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.LiftCond","text":"  ‚àÄ‚ÇÇ\n\n(1)  ‚Üí  (3)  ‚ÇÅ‚Üì  ‚Üó‚àÉ‚ÇÉ  ‚Üì Œª‚ÇÖ  (2)  ‚Üí  (4)       ‚Å¥\n\nTest a map (3)‚Üí(4), given maps (1)->(2)->(4). \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.arity-Tuple{CGraph}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.arity","text":"Number of variables in a constraint graph\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.check_expr-Tuple{CGraph, Commutes}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.check_expr","text":"Validate a commutative diagram constraint makes sense\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr-Tuple{Commutes, CGraph, Vector{Union{Nothing, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}}}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr","text":"Check whether homs are equal by looping over domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.get_ob-Tuple{CGraph, Int64, Vector{Union{Nothing, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}}}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.get_ob","text":"Get the C-Set associated with a vertex in a CGraph\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Constraints.merge_graphs-Tuple{Any, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Constraints.merge_graphs","text":"Take two CGraphs and merge them along their overlapping vertices and edges Returns an ACSetColimit\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.Theories.:‚äï-Tuple{Constraint, Constraint}","page":"Library Reference","title":"Catlab.Theories.:‚äï","text":"Combine two constraints disjunctively, sharing as much of the computation graph  as possible.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.Theories.:‚äó-Tuple{Constraint, Constraint}","page":"Library Reference","title":"Catlab.Theories.:‚äó","text":"Combine two constraints conjunctively, sharing as much of the computation graph  as possible (i.e. pushout along the maximum common subgraph)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.Rule","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.Rule","text":"Rewrite rules which are (usually) encoded as spans.  The L structure encodes a pattern to be matched.  The R morphism encodes a replacement pattern to be substituted in. They are related to each other by an interface I with maps: L ‚üµ I ‚ü∂ R \n\nA semantics (DPO, SPO, CoNeg, or SqPO) must be chosen.\n\nControl the match-finding process by specifying whether the match is intended to be monic or not, as well as an optional application condition(s) \n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.can_match-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.can_match","text":"Returns nothing if the match is acceptable for rewriting according to the rule, otherwise returns the reason why it should be rejected\n\nhomsearch = if we know ahead of time that m was obtained m via automatic hom              search, then we do not need to make certain checks\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.freevars-Union{Tuple{T}, Tuple{Rule{T}, Symbol}} where T","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.freevars","text":"Get a list of AttrVar indices which are NOT bound by the I‚ÜíR morphism\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Any, Any}} where T","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map","text":"Don't bind variables for things that are not ACSets\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Any}} where T","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map","text":"Given the match morphism and the result, construct a map X ‚Üí X‚Ä≤ which  binds any free variables introduced into the result.\n\nL <- I -> R  m ‚Üì    ‚Üì    ‚Üì res   G <- ‚Ä¢ -> X              ‚Üì               X‚Ä≤\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_match-Tuple","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_match","text":"Get one match (if any exist) otherwise return \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{Rule, ACSets.ACSetInterface.ACSet}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_matches","text":"Get list of possible matches based on the constraints of the rule\n\nThis function has the same behavior as the generic get_matches, but it is  more performant because we do not have to query all homomorphisms before finding  a valid match, in case n=1. \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{Rule, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_matches","text":"If not rewriting ACSets, we have to compute entire Hom(L,G).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_pmap-Tuple{Symbol, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_pmap","text":"Extract the partial map (derived rule) from full output data\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_rmap-Tuple{Symbol, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_rmap","text":"Extract the map from the R to the result from the full output data\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.rewrite-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.rewrite","text":"rewrite(r::Rule, G; kw...)\n\nPerform a rewrite (automatically finding an arbitrary match) and return result.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.rewrite_match-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.rewrite_match","text":"rewrite_match(r::Rule, m; kw...)\n\nPerform a rewrite (with a supplied match morphism) and return result.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:DPO}, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps","text":"rewrite_match_maps(r::Rule{:DPO}, m)\n\nApply a DPO rewrite rule (given as a span, L<-I->R) to a ACSet using a match morphism m which indicates where to apply the rewrite.               l   r            L <- I -> R          m ‚Üì    ‚Üì    ‚Üì            G <- K -> H\n\nThis works for any type that implements pushout_complement and pushout\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:CoNeg}, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps","text":"rewrite_match_maps(r::Rule{:CoNeg}, m)\n\nApply a CoNegation rewrite rule (given as a span, L‚Ü©I->R) to a ACSet using a monic match morphism m which indicates where to apply the rewrite.               l   r            L <- I -> R          m ‚Üì    ‚Üì    ‚Üì            G <- K -> H   where  K = ~L ‚à® I\n\nThis works for any type that implements bi-Heyting logic operators ~ and ‚à®.\n\nThis is described here. Essentially, it is partway between DPO and SPO. Suppose the rule tries to delete two things, one of which satisfies the dangling condition, the other violates it. While DPO would fail to apply at all, and SPO would delete both things (cascading  the deletion for the latter), co-negation rewriting would simply delete the item  which can be deleted without cascading and ignore the other element.\n\nIt includes a quote which indicates that this method should work even when the  match morphism isn't monic, if it satisfies the identification condition.  Supporting this is not yet implemented.\n\nMatch morphisms which bind attribute variables are not monic, hence we this  form of rewriting doesn't support VarACSets. Intuitively, it feels like this  restriction could be relaxed.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.SPO.partial_pushout-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, <:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, <:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.SPO.partial_pushout","text":"C ‚Üê Ag ‚Ü™ A ‚Ü© Af ‚Üí B \n\nA ‚Ü© f‚àág ‚Üí Bgf ‚Ü™ B       ‚Üì   ‚åú ‚Üì C ‚Ü© Cfg -> D\n\nImplementation of Construction 6 in L√∂we's  \"Algebraic approach to SPO graph transformation\"\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.ComposableHoms.ComposablePair{Ob, Hom} where {Ob, Hom}}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement","text":"See Theorem 2 of 'Concurrency Theorems for Non-linear Rewriting Theories'       f   B <‚Äì- A m ‚Üì      ‚Üì n   C <‚Äì  D      g\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:SqPO}, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps","text":"rewrite_match_maps(r::Rule{:SqPO},m; pres::Union{Nothing, Presentation}=nothing)\n\nSesqui-pushout is just like DPO, except we use a final pullback complement instead of a pushout complement.\n\nr.L  r.R\n\nL <-‚åûK -> R m ‚Üì    ‚Üìk   ‚Üì r   I <- ‚Ä¢ ->‚åúO      i   o\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.PBPO.PBPORule","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.PBPO.PBPORule","text":"  l    r\n\nL  ‚üµ K ‚ü∂ R  tl ‚Üì     ‚Üì tk     <== tl, tk must be monic     L' ‚üµ K'\n\nIt is assumed we never want the typing/adherence match to be monic, but we  can optionally restrict the match L ‚Üí G to be monic.\n\nWe can attach application conditions to both the match morphism as well as the  adherence morphism. Until morphism search under constraints becomes efficient, it's sometimes needed to just directly state the adherence morphism as a  function of the match morphism.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.Rewrite.PBPO.canon-NTuple{5, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.PBPO.canon","text":"Take a PBPO rule and put into normal form, i.e.  where the lower square forms a pullback\n\nSee Prop 2.4 of \"The PBPO graph transformation approach\"\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.PBPO.partial_abstract-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.PBPO.partial_abstract","text":"This construction addresses the following problem: ideally when we 'abstract'  an ACSet from X to A->X, maps into X, say B->X, can be canonically pulled back  to maps B->A which commute. However, A won't do  here, because there may not even exist any maps B->A. If B has concrete  attributes, then those cannot be sent to an AttrVar in A. Furthermore, if B  has multiple 'references' to an AttrVar (two different edges, each with  AttrVar(1), sent to two different edges with the same atttribute value in X),  then there is no longer a canonical place to send AttrVar(1) to in A, as there  is a distinct AttrVar for every single part+attr in X. So we need a construction  which does two things to A->X, starting with a map B->X. 1.) replaces exactly the  variables we need with concrete values in order to allow a map B->A, 2.) quotients  variables in A so that there is exactly one choice for where to send attrvars in  B such that the triangle commutes.\n\nStarting with a map L -> G (where G has no AttrVars),  we want the analogous map into a \"partially abstracted\" version of G that  has concrete attributes replaced with AttrVars EXCEPT for those attributes  which are mapped to by concrete attributes of L. Likewise, multiple occurences  of the same variable in L correspond to AttrVars which should be merged in the  partially-abstracted G.\n\nFor example, for a schema with a single Ob and Attr (where all combinatorial  maps are just {1‚Ü¶1, 2‚Ü¶2}):\n\nL = [AttrVar(1), :foo]\nG = [:bar, :foo, :baz]\nabs(G) = [AttrVar(1), AttrVar(2), AttrVar(3)]\nexpected result: [AttrVar(1), :foo, AttrVar(2)]\nL  -> Partial_abs(G)  ‚Üì          ‚Üë  G  <-   abs(G)\n\nThis function computes the top arrow of this diagram starting with the left  arrow. The bottom arrow is computed by abstract_attributes and the right  arrow by sub_vars. Furthermore, a map from Partial_abs(G) to G is provided.\n\nThis is the factorization system arising from a coreflective subcategory.\n\n(see https://ncatlab.org/nlab/show/reflective+factorization+system  and https://blog.algebraicjulia.org/post/2023/06/varacsets/)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.PBPO.test_adherence-Tuple{PBPORule, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.PBPO.test_adherence","text":"See get_matches(::PBPORule, ::ACSet) \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Tuple{PBPORule, Any, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map","text":"Use exprs and k_exprs to fill in variables introduced by applying the rw rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{PBPORule, ACSets.ACSetInterface.ACSet}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_matches","text":"PBPO matches consist of two morphisms. First, a match m: L ‚Üí G, and secondly  a typing G ‚Üí L‚Ä≤. With attributes, it is not so simple because G has concrete  values for attributes and L‚Ä≤ may have variables. Therefore, we actually change the  typing to map out of A, an abstracted version of G (with its attributes replaced  by variables). So we lift matches L->G to matches L->A, then search Œ±‚ààHom(A,L‚Ä≤).\n\nIn general, we want Œ± to be uniquely determined by m, so by default Œ±_unique   is set to true.\n\n m\n\nL‚åü ‚ü∂ G   ||     ‚Üì Œ±   L  ‚ü∂ L‚Ä≤      tl\n\n m\n\nL ‚ü∂ G  tl ‚Üì ‚Üòa ‚Üë (abs = partial abstraction. Note a is Labs in the code.)    L‚Ä≤‚üµ A        Œ±\n\nThe \"strong match\" condition we enforce is that: tl‚Åª¬π(Œ±(A)) = a‚Åª¬π(A). This means  we can deduce precisely what m is by looking at Œ±.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{PBPORule, Any}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps","text":"         r\n      K ----> R\ng‚Çó    u ‚Üì g·µ£ ‚åú ‚Üì w\n\nG‚Çó <‚Äì‚Äì Gk ‚Äì‚Äì> G·µ£ Œ± ‚Üì    ‚åû ‚Üì u'  L‚Ä≤ <‚Äì  K‚Ä≤      t‚Çó\n\nFor the adherence morphism Œ± to be valid, it must satisfy a condition with  m, t‚Çó. This is checked for matches provided by get_matches, so by default  we do not check it.\n\nL <‚Äì‚åû‚Ä¢ m ‚Üì     ‚Üì   G ‚üµ Gk\n\nSee Lemma 7.2 of \"TERMINATION OF GRAPH TRANSFORMATION SYSTEMS USING WEIGHTED  SUBGRAPH COUNTING\" by Overbeek and Endrullis (2023)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Migration.pres_hash-Tuple{GATlab.Models.Presentations.Presentation}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Migration.pres_hash","text":"Want a filename that is stable to multiple Julia sessions but changes when the schema changes. This minimizes the need to clear the cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#Schedules","page":"Library Reference","title":"Schedules","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [\n  AlgebraicRewriting.Theories,\n  AlgebraicRewriting.Poly,\n  AlgebraicRewriting.Wiring,\n  AlgebraicRewriting.Eval,\n  AlgebraicRewriting.Basic,\n  AlgebraicRewriting.Conditionals,\n  AlgebraicRewriting.RuleApps,\n  AlgebraicRewriting.Queries,\n  AlgebraicRewriting.Visuals\n]","category":"page"},{"location":"api/#CategoricalAlgebra","page":"Library Reference","title":"CategoricalAlgebra","text":"","category":"section"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#243","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#243","text":"Compute a pushout complement of finite sets, if possible.\n\nGiven functions l I  L and m L  G to form a pushout square\n\nl\n\nL ‚Üê I m ‚Üì   ‚Üìk   G ‚Üê K     g\n\ndefine the set K = G  m(L  l(I)) and take g K  G to be the inclusion. Then the map k I  K is determined by the map lm I  G from the requirement that the square commutes.\n\nPushout complements exist only if the identification condition is satisfied. An error will be raised if the pushout complement cannot be constructed. To check this in advance, use can_pushout_complement.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#249","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#249","text":"Compute a pushout complement of finite sets, if possible.\n\nGiven functions l I  L and m L  G to form a pushout square\n\nl\n\nL ‚Üê I m ‚Üì   ‚Üìk   G ‚Üê K     g\n\ndefine the set K = G  m(L  l(I)) and take g K  G to be the inclusion. Then the map k I  K is determined by the map lm I  G from the requirement that the square commutes.\n\nFor example, if L = I = {1} and G = {1,2}, then  l({1}) = {1}, L ‚àñ l(I) = {} and G‚àñ m({}) = {1,2}.\n\nPushout complements exist only if the identification condition is satisfied. An error will be raised if the pushout complement cannot be constructed. To check this in advance, use can_pushout_complement.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#252","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#252","text":"Because l is monic, the map l:I+T ‚Ü£ L+T secretly is just a map l‚Ä≤:I‚Ü£L and T=T\n\nWe'll also assume that the map m: L+T->G+T is secretly just a map L->T (G=‚àÖ).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.BasicSets.FinDomFunctions.FinDomFunction, Catlab.BasicSets.FinDomFunctions.FinDomFunction}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition","text":"Kleisli composition \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.BasicSets.FinFunctions.FinFunction, Catlab.BasicSets.FinFunctions.FinFunction}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition","text":"Check identification condition for pushout complement of finite sets.\n\nThe identification condition says that the functions do not map (1) both a deleted item and a preserved item in L to the same item in G or (2) two distinct deleted items to the same item. It is trivially satisfied for injective functions.\n\nReturns pair of iterators of\n\n(1) a nondeleted item that maps to a deleted item in G   (2) a pair of distinct items in L that are deleted yet mapped to the same       item in G.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate","text":"TODO: check if functorial\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.##docsink#255","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.##docsink#255","text":"Compute pushout complement of attributed C-sets, if possible.\n\nThe pushout complement is constructed pointwise from pushout complements of finite sets. If any of the pointwise identification conditions fail (in FinSet), this method will raise an error. If the dangling condition fails, the resulting C-set will be only partially defined. To check all these conditions in advance, use the function can_pushout_complement.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj-Tuple{ACSets.ACSetInterface.ACSet, Any}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj","text":"Recursively delete anything, e.g. deleting a vertex deletes its edge\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb-NTuple{4, Any}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb","text":"Y   i‚Üò  f_     X ‚Üí ‚Ä¢  g_ ‚Üì ‚åü ‚Üì f     ‚Ä¢ ‚Üí ‚Ä¢          g\n\nCheck whether (X, f,g) is the pullback of (f,g), up to isomorphism (i.e. the  pullback of f and g produces (Y,œÄ‚ÇÅ,œÄ‚ÇÇ), where Y is isomorphic to X and  i‚ãÖf_ = œÄ‚ÇÅ & i‚ãÖg_ = œÄ‚ÇÇ.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.fibers-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.fibers","text":"Every morphism induces a partition of the parts of the domain. This function  finds every nontrivial partition (size greater than one element) for the objects of the schema.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom","text":"Invert a morphism which may not be monic nor epic. When the morphism is not  monic, an arbitrary element of the preimage is mapped to. When it is not epic, a completely arbitrary element is mapped to.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso","text":"Invert some (presumed iso) components of an ACSetTransformation (given by s)\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.lift_morphism_constraints-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.lift_morphism_constraints","text":"Given   f: A->C and g: B->C, find all morphisms A->B that make the triangle commute \n\n                ??? \n              A  ‚áâ  B \n              f ‚Üò ‚Üô g\n                 C\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars","text":"Given a value for each variable, create a morphism X ‚Üí X‚Ä≤ which applies the  substitution. We do this via pushout.\n\nO ‚Äì> X    where C has AttrVars for merge equivalence classes    ‚Üì          and O has only AttrVars (sent to concrete values or eq classes    C          in the map to C.\n\nsubs and merge are dictionaries keyed by attrtype names\n\nsubs values are int-keyed dictionaries indicating binding, e.g.  ; subs = (Weight = Dict(1 => 3.20, 5 => 2.32), ...)\n\nmerge values are vectors of vectors indicating equivalence classes, e.g. ; merge = (Weight = [[2,3], [4,6]], ...)\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.var_eqs-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.var_eqs","text":"Further induced equations between AttrVars, given a specific match morphism\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback-Union{Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multicospan{var\"#s110\", Hom, Foot, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, <:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {var\"#s110\"<:(ACSets.DenseACSets.StructACSet{S, Ts}), Hom, Foot}}, Tuple{Ts}, Tuple{S}} where {S, Ts}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback","text":"Take an ACSet pullback combinatorially and freely add variables for all  attribute subparts.\n\nThis relies on implementation details of abstract.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom","text":"A component-wise map between two cospans. The first component given is the apex map, with the following maps being the legs.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule","text":"A span of StructuredMulticospanHoms, interpreted as a DPO rewrite rule\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Tuple{openrule, openrule}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_","text":"composeH_(r‚ÇÅ, r‚ÇÇ)\n\ncompose two rewrite rules horizontally (via pushouts) as shown below:     L‚ÇÅ‚Çã‚Çç‚Çô‚Çã‚ÇÅ‚Çé-> L <- L‚Çô    X‚ÇÅ -> X <- X‚ÇÇ‚Çã‚Çò     L‚ÇÅ‚Çã‚Çç‚Çô‚Çã‚ÇÅ‚Çé -> L +L‚Çô X <- X‚ÇÇ‚Çã‚Çò     ‚Üë        Œª ‚Üë    ‚Üë     ‚Üë    ‚Üë œá    ‚Üë          ‚Üë           ‚Üë        ‚Üë     I‚ÇÅ‚Çã‚Çç‚Çô‚Çã‚ÇÅ‚Çé-> I <- I‚Çô ‚àòh Y‚ÇÅ -> Y <- Y‚ÇÇ‚Çã‚Çò  =  I‚ÇÅ‚Çã‚Çç‚Çô‚Çã‚ÇÅ‚Çé -> I +I‚Çô Y <- Y‚ÇÇ‚Çã‚Çò     ‚Üì        œÅ ‚Üì    ‚Üì     ‚Üì    ‚Üì Œ∂    ‚Üì          ‚Üì           ‚Üì        ‚Üì     R‚ÇÅ‚Çã‚Çç‚Çô‚Çã‚ÇÅ‚Çé-> R <- R‚Çô    Z‚ÇÅ -> Z <- Z‚ÇÇ‚Çã‚Çò     R‚ÇÅ‚Çã‚Çç‚Çô‚Çã‚ÇÅ‚Çé -> R +R‚Çô Z <- Z‚ÇÇ‚Çã‚Çò\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Union{Tuple{L}, Tuple{Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan{L}, Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan{L}}} where L","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_","text":"Cospan composition given by pushout\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, <:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, <:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_","text":"Finset span composition given by pullback\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{openrule, openrule}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_","text":"composeV_(r‚ÇÅ, r‚ÇÇ)\n\ncompose two rewrite rules vertically with pullbacks, as shown below:        L‚ÇÅ‚Çã‚Çô -> L        ‚Üë       ‚Üë        I‚ÇÅ‚Çã‚Çô -> I        ‚Üì       ‚Üì         L‚ÇÅ‚Çã‚Çô        ->   L        R‚ÇÅ‚Çã‚Çô -> R           ‚Üë              ‚Üë            ‚àòv      = I‚ÇÅ‚Çã‚Çô √ó·µ£‚ÇÅ‚Çã‚Çô  Œò‚ÇÅ‚Çã‚Çô -> I √ó·µ£ Œò        Œõ‚ÇÅ‚Çã‚Çô -> Œõ           ‚Üì              ‚Üì        ‚Üë       ‚Üë         Œ©‚ÇÅ‚Çã‚Çô        ->   Œ©        Œò‚ÇÅ‚Çã‚Çô -> Œò        ‚Üì       ‚Üì        Œ©‚ÇÅ‚Çã‚Çô -> Œ©\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_-Union{Tuple{L_}, Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, <:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb{L_}}} where L_","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_","text":"Pass dummy value in because a span of invertible FinFunctions does not retain L type\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_-Union{Tuple{Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb{L}}, Tuple{L}} where L","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_","text":"Vertical arrows are spans of invertible finfunctions\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement-Tuple{openrule, StructuredMultiCospanHom}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement","text":"Initial data: 4 structured cospans + 3 cospan morphisms: Œº, Œª, œÅ      g G‚ÇÅ‚Çã‚Çô ‚Äì> G ‚Üë    l  ‚Üë Œº L‚ÇÅ‚Çã‚Çô ‚Äì> L ‚Üë    i  ‚Üë Œª I‚ÇÅ‚Çã‚Çô ‚Äì> I ‚Üì    r  ‚Üì œÅ R‚ÇÅ‚Çã‚Çô ‚Äì> R\n\nComputed data: 2 new structured cospans + 4 cospan morphisms: Œ≥, Œ∑, ik, rh         G‚ÇÅ‚Çã‚Çô      G           ‚Üë    k  ‚Üë Œ≥   ik  I‚ÇÅ‚Çã‚Çô -> K‚ÇÅ‚Çã‚Çô  ‚Äì> K    <‚Äì I           ‚Üì    h  ‚Üì Œ∑   rh  R‚ÇÅ‚Çã‚Çô -> H‚ÇÅ‚Çã‚Çô  ‚Äì> H    <‚Äì R In the context of the legs of a multicospan, the indices 1-n refer to the n legs of the cospan. In the context of a map of multicospans, there are 1-(n+1) maps, with the first one designating the map of the apexes. Hence it can make sense to have the elements: zip(legs, maps[2:end]) = [(leg·µ¢, map·µ¢), ...]\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite-Tuple{openrule, StructuredMulticospan}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite","text":"Apply a rewrite rule to a structured multicospan, where a matching cospan homomorphism is found automatically. If multiple matches are found, a particular one can be selected using m_index. Returns nothing if none are found.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match-Tuple{openrule, StructuredMultiCospanHom}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match","text":"Extract the rewritten structured cospan from the induced rewrite rule\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.CategoricalAlgebra.Pointwise.HomSearch.homomorphisms-Union{Tuple{L}, Tuple{StructuredMulticospan{L}, StructuredMulticospan{L}}} where L","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Pointwise.HomSearch.homomorphisms","text":"Find homomorphisms between structured cospans. These are constrained to be iso on the legs of the cospans. Solving this w/ homomorphism finding  requires a dynamic acset, and the current hack will be replaced once those are available.\n\nA homomorphism backend that uses SAT/SMT would also make this viable to do without hacking.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs-Tuple{ACSets.DenseACSets.StructACSet, GATlab.Models.Presentations.Presentation, Symbol, Int64}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs","text":"Confirm a C-Set satisfies its equational axioms\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path-Tuple{ACSets.DenseACSets.StructACSet, Any, Int64}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path","text":"Take a GATExpr (an id morphism, a generator, or a composite) and evaluate, starting at a particular point.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta-Tuple{ACSets.DenseACSets.StructCSet}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta","text":"The natural injection from X ‚ü∂ T(X) When evaluated on the terminal object, this gives the subobject classfier.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property","text":"A partial function is defined by the following span:                           m   f                         A ‚Ü© X ‚Üí B\n\nWe compute œï(m,f): A ‚ü∂ T(B) such that the following is a pullback square:      f   X  ‚ü∂ B m ‚Üì     ‚Üì Œ∑(B)   A  ‚ü∂ T(B)      œï\n\nEssentially, œï sends elements of A to the 'real' values in T(B) when A is in the subobject picked out by X. When A is 'deleted', it picks out the right element of the additional data added by T(B).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom","text":"Because the functorial embedding of objects keeps a copy of the original data, what to do with morphisms is just carry them along. Because our implementation adds all of the additional stuff afterwards, index-wise, we can use literally the same data for a morphism lifted from X‚ü∂Y to T(X)‚ü∂T(Y).\n\nHowever, we still need to map the extra stuff in T(X) to the proper extra stuff in T(Y).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob-Tuple{ACSets.DenseACSets.StructCSet}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob","text":"A functor T, playing the role of Maybe in Set, but generalized to C-Sets.\n\nWhen called on the terminal object, this produces the subobject classifier: See Mulry \"Partial map classifiers and cartesian closed categories\" (1994)\n\nThis function specifies what T does on objects. The key properties:\n\nfor all X ‚àà Ob(C), Œ∑(X):X‚ü∂T(X) is monic.                 m   f                                    œï(m,f)\nfor each span A ‚Ü© X ‚Üí B, there exists a unique morphism A ‚ü∂ T(B) such that (m,f) is the pullback of œï(m,f),Œ∑(B))\n\nNot only do we add an extra element to each component of the C-Set, but we need to consider the possibility that a component (with n outgoing morphisms) has any combination of the targets of those morphisms deleted (like the subobject classifier, there are different ways for something to be deleted).\n\nFor example, in Graph, an edge can be deleted that goes between any two vertices of the graph. We can't map all deleted edges to the same point in T(E) (if we're going to satisfy that desired property #2), so we need an extra edge in T(E) for every possibility (from V1 to V2, from V1 to V3, ..., from [Deleted] to V1, ..., from V2 to [Deleted], ... from [Deleted] to [Deleted]), where [Deleted] is our name for the extra element added to T(V).\n\n                [src]     [tgt]\n\nThus, T(E) ‚âÖ |E| + (|V|+1) √ó (|V|+1).\n\nIn general, T(X) ‚âÖ |X| + ‚àè‚Çï(|T(codom(h))|) for each outgoing morphism h::X‚ü∂Y\n\nthe |X| corresponds to the 'real' elements of X\nthe second term corresponds to the possible ways an X can be deleted.\nThis recursive formula means we require the schema of the C-set to be acyclic otherwise the size is infinite (assumes schema is free).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs-Tuple{Any}","page":"Library Reference","title":"AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs","text":"Get topological sort of objects of a schema. Fail if cyclic.\n\n\n\n\n\n","category":"method"},{"location":"generated/lotka_volterra/#Lotka-Volterra","page":"Lotka Volterra","title":"Lotka Volterra","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"This is a demonstration of a predator-prey agent-based model.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We start with importing some libraries.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"using Catlab, AlgebraicRewriting\nusing Random, Test\n\nusing Catlab.Graphics.Graphviz: Attributes, Statement, Node\nimport Catlab.Graphics.Graphviz\n\nconst hom = homomorphism\nconst AV = AttrVar\nconst AV1 = AttrVar(1)\n\nRandom.seed!(123);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Ontology","page":"Lotka Volterra","title":"Ontology","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Defining an ontology is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a Presentation, i.e. a database schema. Objects (Ob, or tables) are types of entities. Homs (Hom, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to Ob via attributes (Attr).","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"The schema below extends the schema for directed graphs, which consists in two tables (E and V, for edges and vertices) and two homs (src and tgt, E‚ÜíV). It says there are two more types of entities, Sheep and Wolf, and they can be thought of as living on the graph due to homs sheep_loc and wolf_loc which assign each of them a vertex.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Furthermore, we want to give these entities some attributes. In this model, wolves and sheep both have \"energy\", given by Eng (a type variable, which we'll later instantiate with Int). Also, grass lives on vertices, and it's represented by an integer. countdown being zero means the grass is ready to eat, whereas a value above zero represents a counter of time the grass needs until it grows back.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"There is also a direction attribute type, and the edges (as well as animals) will be oriented in a particular direction at any point in time.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"@present SchLV <: SchGraph begin\n  (Sheep, Wolf)::Ob\n  sheep_loc::Hom(Sheep, V); wolf_loc::Hom(Wolf, V)\n\n  Time::Ob\n  countdown::Hom(Time, V);\n\n  Eng::AttrType\n  sheep_eng::Attr(Sheep, Eng); wolf_eng::Attr(Wolf, Eng)\n\n  Dir::AttrType\n  dir::Attr(E, Dir); sheep_dir::Attr(Sheep, Dir); wolf_dir::Attr(Wolf, Dir)\nend\n\n# efficient ABM rewriting uses BitSetParts rather than DenseParts to allow\n# in-place pushout rewriting, rather than pure/non-mutating pushouts.)\n@acset_type LV_Generic(SchLV, part_type=BitSetParts) <: HasGraph\nconst LV = LV_Generic{Int, Symbol}\n\nconst ‚Ñí = ACSetCategory(MADVarACSetCat(LV()))\n\nto_graphviz(SchLV; prog=\"dot\")","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We can further extend this schema with an additional attribute of (x,y) coordinates for every vertex. This is nice for visualization but is otherwise unnecessary when doing the actual agent-based modeling. So what we will do is build our model with the LV schema and then run our model with the LV‚Ä≤ schema.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"@present SchLV‚Ä≤ <: SchLV begin\n  Coord::AttrType\n  coord::Attr(V, Coord)\nend\n\n@acset_type LV‚Ä≤_Generic(SchLV‚Ä≤, part_type=BitSetParts) <: HasGraph\nconst LV‚Ä≤ = LV‚Ä≤_Generic{Int, Symbol, Tuple{Int,Int}};\n\nùíü = ACSetCategory(MADVarACSetCat(LV‚Ä≤()))","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We will be representing directions as Symbols and encode the geometry via left and right functions. The attribute will only take values :N, :E, :W, or :S.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"import Catlab.CategoricalAlgebra: left, right\n\nfunction right(s::Symbol)\n  if s == :N\n    return :E\n  elseif s == :S\n    return :W\n  elseif s == :E\n    return :S\n  elseif s == :W\n    return :N\n  end\nend\n\nfunction left(s::Symbol)\n  if s == :N\n    return :W\n  elseif s == :S\n    return :E\n  elseif s == :E\n    return :N\n  elseif s == :W\n    return :S\n  end\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Data-migration-functors","page":"Lotka Volterra","title":"Data migration functors","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"The schema LV has a certain symmetry between wolves and sheep, and this symmetry can be used to take instances of the schema (i.e. world states) and swap the wolves and the sheep. This is helpful for avoiding repeating work: there are certain actions that wolves and sheep share, so, by using this data migration, we can define them in terms of sheep and then migrate along F to obtain the analogous actions for wolves.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"F = Migrate(\n  ‚Ñí,\n  Dict(:Sheep => :Wolf, :Wolf => :Sheep, :Time=>:Time),\n  Dict([:sheep_loc => :wolf_loc, :wolf_loc => :sheep_loc,\n    :sheep_eng => :wolf_eng, :wolf_eng => :sheep_eng, :countdown => :countdown,\n    :sheep_dir => :wolf_dir, :wolf_dir => :sheep_dir,]), SchLV, LV);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We ought to be able to take a state of the world (with no coordinate information) and obtain a state of the world with coordinates (the canonical way to do this is to assign \"variables\" for the values of the coordinates).","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"F2 = Migrate(ùíü, SchLV, LV, SchLV‚Ä≤, LV‚Ä≤; delta=false);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Initializing-and-visualizing-world-states","page":"Lotka Volterra","title":"Initializing and visualizing world states","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"To help us create initial states for simulations, here is a helper function that makes an n √ó n grid with periodic boundary conditions. Edges in each cardinal direction originate at every point.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"function create_grid(n::Int)\n  lv = LV‚Ä≤()\n  coords = Dict()\n  for i in 0:n-1  # Initialize grass 50% green, 50% uniformly between 0-30\n    for j in 0:n-1\n      coords[i=>j] = add_part!(lv, :V; coord=(i, j))\n      add_parts!(lv, :Time, max(0, rand(-30:30)); countdown=coords[i=>j])\n    end\n  end\n  for i in 0:n-1\n    for j in 0:n-1\n      add_part!(lv, :E; src=coords[i=>j], tgt=coords[mod(i + 1, n)=>j], dir=:E)\n      add_part!(lv, :E; src=coords[i=>j], tgt=coords[mod(i - 1, n)=>j], dir=:W)\n      add_part!(lv, :E; src=coords[i=>j], tgt=coords[i=>mod(j + 1, n)], dir=:N)\n      add_part!(lv, :E; src=coords[i=>j], tgt=coords[i=>mod(j - 1, n)], dir=:S)\n    end\n  end\n  lv\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"To initialize a state of the world with sheep and wolves, we also accept parameters which indicate the fraction of spaces that are populated with that animal.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"function initialize(n::Int, sheep::Float64, wolves::Float64)::LV‚Ä≤\n  grid = create_grid(n)\n  args = [(sheep, :Sheep, :sheep_loc, :sheep_eng, :sheep_dir),\n    (wolves, :Wolf, :wolf_loc, :wolf_eng, :wolf_dir)]\n  for (n_, name, loc, eng, d) in args\n    for _ in 1:round(Int, n_ * n^2)\n      dic = Dict([eng => 5, loc => rand(vertices(grid)),\n        d => rand([:N, :E, :S, :W])])\n      add_part!(grid, name; dic...)\n    end\n  end\n  grid\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Some visualization code below will allow us to see states of the world. Edges are left implicit (we know from how the graphs were constructed that there are edges between every pair of adjacent vertices).","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"supscript_d = Dict(['1' => '¬π', '2' => '¬≤', '3' => '¬≥', '4' => '‚Å¥', '5' => '‚Åµ', '6' => '‚Å∂', '7' => '‚Å∑', '8' => '‚Å∏', '9' => '‚Åπ', '0' => '‚Å∞', 'x' => 'À£', 'y' => ' ∏', 'z' => '·∂ª', 'a' => '·µÉ', 'b' => '·µá', 'c' => '·∂ú', 'd' => '·µà'])\nsupscript(x::String) = join([get(supscript_d, c, c) for c in x]); # energy shown in superscript\n\nfunction view_LV(p::ACSetTransformation, pth=tempname(); name=\"G\", title=\"\")\n  if nparts(dom(p), :Wolf) == 1\n    star = :Wolf => p[:Wolf](1)\n  elseif nparts(dom(p), :Sheep) == 1\n    star = :Sheep => p[:Sheep](1)\n  elseif nparts(dom(p), :V) == 1\n    star = :V => p[:V](1)\n  else\n    star = nothing\n  end\n  view_LV(codom(p), pth; name=name, title=title, star=star)\nend\n\nfunction view_LV(p::LV‚Ä≤, pth=tempname(); name=\"G\", title=\"\", star=nothing)\n  pstr = [\"$(i),$(j)!\" for (i, j) in p[:coord]]\n  stmts = Statement[]\n  for s in 1:nv(p)\n    st = (star == (:V => s)) ? \"*\" : \"\"\n    gv = length(incident(p, s, :countdown))\n    col = gv == 0 ? \"lightgreen\" : \"tan\"\n    push!(stmts, Node(\"v$s\", Attributes(\n      :label => gv == 0 ? \"\" : string(gv) * st,\n      :shape => \"circle\",\n      :color => col, :pos => pstr[s])))\n  end\n  d = Dict([:E => (1, 0), :N => (0, 1), :S => (0, -1), :W => (-1, 0),])\n\n  args = [(:true, :Wolf, :wolf_loc, :wolf_eng, :wolf_dir),\n    (false, :Sheep, :sheep_loc, :sheep_eng, :sheep_dir)]\n\n  for (is_wolf, prt, loc, eng, dr) in args\n    for w in parts(p, prt)\n      st = (star == ((is_wolf ? :Wolf : :Sheep) => w)) ? \"*\" : \"\"\n      e = only(incident(p, p[w, loc], :src) ‚à© incident(p, p[w, dr], :dir))\n      s = src(p, e)\n      dx, dy = d[p[e, :dir]]\n      (sx, sy) = p[s, :coord]\n\n      L, R = 0.25, 0.1\n      wx = sx + L * dx + R * rand()\n      wy = sy + L * dy + R * rand()\n      ID = \"$(is_wolf ? :w : :s)$w\"\n      append!(stmts, [Node(ID, Attributes(\n        :label => \"$w\" * supscript(\"$(p[w,eng])\") * st,\n        :shape => \"square\", :width => \"0.3px\", :height => \"0.3px\", :fixedsize => \"true\",\n        :pos => \"$(wx),$(wy)!\", :color => is_wolf ? \"red\" : \"lightblue\"))])\n    end\n  end\n\n  g = Graphviz.Digraph(name, Statement[stmts...]; prog=\"neato\",\n    graph_attrs=Attributes(:label => title, :labelloc => \"t\"),\n    node_attrs=Attributes(:shape => \"plain\", :style => \"filled\"))\n  open(pth, \"w\") do io\n    show(io, \"image/svg+xml\", g)\n  end\n  g\nend\n\ninit = initialize(2, 0.5, 0.5)\nview_LV(init)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Not only can we visualize states of the world, but we can visualize certain states of the world with certain distinguished agents, such as a sheep, wolf, or patch of grass. The way we specify a state of the world (X) with a distinguished sheep (for example) is a morphism S ‚Üí X, where S is an ACSet with a single sheep in it.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Below we manually construct a generic sheep (in LV, which doesn't have coordinates). We then use the data migration to give it generic coordinates to obtain a generic LV‚Ä≤ sheep. We use this as the domain of a hom that assigns the sheep to Sheep #2 of the world state init from above.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"S = @acset LV begin V=1; Sheep=1; Dir=1; Eng=1;\n  sheep_loc=1; sheep_dir=[AV1]; sheep_eng=[AV1];\nend\n\nview_LV(hom(F2(S), init; initial=(Sheep=[2],)))","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"It will be helpful to not have to manually construct \"generic\" world states like above because it's tedious. We want to say \"give me a sheep\" or \"give me a sheep and a wolf that are on the same vertex\" and have it automatically specify the remaining information in the most generic way possible. The @acset_colim macro is perfect for exactly this. In order to use that macro, we need to compute something first with the yoneda_cache function.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"gV, gE, gS, gW, gT, gEng, gD = ob_generators(FinCat(SchLV))\n\nyLV = yoneda_cache(LV; clear=true); # cache=false means reuse cached results\nI = LV() # Empty agent type\nS = ob_map(yLV, gS) # Generic sheep agent\niS = id[‚Ñí](S)\nW = ob_map(yLV, gW) # Generic wolf agent\nE = ob_map(yLV, gE) # Generic edge\nD = ob_map(yLV, gD) # Generic direction\nT = ob_map(yLV, gT) # Generic time\nEng = ob_map(yLV, gEng) # Generic energy variable\nG = ob_map(yLV, gV) # Generic grass agent\nN = Names(Dict(\"W\" => W, \"S\" => S, \"G\" => G, \"\" => I)); # give these ACSets names\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Rules","page":"Lotka Volterra","title":"Rules","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We have finished specifying what makes up a simulation state, and next is to define what sorts of transitions are possible. This is done by declaring rewrite rules. We also will put these rules into little boxes with an incoming wire and two outgoing wires (called a RuleApp), where wires correspond to the successful (resp. unsuccessful) application of the rewrite rule. In the next section we will focus on assembling these miniature wiring diagrams into an overall simulation.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Here we just note that the wires of the simulation must be labeled with an agent. This is because, at all points in time, there is a distinguished agent (i.e. a morphism A ‚Üí X, where A is an ACSet with a generic something in it, e.g. a generic sheep like above). So when we wrap our rules into the RuleApp boxes, we need to also specify what those distinguished agents are and how they relate to the pattern + replacement of the rewrite rule within the box.","category":"page"},{"location":"generated/lotka_volterra/#Rotating","page":"Lotka Volterra","title":"Rotating","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Our first action that is possible for sheep (and wolves) is rotation. Animals will, with some probability, change their orientation. This is a rewrite rule which only modifies an attribute rather than changing any combinatorial data. We delete the sheep and recreate it.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"GS_Eng = @withmodel TypedCatWithCoproducts(‚Ñí) (‚äï) begin\n  hom(G‚äïEng, S; monic=true, cat=‚Ñí)\nend\nrl = Rule(GS_Eng,GS_Eng; expr=(Dir=[((s,),) -> left(s)],), cat=‚Ñí);\nrr = Rule(GS_Eng,GS_Eng; expr=(Dir=[((s,),) -> right(s)],));\n\nsheep_rotate_l = tryrule(RuleApp(:turn_left, rl, iS, iS));\nsheep_rotate_r = tryrule(RuleApp(:turn_right, rr, iS, iS));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We can imagine executing these rules in sequence","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"seq_sched = (sheep_rotate_l ‚ãÖ sheep_rotate_r);\nview_sched(seq_sched; names=N)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"... or in parallel.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"par_sched = (sheep_rotate_l ‚äó sheep_rotate_r);\nview_sched(par_sched; names=N)","category":"page"},{"location":"generated/lotka_volterra/#Test-rotation","page":"Lotka Volterra","title":"Test rotation","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"begin\n  ex = @acset LV begin\n    E=1; Sheep=1; V=2; Time=2\n    src=1; tgt=2; dir=:W; countdown = [1, 2]\n    sheep_loc=1; sheep_eng=100; sheep_dir=:N\n  end;\n\n  expected = copy(ex);\n  expected[:sheep_dir] = :W\n\n  m = homomorphism(S, ex);\n  l = left(rl);\n  p = ComposablePair(l, m);\n  k, g = pushout_complement[‚Ñí](p);\n  K = dom(g)\n  rewrite(rl, ex; cat=‚Ñí)\n\n  @test is_isomorphic(rewrite(rl, ex; cat=‚Ñí), expected; cat=‚Ñí)\n  rewrite!(rl, ex; cat=‚Ñí)\n  @test is_isomorphic(ex, expected)\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Moving-forward","page":"Lotka Volterra","title":"Moving forward","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"s_fwd_l = @acset LV begin\n  V=2; E=1; Sheep=1; Eng=1; Dir=1;\n  src=2; tgt=1; dir=[AV1];\n  sheep_loc=2; sheep_eng=[AV1]; sheep_dir=[AV1]\nend\n\ns_fwd_i = E\n\ns_fwd_r = @acset LV begin\n  V=2; E=1; Sheep=1; Eng=1; Dir=1;\n  src=1; tgt=2; dir=[AV1];\n  sheep_loc=2; sheep_eng=[AV1]; sheep_dir=[AV1]\nend\n\ns_n = sub_vars(s_fwd_l, Dict(:Eng=>[0],), Dict(); cat=‚Ñí)\n\nsheep_fwd_rule = Rule(\n  hom(s_fwd_i, s_fwd_l; monic=true),\n  hom(s_fwd_i, s_fwd_r; monic=true),\n  ac=[NAC(s_n)],\n  expr=(Eng=[vs -> only(vs) - 1],));\n\nsheep_fwd = tryrule(RuleApp(:move_fwd, sheep_fwd_rule,\n  hom(S, s_fwd_l), hom(S, s_fwd_r)));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Moving-forward-test","page":"Lotka Volterra","title":"Moving forward test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"begin\n  ex = @acset LV begin\n    V=3; E=2; Sheep=1; Time=4\n    countdown=[1,2,2,3]\n    src=[1,2]; tgt=[2,3]; dir=[:N,:W]\n    sheep_loc=1; sheep_dir=:N; sheep_eng = 10\n  end\n  expected = copy(ex);\n  expected[:sheep_loc] = 2\n  expected[:sheep_eng] = 9\n  @test is_isomorphic(expected, rewrite(sheep_fwd_rule, ex; cat=‚Ñí); cat=‚Ñí)\n  rewrite!(sheep_fwd_rule, ex; cat=‚Ñí)\n  @test is_isomorphic(ex, expected)\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Sheep-eat-grass","page":"Lotka Volterra","title":"Sheep eat grass","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"function add_time(lv::LV, n::Int)\n  res = deepcopy(lv)\n  add_parts!(res, :Time, n; countdown=1)\n  res\nend\n\ns_eat_nac = @acset LV begin\n  V=1; Sheep=1; Time=1; Dir=1; Eng=1\n  sheep_loc=1; sheep_eng=[AV1]; sheep_dir=[AV1]; countdown=1\nend\n\nGD = ob(coproduct[‚Ñí](G,D))\nGS_Dir = hom(GD, S; monic=true)\nGS_Dir30 = hom(GD, add_time(S, 30); monic=true)\n\nse_rule = Rule(GS_Dir,GS_Dir30; expr=(Eng=[vs -> only(vs) + 4],),\n  ac=[NAC(hom(S, s_eat_nac))]);\n\nS_to_S30 = hom(S, add_time(S, 30))\nsheep_eat = tryrule(RuleApp(:Sheep_eat, se_rule, id[‚Ñí](S), S_to_S30));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Sheep-eating-test","page":"Lotka Volterra","title":"Sheep eating test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"ex = @acset LV begin\n  E=1; V=2; Sheep=1; Time=2\n  src=1; tgt=2; dir=:S; countdown=[1,1]\n  sheep_loc = 2; sheep_eng = 3; sheep_dir=:W\nend\n\nexpected = @acset LV begin\n  E=1; V=2; Sheep=1; Time=32\n  src=1; tgt=2; dir=:S; countdown=[1,1, fill(2, 30)...]\n  sheep_loc = 2; sheep_eng = 7; sheep_dir=:W\nend\n\n@test is_isomorphic(expected, rewrite(se_rule, ex; cat=‚Ñí); cat=‚Ñí)\nrewrite!(se_rule, ex; cat=‚Ñí)\n@test is_isomorphic(ex, expected);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Wolves-eat-sheep","page":"Lotka Volterra","title":"Wolves eat sheep","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"w_eat_l = @acset LV begin\n  V=1; Sheep=1; Wolf=1; Eng=2; Dir=2\n  sheep_loc=1; sheep_eng=[AV1]; sheep_dir=[AV1]\n  wolf_loc=1; wolf_eng=[AV(2)]; wolf_dir=[AV(2)]\nend\n\nGWS_Dir = hom(GD, w_eat_l; initial=(Dir=[AV(2)],))\nGW_Dir = hom(GD, W; monic=true,)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"wolf energy is energy variable #2.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"we_rule = Rule(GWS_Dir, GW_Dir, expr=(Eng=[vs -> vs[2] + 20],));\n\nwolf_eat = tryrule(RuleApp(:Wolf_eat, we_rule, hom(W, w_eat_l), id[‚Ñí](W)));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Wolf-eating-test","page":"Lotka Volterra","title":"Wolf eating test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"ex = @acset LV begin\n  Sheep=1; Wolf=1; V=3; E=2; Time=3;\n  src=[1,2]; tgt=[2,3]; countdown=[1,2,3]; dir=[:N,:N];\n  sheep_loc=2; sheep_eng=[3]; sheep_dir=[:N]\n  wolf_loc=[2];  wolf_eng=[16];  wolf_dir=[:S]\nend\n\nexpected = copy(ex)\nexpected[1, :wolf_eng] = 36\nrem_part!(expected, :Sheep, 1)\n\nres = rewrite(we_rule,ex; cat=‚Ñí)\n@test is_isomorphic(res, expected; cat=‚Ñí)\nrewrite!(we_rule, ex; cat=‚Ñí)\n@test is_isomorphic(ex,expected; cat=‚Ñí);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Sheep-starvation","page":"Lotka Volterra","title":"Sheep starvation","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"s_die_l = codom(sub_vars(S,Dict(:Eng=>[0],), Dict(); cat=‚Ñí))\n\nsheep_die_rule = Rule(hom(G, s_die_l; cat=‚Ñí), id[‚Ñí](G))\nsheep_starve = (RuleApp(:starve, sheep_die_rule,\n  hom(S, s_die_l), create[‚Ñí](G))\n                ‚ãÖ\n                (id([I]) ‚äó Weaken(create[‚Ñí](S))) ‚ãÖ merge_wires(I));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Sheep-starvation-test","page":"Lotka Volterra","title":"Sheep starvation test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"ex = @acset LV begin\n  V=1; Sheep=1; Wolf=1; Time=1\n  countdown=[1];\n  sheep_loc=1; sheep_eng=0; sheep_dir=:W\n  wolf_loc=1; wolf_eng=10; wolf_dir=:S\nend\nexpected = copy(ex)\nrem_part!(expected, :Sheep, 1)\n\n@test is_isomorphic(rewrite(sheep_die_rule,ex; cat=‚Ñí), expected)\nrewrite!(sheep_die_rule,ex; cat=‚Ñí)\n@test is_isomorphic(ex, expected);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Reproduction","page":"Lotka Volterra","title":"Reproduction","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"s_reprod_r = @acset LV begin\n  V=1; Sheep=2; Eng=2; Dir=2;\n  sheep_loc=[1]; sheep_eng=[AV1, AV(2)]; sheep_dir=[AV1, AV(2)]\nend;\n\nsheep_reprod_rule = Rule(\n  hom(G, S; cat=‚Ñí,),\n  hom(G, s_reprod_r; cat=‚Ñí,);\n  cat=‚Ñí,\n  expr=(Dir=fill(((d‚Çõ,),)->d‚Çõ ,2),\n        Eng=fill(((e‚Çõ,),) -> round(Int, e‚Çõ / 2, RoundUp), 2),)\n);\n\nsheep_reprod = RuleApp(:reproduce, sheep_reprod_rule,\n  id[‚Ñí](S), hom(S, s_reprod_r; any=true)) |> tryrule;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Reproduction-test","page":"Lotka Volterra","title":"Reproduction test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"ex = @acset LV begin\n  Sheep=1; Wolf=1; V=2; Time=2\n  countdown=[1,2]\n  sheep_loc=1; sheep_eng=10; sheep_dir=:W\n  wolf_loc=2; wolf_eng=5; wolf_dir=:N\nend\n\nexpected = copy(ex)\nadd_part!(expected,:Sheep)\nexpected[:sheep_eng] = [5, 5]\nexpected[:sheep_loc] = [1, 1]\nexpected[:sheep_dir] = [:W, :W]\n\n@test is_isomorphic(rewrite(sheep_reprod_rule,ex; cat=‚Ñí,),expected)\nrewrite!(sheep_reprod_rule,ex; cat=‚Ñí)\n@test is_isomorphic(ex, expected);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Grass-increments","page":"Lotka Volterra","title":"Grass increments","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"g_inc_rule = Rule(hom(G, T; cat=‚Ñí), id[‚Ñí](G); cat=‚Ñí);\n\ng_inc = RuleApp(:GrassIncrements, g_inc_rule, G; cat=‚Ñí) |> tryrule;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Grass-incrementing-test","page":"Lotka Volterra","title":"Grass incrementing test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"ex = @acset LV begin\n  Sheep = 1; V = 3; E = 2; Time=3\n  src = [1, 2]; tgt = [2, 3]\n  sheep_loc = 2; sheep_eng = [3]; sheep_dir = [:N]\n  countdown = [2,2,2]; dir = fill(:N, 2)\nend\nexpected = deepcopy(ex);\nrem_part!(expected, :Time, 1)\n\nm = homomorphism(T, ex; any=true, cat=‚Ñí)\n\nrwres = rewrite(g_inc_rule, ex; cat=‚Ñí)\n@test is_isomorphic(rwres, expected; cat=‚Ñí)\nrewrite!(g_inc_rule, ex; cat=‚Ñí)\n@test is_isomorphic(ex, expected);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Assembling-rules-into-a-recipe","page":"Lotka Volterra","title":"Assembling rules into a recipe","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Now we can assemble our building block transitions into a large wiring diagram characterizing the flow of the overall ABM simulation. In addition to the blue rewrite rule blocks, we have red (probabilistic) control flow blocks and yellow Query blocks.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"general = mk_sched((;), (init=:S,), N, (\n    turn=const_cond([1.0, 2.0, 1.0], S; name=:turn),\n    maybe=const_cond([0.1, 0.9], S; name=:reprod),\n    lft=sheep_rotate_l,\n    rght=sheep_rotate_r,\n    fwd=sheep_fwd,\n    repro=sheep_reprod,\n    starve=sheep_starve),\n  quote\n    out_l, out_str, out_r = turn(init)\n    moved = fwd([lft(out_l), out_str, rght(out_r)])\n    out_repro, out_no_repro = maybe(moved)\n    return starve([repro(out_repro), out_no_repro])\n  end);\n\nview_sched(general; names=N)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"The above was content common to wolves and sheep. The difference is how they eat.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"sheep = sheep_eat ‚ãÖ general;   # executed once per sheep\n\nview_sched(sheep; names=N)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"We use the swap data migration functor F to translate the sheep routine into a wolf one so that it can be composed with the wolf eating step.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"wolf = wolf_eat ‚ãÖ F(general);  # executed once per wolf\n\nview_sched(wolf; names=N)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Do all sheep, then all wolves, then all daily operations","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"cycle = (agent(sheep; n=:sheep, ret=I)\n         ‚ãÖ\n         agent(wolf; n=:wolves, ret=I)\n         ‚ãÖ\n         agent(g_inc; n=:grass))\n\nview_sched(cycle; names=N)\n\n#=\nWrap the whole thing in a while loop. Also apply the F2 migration to give\neverything coordinates.\n=#\n\noverall = while_schedule(cycle, curr -> nparts(curr, :Wolf) >= 0) |> F2\n\nview_sched(overall; names=F2(N))","category":"page"},{"location":"generated/lotka_volterra/#Running-the-simulation","page":"Lotka Volterra","title":"Running the simulation","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"X = initialize(3, 0.25, 0.25); # 3 √ó 3 grid, 2 sheep + wolves\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Encourage something exciting to happen by placing a wolf on top of a sheep","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"X[1, :wolf_loc] = X[1, :sheep_loc]\nX[1, :wolf_dir] = X[1, :sheep_dir]\n\nview_LV(X)","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Run the simulation for 100 steps","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"res = interpret(overall, X; maxstep=100, cat=ùíü);\nlength(res)","category":"page"},{"location":"generated/lotka_volterra/#Visualizing-the-results","page":"Lotka Volterra","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"Run this line to view the trajectory in the generated traj folder","category":"page"},{"location":"generated/lotka_volterra/","page":"Lotka Volterra","title":"Lotka Volterra","text":"view_traj(overall, res[1:10], view_LV; agent=true, names=F2(N));\nnothing #hide","category":"page"},{"location":"generated/ptg_simple/#Slice-Bread","page":"Slice Bread","title":"Slice Bread","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"using PrettyTables\n\nusing Catlab\nusing AlgebraicRewriting","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Create an ontology by defining a finite presentation of a freely generated category using @present macro","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"About the world: The Bread World Ontology has the types Thing, BreadLoaf, Countertop, and Stool. The Breadloaf, Countertop, and Stool types have morphisms to Thing that represent is-a relationships. The InOn type can be used to encode a set relation (as opposed to a function) that was two morphisms going to Thing. One morphism points out the LHS of the relation and the other morphism point out the RHS of the relation.","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"@present OntBreadWorld(FreeSchema) begin\n  Thing::Ob\n  BreadLoaf::Ob\n  Countertop::Ob\n  Stool::Ob\n\n  BreadLoafIsThing::Hom(BreadLoaf, Thing)  # is-a\n  CountertopIsThing::Hom(Countertop, Thing)  # is-a\n  StoolIsThing::Hom(Stool, Thing)  # is-a\n\n  InOn::Ob\n  inOn_l::Hom(InOn, Thing)\n  inOn_r::Hom(InOn, Thing)\nend","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Visualize the ontology","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"to_graphviz(OntBreadWorld)","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Make the ontology an acset type","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"@acset_type BreadWorld(OntBreadWorld)","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Construct rule by defining a span in the category of ACSets","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Use the @acset macro to define an ACSet functor. The LHS refers to a type (or object) in our ontology and the RHS defines the set assignment using FinFunctions. For this, you need to completely specify the ACSet functor, i.e. every object and morphism in the index category must be specified.","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"About the rule: This rule moves a breadloaf from a countertop to a stool.","category":"page"},{"location":"generated/ptg_simple/#Left-ACSet","page":"Slice Bread","title":"Left ACSet","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"L = @acset BreadWorld begin\n  Thing = 3\n  BreadLoaf = 1\n  Countertop = 1\n  Stool = 1\n\n  BreadLoafIsThing = [1]\n  CountertopIsThing = [2]\n  StoolIsThing = [3]\n\n  InOn = 1\n  inOn_l = [1]\n  inOn_r = [2]  # breadloaf is on the countertop\nend","category":"page"},{"location":"generated/ptg_simple/#Middle/Keep-ACSet","page":"Slice Bread","title":"Middle/Keep ACSet","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"The Thing, Breadloaf, Countertop, and Stool types should be held constant. The InOn type will change because we are changing the underlying set function.","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"K = @acset BreadWorld begin\n  Thing = 3\n  BreadLoaf = 1\n  Countertop = 1\n  Stool = 1\n  BreadLoafIsThing = [1]\n  CountertopIsThing = [2]\n  StoolIsThing = [3]\nend","category":"page"},{"location":"generated/ptg_simple/#Right-ACSet","page":"Slice Bread","title":"Right ACSet","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"R = @acset BreadWorld begin\n  Thing = 3\n  BreadLoaf = 1\n  Countertop = 1\n  Stool = 1\n\n  BreadLoafIsThing = [1]\n  CountertopIsThing = [2]\n  StoolIsThing = [3]\n\n  InOn = 1\n  inOn_l = [1]\n  inOn_r = [3]  # breadloaf is on the stool\nend","category":"page"},{"location":"generated/ptg_simple/#Left-leg-of-span","page":"Slice Bread","title":"Left leg of span","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"l = ACSetTransformation(K, L, Thing=[1, 2, 3], BreadLoaf=[1], Countertop=[1], Stool=[1])","category":"page"},{"location":"generated/ptg_simple/#Right-leg-of-span","page":"Slice Bread","title":"Right leg of span","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"r = ACSetTransformation(K, R, Thing=[1, 2, 3], BreadLoaf=[1], Countertop=[1], Stool=[1])","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Use AlgebraicRewriting.Rule wrapper to add a rule interface","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"moveBreadRule = Rule(l, r)","category":"page"},{"location":"generated/ptg_simple/#WORLD-STATE","page":"Slice Bread","title":"WORLD STATE","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Define a world state using the @acset macro. This is the ACSet way of specifying an ACSet. For this, you need to completely specify the ACSet functor, i.e. every object and morphism in the index category must be specified. The ACSets must be specified in terms of FinFunctions.","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"About the world state: In this world state, there are two countertops, one stool, and one breadloaf. All of these amount to four things. The breadloaf is on the first countertop.","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"state = @acset BreadWorld begin\n  Thing = 4\n  BreadLoaf = 1\n  Countertop = 2\n  Stool = 1\n\n  BreadLoafIsThing = [1]\n  CountertopIsThing = [2, 3] # there are two countertops\n  StoolIsThing = [4]\n\n  InOn = 1\n  inOn_l = [1]  # breadloaf is on the countertop 1\n  inOn_r = [2]\nend","category":"page"},{"location":"generated/ptg_simple/#Apply-Rule","page":"Slice Bread","title":"Apply Rule","text":"","category":"section"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Use the AlgebraicRewriting.get_matches(::Rule{T}, ::ACSet) utility function to find matches between the rule and the state.","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"matches = get_matches(moveBreadRule, state)","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Take the first match","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"match = matches[1]","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"Compute the new world state after rewriting","category":"page"},{"location":"generated/ptg_simple/","page":"Slice Bread","title":"Slice Bread","text":"new_state = rewrite_match(moveBreadRule, match)","category":"page"},{"location":"generated/full_demo/#Full-Demo","page":"Full Demo","title":"Full Demo","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"using AlgebraicRewriting, Catlab#, AlgebraicPetri\nusing Test","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"This is a self-contained walkthrough of the main features of AlgebraicRewriting. This is a regular julia file that can be run interactively.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Importantly:","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"use Julia 1.10\nactivate the environment in AlgebraicRewriting.jl/docs\ncheck that graphviz is installed locally (test via \"which dot\" in terminal)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Table of contents:","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"DPO\nSPO\nSqPO\nPBPO+\nGeneralizing graphs: C-Sets, Slices, etc.\nApplication conditions\nAttribute variables\nGraph processes\nGeneral purpose programming / agent-based modeling","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"a. Rewrite and Control Flow boxes   b. Agents and Query boxes   c. Data migration   d. Monadic output","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"The VS Code REPL makes it easy to have figures automatically pop up in a side window, so this is the preferred way of interacting with this file. However, if that is not available, your options are to 1.) copy-paste the code into a Jupyter notebook 2.) use the following to_svg function, which will write a graphviz output to     a SVG file and can be viewed in a browser. The Julia pipe syntax |> allows     you to easily append \" |> to_svg \" to a line with a visualization.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"to_svg(G, filename=\"tmp.svg\") =\n  open(filename, \"w\") do io\n    show(io, \"image/svg+xml\", G)\n  end\n\nto_graphviz(path_graph(Graph, 3))","category":"page"},{"location":"generated/full_demo/#1.-DPO","page":"Full Demo","title":"1. DPO","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We are working in the category of directed multigraphs","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"ùíû = ACSetCategory(Graph())","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We construct a rule by providing a span, L ‚Üê I ‚Üí R","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"L = path_graph(Graph, 2)  # ‚Ä¢ ‚Üí ‚Ä¢\nI = Graph(1) # ‚Ä¢\nR = @acset Graph begin\n  V = 1\n  E = 1\n  src = 1\n  tgt = 1\nend # ‚Ä¢‚Ü∫\nl = ACSetTransformation(I, L; V=[1]) # graph homomorphism data\nr = ACSetTransformation(I, R; V=[1])\nrule = Rule(l, r)\n\nG = path_graph(Graph, 5)  # ‚Ä¢ ‚Üí ‚Ä¢ ‚Üí ‚Ä¢ ‚Üí ‚Ä¢ ‚Üí ‚Ä¢\nm = only(get_matches(rule, G)) # only one match which satisfies dangling condition","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Provided a specific match (m), we can use the rule to rewrite the graph (G) using rewrite_match(rule, m).","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"res = rewrite_match(rule, m) # ‚Ä¢ ‚Üí ‚Ä¢ ‚Üí ‚Ä¢ ‚Üí ‚Ä¢‚Ü∫\nto_graphviz(res; node_labels=true)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Note that C-Sets are morally regarded up to isomorphism - in particular, limits and colimits may modify the orderings of edges/vertices","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"expected = @acset Graph begin\n  V = 4\n  E = 4\n  src = [1, 2, 3, 4]\n  tgt = [2, 3, 4, 4]\nend\n@test is_isomorphic(expected, res)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We can also specify the rule via a colimit-of-representables (i.e. generators and relations) syntax. As your schema gets bigger, this becomes more and more convenient. Assigning temporary tags, e.g. e, v, e·µ£ to the C-Set elements can also be helpful.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"yG = yoneda_cache(Graph, clear=true); # compute representables\n\nrule2 = Rule(@migration(SchRulel, SchGraph, begin\n    L => @join begin\n      e::E\n    end\n    K => @join begin\n      v::V\n    end\n    R => @join begin\n      e·µ£::E\n      src(e·µ£) == tgt(e·µ£)\n    end\n    l => begin\n      v => src(e)\n    end\n  end), yG);","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We can also rewrite without a match (and let it pick an arbitrary match).","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"@test res == rewrite(rule, G)","category":"page"},{"location":"generated/full_demo/#2.-SPO","page":"Full Demo","title":"2. SPO","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Rules are by default DPO, but if we specify a type parameter we can change the semantics","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"rule_spo = Rule{:SPO}(l, r)  # (same data as before)\n\n@test length(get_matches(rule_spo, G)) == 4 # there are now four matches\nm = get_matches(rule_spo, G)[1]\nres = rewrite_match(rule_spo, m)\nto_graphviz(res)\n@withmodel TypedCatWithCoproducts(ùíû) (‚äï) begin\n  @test is_isomorphic(res, path_graph(Graph, 3) ‚äï R)\nend","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Note: ‚äï and ‚äó are shorthand for (co)products Tip: Julia lets you easily write unicode symbols via \"\\\" followed by a LaTeX name, then hit \"Tab\" to convert the symbol","category":"page"},{"location":"generated/full_demo/#3.-SqPO","page":"Full Demo","title":"3. SqPO","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"If we duplicate a vertex with an incident edge, it will duplicate the edge","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"L = Graph(1)\nI = Graph(2)\nR = path_graph(Graph, 2);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We can use automated homomorphism search to reduce the tedium of specifying data manually. In this case, there is a unique option. In general, homomorphism will throw an error if there is more than one homomorphism.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"l = homomorphism(I, L);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"There are many constraints we can put on the search, such as being monic. Here there are two monic homomorphisms (sending vertices 1 and 2 to (1,2) and (2,1)), so we add the keyword any=true to avoid throwing an error.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"r = homomorphism(I, R; monic=true, any=true)\n\nrule_sqpo = Rule{:SqPO}(l, r) # same data as before)\n\n\nG = star_graph(Graph, 6) # a 5-pointed star\nto_graphviz(G; prog=\"neato\") # changing \"prog\" can sometimes make it look better\n\nm = ACSetTransformation(Graph(1), G; V=[6]) # point at the center\nres = rewrite_match(rule_sqpo, m)\nto_graphviz(res; prog=\"neato\")","category":"page"},{"location":"generated/full_demo/#4.-PBPO","page":"Full Demo","title":"4. PBPO+","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"PBPO+ requires a span just like the other kinds of rewriting.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"L = Graph(1)\nK = R = Graph(2)\nl, r = homomorphism(K,L), id[ùíû](K);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"However, it also requires more data. The graph G that we rewrite will be typed over the L' type graph which controls how various parts of the context (not merely the matched pattern) are rewritten.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"1 = root of the deep copy, 2 = children of #1, 3 = everything else","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"L‚Ä≤ = @acset Graph begin V=3;E=5;src=[1,2,3,3,3];tgt=[2,2,1,2,3] end\nto_graphviz(L‚Ä≤; node_labels=true)\n\ntl = ACSetTransformation(L,L‚Ä≤;V=[1])\nK‚Ä≤ = @acset Graph begin V=5;E=9 ;\n  src=[1,2,3,3,4,3,5,3,3];tgt=[2,2,3,2,5,5,5,1,4]\nend\ntk = ACSetTransformation(K,K‚Ä≤;V=[1,4])\nl‚Ä≤ = homomorphism(K‚Ä≤,L‚Ä≤; initial=(V=[1,2,3,1,2],));\n\n\"\"\"Given a match L ‚Üí G, compute what the typing map G ‚Üí L' should be\"\"\"\nfunction get_adherence(m::ACSetTransformation)\n  root, G, descendents  = only(collect(m[:V])), codom(m), Set()\n  queue = [root]\n  while !isempty(queue)\n    nxt = pop!(queue)\n    union!(descendents, outneighbors(G,nxt))\n    union!(queue, outneighbors(G,nxt))\n  end\n  return (V = map(parts(codom(m),:V)) do v_G\n    if     v_G == root       return 1\n    elseif v_G ‚àà descendents return 2\n    else                     return 3\n    end\n  end,)\nend\n\nrule = PBPORule(l, r, tl, tk, l‚Ä≤; adherence=get_adherence);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Think of the following graph as a file system","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"G = @acset Graph begin V=8; E=8;\n  src=[1,1,2,2,3,4,4,5]; tgt=[2,3,4,5,6,5,7,8]\nend\n\nto_graphviz(G; node_labels=true)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Executing this rule (forcing the pattern to match at vertex 2) performs a \"deepcopy\" operation, copying vertex 2 and everything underneath it.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"expected = @acset Graph begin V=13;E=14;\n  src=[7,7,7,1,1,3,3,4,2,2,10,10,11,8]; tgt=[1,2,8,3,4,5,4,6,10,11,12,11,13,9]\nend\n\n@test is_isomorphic(expected, rewrite(rule, G; initial=(V=[2],)))\n\nto_graphviz(expected; node_labels=true)","category":"page"},{"location":"generated/full_demo/#5.-Generalizing-Graphs","page":"Full Demo","title":"5. Generalizing Graphs","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Any data structure which implements the required functions we need can, in principle, be used for rewriting. Importantly this includes pushout_complement, pushout, and homomorphism search. These are all implemented generically for any C-Set schema (allowing us to rewrite Petri nets, Semisimplicial sets, etc.)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Here we'll do rewriting in graphs sliced over ‚Ä¢‚áÜ‚Ä¢, which is isomorphic to the category of (whole-grain) Petri nets, with States and Transitions.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"function graph_slice(s::Slice)\n  h = s.slice\n  V, E = collect.([h[:V], h[:E]])\n  g = dom(h)\n  (S, T), (I, O) = [[findall(==(i), X) for i in 1:2] for X in [V, E]]\n  nS, nT, nI, nO = length.([S, T, I, O])\n  findS, findT = [x -> findfirst(==(x), X) for X in [S, T]]\n  to_graphviz(@acset AlgebraicPetri.PetriNet begin\n    S = nS; T = nT; I = nI; O = nO\n    is = findS.(g[I, :src])\n    it = findT.(g[I, :tgt])\n    ot = findT.(g[O, :src])\n    os = findS.(g[O, :tgt])\n  end)\nend;","category":"page"},{"location":"generated/full_demo/#This-is-the-graph-we-are-slicing-over.","page":"Full Demo","title":"This is the graph we are slicing over.","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"two = @acset Graph begin\n  V = 2; E = 2; src = [1, 2]; tgt = [2, 1]\nend\n\nto_graphviz(two)","category":"page"},{"location":"generated/full_demo/#Define-a-rule-which-deletes-a-[T]-S-edge.-Start-with-the-pattern,-L.","page":"Full Demo","title":"Define a rule which deletes a [T] -> S edge. Start with the pattern, L.","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"L_ = path_graph(Graph, 2)\nL = Slice(ACSetTransformation(L_, two, V=[2, 1], E=[2])) # [T] ‚ü∂ (S)\ngraph_slice(L)","category":"page"},{"location":"generated/full_demo/#Then-define-I-and-R","page":"Full Demo","title":"Then define I and R","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"I_ = Graph(1)\nI = Slice(ACSetTransformation(I_, two, V=[2])) # [T]\nR_ = Graph(2)\nR = Slice(ACSetTransformation(R_, two, V=[2, 1])) # [T]  (S)","category":"page"},{"location":"generated/full_demo/#Using-homomorphism-search-in-the-slice-category","page":"Full Demo","title":"Using homomorphism search in the slice category","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"rule = Rule(homomorphism(I, L), homomorphism(I, R))\n\nG_ = path_graph(Graph, 3)\nG = Slice(ACSetTransformation(G_, two, V=[1, 2, 1], E=[1, 2])) # (S) ‚ü∂ [T] ‚ü∂ (S)\ngraph_slice(G)\n\nres = rewrite(rule, G) # (S) ‚ü∂ [T]  (S)\ngraph_slice(res)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"While the vast majority of functionality is focused on ACSets at the present moment, but there is nothing in principle which limits this.","category":"page"},{"location":"generated/full_demo/#6.-Application-conditions","page":"Full Demo","title":"6. Application conditions","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We can construct commutative diagrams with certain edges left unspecified or marked with ‚àÄ or ‚àÉ. If only one edge is left free, we can treat the diagram as a boolean function which tests whether the morphism makes the specified paths commute (or not commute). This generalizes positive/negative application conditions and lifting conditions, but because those are most common there are constructors AppCond and LiftCond to make these directly.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"         ‚àÄ\n  [‚Üª‚Ä¢]   ‚Üí  ?\n    ‚Üì    ‚Üó ‚àÉ ‚Üì\n  [‚Üª‚Ä¢‚ü∂‚Ä¢]  ‚Üí [‚Üª‚Ä¢‚ü∂‚Ä¢‚üµ‚Ä¢‚Ü∫]","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"` Every vertex with a loop also has a map to the vertex marked by the bottom map.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"t = terminal[ùíû]() |> apex\nlooparr = @acset Graph begin V=2; E=2; src=2; tgt=[1,2] end","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"  (e1, e2)::E\n  src(e1) == tgt(e1)\n  src(e1) == src(e2)\nend","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"v = homomorphism(t, looparr)\nloop_csp = @acset Graph begin\n  V = 3; E = 4; src = [1, 3, 1, 3]; tgt = [1, 3, 2, 2]\nend\nb = homomorphism(looparr, loop_csp; initial=(V=[2,1],))\nconstr = LiftCond(v, b)\n\n@test !apply_constraint(constr, homomorphism(t, loop_csp; initial=(V=[1],)); cat=ùíû)\n@test apply_constraint(constr, b; cat=ùíû)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"We can combining constraints with logical combinators.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"match vertex iff it has 2 or 3 self loops","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"one, two, three, four, five = [@acset(Graph, begin\n  V = 1; E = n; src = 1; tgt = 1\nend) for n in 1:5]\n\nc2 = PAC(homomorphism(Graph(1), two); monic=true)         # PAC\nc3 = NAC(homomorphism(Graph(1), four); monic=true) # NAC\nconstr = c2 ‚äó c3 # logical conjunction: 2 ‚â§ |E| < 4\n\nrule = Rule(id[ùíû](Graph(1)), id[ùíû](Graph(1)); ac=[constr])\n\nG = @withmodel TypedCatWithCoproducts(ùíû) (‚äï) begin\n two ‚äï three ‚äï two ‚äï four ‚äï five ‚äï one\nend\n@test length(get_matches(rule, G)) == 3","category":"page"},{"location":"generated/full_demo/#7.-Attribute-variables","page":"Full Demo","title":"7. Attribute variables","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Normally ACSet morphisms must match attribute values exactly, i.e. a weighted graph edge of 8.3 can only be mapped to another edge weighted at 8.3. This becomes very restricted, especially when we want to do some simple computations with attribute values (e.g. when merging two edges, add their values together)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"An extension of ACSets makes this possible - each attribute type comes equipped with a finite set of \"variables\" which can be mapped to any concrete value (or another variable).","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"yWG = yoneda_cache(WeightedGraph{Int}; clear=true);\nL = @acset_colim yWG begin\n  (e1, e2)::E\n  src(e1) == src(e2)\n  tgt(e1) == tgt(e2)\nend\nI = WeightedGraph{Int}(2)\nR = @acset WeightedGraph{Int} begin\n  V = 2; E = 1; Weight = 1\n  src = [1]; tgt = [2]; weight = [AttrVar(1)]\nend\n\nl = homomorphism(I, L; initial=(V=1:2,))\nr = homomorphism(I, R; initial=(V=1:2,))\nrule = Rule(l, r; monic=[:E], expr=Dict(:Weight => [((w‚ÇÅ,w‚ÇÇ),) -> w‚ÇÅ + w‚ÇÇ]))\n\nG = @acset WeightedGraph{Int} begin\n  V = 1; E = 3; src = 1; tgt = 1; weight = [10, 20, 100]\nend\n\nm = homomorphism(L, G; initial=(E=1:2,))\n@test rewrite_match(rule, m) == @acset WeightedGraph{Int} begin\n  V = 1; E = 2; src = [1]; tgt = [1]; weight = [30, 100]\nend","category":"page"},{"location":"generated/full_demo/#8.-Graph-processes","page":"Full Demo","title":"8. Graph processes","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"A sequence of rewrite applications can be given a poset structure where Œ± ‚â§ Œ≤ means that the rule application Œ± needed to occur before Œ≤.  This is computed via analyzing the colimit of all the partial maps induced by the rewrites.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"using AlgebraicRewriting.Processes: RWStep, find_deps\n\nG0, G1, G2, G3 = Graph.([0, 1, 2, 3]);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Delete a node","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Rule1 = Span(create[ùíû](G1), id[ùíû](G0));\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Merge two nodes","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Rule2 = Span(id[ùíû](G2), homomorphism(G2, G1));\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Add a node","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Rule3 = Span(id[ùíû](G0), create[ùíû](G1))\n\nR1, R2, R3 = [Rule(l, r) for (l, r) in [Rule1, Rule2, Rule3]];\nnothing #hide","category":"page"},{"location":"generated/full_demo/#9.-Trajectory","page":"Full Demo","title":"9. Trajectory","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Step 1: add node 3 to G2","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"M1 = create[ùíû](G2)\nCM1 = ACSetTransformation(G1, G3; V=[3])\nPmap1 = Span(id[ùíû](G2), ACSetTransformation(G2, G3; V=[1, 2]))\nRS1 = RWStep(Rule3, Pmap1, M1, CM1);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Step 2: merge node 2 and 3 to yield a G2","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"M2 = ACSetTransformation(G2, G3; V=[2, 3])\nCM2 = ACSetTransformation(G1, G2; V=[2])\nPmap2 = Span(id[ùíû](G3), ACSetTransformation(G3, G2; V=[1, 2, 2]))\nRS2 = RWStep(Rule2, Pmap2, M2, CM2);\nnothing #hide","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Step 3: delete vertex 1","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"M3 = ACSetTransformation(G1, G2; V=[1])\nCM3 = create[ùíû](G1)\nPmap3 = Span(ACSetTransformation(G1, G2; V=[2]), id[ùíû](G1))\nRS3 = RWStep(Rule1, Pmap3, M3, CM3);\n\n\nsteps = [RS1, RS2, RS3];\n\ng = find_deps(steps; cat=ùíû)\nto_graphviz(g; node_labels=true)","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Confirm this what we expect","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"expected = @acset Graph begin V = 3; E = 1; src = 1; tgt = 2 end\n@test expected == g","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Interface that just uses rules and match morphisms: The matches needed to be updated to reflect the particular isomorph that DPO rewriting produces when applying the rule.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"œÉ‚ÇÇ = ACSetTransformation(G2, G2; V=[2, 1])\nœÉ‚ÇÉ = ACSetTransformation(G3, G3; V=[3, 1, 2])\n\ng‚Ä≤ = @withmodel ùíû (‚ãÖ) begin\n  find_deps([R3 => M1, R2 => M2 ‚ãÖ œÉ‚ÇÉ, R1 => M3 ‚ãÖ œÉ‚ÇÇ]; cat=ùíû)\nend\n@test g‚Ä≤ == g","category":"page"},{"location":"#AlgebraicRewriting.jl","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"Algebraic rewriting is a context-aware find-and-replace operation that is useful for maintaining structure in various scenarios. This package provides tools for such operations in Julia, ensuring that rewrite rules adhere to structures defined using ACSets (see ACSets.jl and Catlab.jl). This documentation provides a basic guide to using the AlgebraicRewriting package in Julia. ","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"This page will provide you with a gentle overview of how to design and apply rewrite rules for a simple ACSet. More sophisticated examples can be found in the side-bar.","category":"page"},{"location":"#Setup-Environment","page":"AlgebraicRewriting.jl","title":"Setup Environment","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"To begin, set up your environment by importing necessary packages.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"using Catlab\nusing AlgebraicRewriting","category":"page"},{"location":"#Design-a-rewrite-rule","page":"AlgebraicRewriting.jl","title":"Design a rewrite rule","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"The general process for designing a rewrite rule is as follows:","category":"page"},{"location":"#1.-Define-your-schema","page":"AlgebraicRewriting.jl","title":"1. Define your schema","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"A schema defined by a finite presentation of a generalized algebraic theory model using generators, Ob, Hom, AttrType, and Attr.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"@present SchSportsTeam(FreeSchema) begin\n  Player::Ob\n  Team::Ob\n  Member::Ob\n  IsMember::Hom(Member, Player)\n  MemberOf::Hom(Member, Team)\n\n  Name::AttrType\n  PlayerHasName::Attr(Player, Name)\n  TeamHasName::Attr(Team, Name)\nend\nto_graphviz(SchSportsTeam)","category":"page"},{"location":"#2.-Create-the-schema-type","page":"AlgebraicRewriting.jl","title":"2. Create the schema type","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"Data for rules are stored in a data structure called an ACSet. ","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"@acset_type SportsTeam(SchSportsTeam)","category":"page"},{"location":"#3.-Define-rule-parts","page":"AlgebraicRewriting.jl","title":"3. Define rule parts","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"A rewrite rule consists of a span of ACSets (L <-l- K -r-> R), namely three ACSets (L, K, R) and two natural transformations (l, r):","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"Left ACSet, L, is the pre-condition for the rule to be applied.\nKeep ACSet, K, is the data for the part of the state that remain consistent when the rule is applied.\nRight ACSet, R, is the effect of the rule.\nLeft transformation, l, embeds K in L.\nRight transformation, r, embed K in R.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"To define a rule, all five parts need to be defined. ","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"It is possible to insert data according to the schema using a static approach or the colimit-of-representables approach.","category":"page"},{"location":"#Static-Instantiation-(@acset)","page":"AlgebraicRewriting.jl","title":"Static Instantiation (@acset)","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"If using the static approach, you must fully specify the ACSet functors and natural transformation. Here is a rule that defines the ACSet statically. ","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"In this example, the rule swaps players, one from each team. AttrVar.(1:2), or [AttrVar(1), AttrVar(2)], are used as variable placeholders for the names of the players. This allows the rule to be applied independent of player names, as long as two players are specified from opposing teams. Contrastingly, [\"Home\", \"Away\"], are specified explicitly and, therefore, this rule can only be applied to teams whose names are \"Home\" and \"Away\"","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"# Both L and R are the same: two players are members of a Home and Away team\nL = R = @acset SportsTeam{String} begin\n  Player = 2; Team = 2; Member = 2; Name = 2\n  IsMember = [1, 2]; MemberOf = [1, 2]\n  PlayerHasName = AttrVar.(1:2)\n  TeamHasName = [\"Home\", \"Away\"]\nend\n# K is missing the Member relation. L <- K removes the two players' memberships\n# and K -> R adds in a new membership relation.\nK = @acset SportsTeam{String} begin\n  Player = 2; Team = 2; Name = 2\n  PlayerHasName = AttrVar.(1:2)\n  TeamHasName = [\"Home\", \"Away\"]\nend\n\n# Manually specify K->L and K->R\n# Important that the player removed from Home (as determined by l: K->L) is \n# assigned (via r: K->R) to the player which is added to away, and vice-versa.\nl = ACSetTransformation(K, L, Player=[1,2], Team=[1, 2], Name=AttrVar.([1,2]))\nr = ACSetTransformation(K, R, Player=[2,1], Team=[1, 2], Name=AttrVar.([2,1])) # swap\n\n# Alternatively we could use automated search, as there are the only two maps \n# K->L (same as K->R because L=R) that do not merge the two players together \nl, r = homomorphisms(K, L; monic=true) # ('monic' = \"no merging allowed\")","category":"page"},{"location":"#Colimit-of-representables-instantiation-(@acset_colim)","page":"AlgebraicRewriting.jl","title":"Colimit-of-representables instantiation (@acset_colim)","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"If using the colimit-of-representables approach, you only need to specify relevant objects and morphism parts. Shown here is the translation of the above rule using @acset_colim.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"ySportsTeam = yoneda(SportsTeam{String})\nL = R = @acset_colim ySportsTeam begin\n  (p1, p2)::Player\n  (t1, t2)::Team\n  (m1, m2)::Member\n  IsMember(m1) == p1\n  IsMember(m2) == p2\n  MemberOf(m1) == t1\n  MemberOf(m2) == t2\n  TeamHasName(t1) == \"Home\"\n  TeamHasName(t2) == \"Away\"\nend # we did not specify PlayerHasName, so it's left generic\nK = @acset_colim ySportsTeam begin\n  (t1, t2)::Team\n  (p1, p2)::Player\n  TeamHasName(t1) == \"Home\"\n  TeamHasName(t2) == \"Away\"\nend\nl, r = homomorphisms(K, L; monic=true) # same as above because K,L,R are the same","category":"page"},{"location":"#4.-Construct-the-rule","page":"AlgebraicRewriting.jl","title":"4. Construct the rule","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"Use the AlgebraicRewriting.Rule constructor to create the rule. This assumes that a double-pushout (DPO) rewrite rule is being constructed. You may also construct an single-pushout (SPO), sesqui-pushout (SqPO), or pullback-pushout (PBPO) rule.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"rule = Rule{:DPO}(l, r)","category":"page"},{"location":"#Apply-the-rule","page":"AlgebraicRewriting.jl","title":"Apply the rule","text":"","category":"section"},{"location":"#5.-Define-the-initial-state.","page":"AlgebraicRewriting.jl","title":"5. Define the initial state.","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"Similarly, you can choose to define the acset using the static approach or the colimit-of-representable approach.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"If using the static approach, you must fully specify the ACSet for the initial state.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"state = @acset SportsTeam{String} begin\n  Player = 4; Member = 4; Team = 2\n  IsMember = [1, 2, 3, 4]; MemberOf = [1, 1, 2, 2]\n  TeamHasName = [\"Home\", \"Away\"]\n  PlayerHasName = [\"Jordan\", \"Alex\", \"Casey\", \"Taylor\"]\nend","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"If using the colimit-of-representable approach, you only need to specify relevant objects and morphism parts.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"state = @acset_colim ySportsTeam begin\n  (p1, p2, p3, p4)::Player\n  (m1, m2, m3, m4)::Member\n  (t1, t2)::Team\n  IsMember(m1) == p1; IsMember(m2) == p2; IsMember(m3) == p3; IsMember(m4) == p4\n  MemberOf(m1) == t1; MemberOf(m2) == t1; MemberOf(m3) == t2; MemberOf(m4) == t2\n  PlayerHasName(p1) == \"Jordan\"\n  PlayerHasName(p2) == \"Alex\"\n  PlayerHasName(p3) == \"Casey\"\n  PlayerHasName(p4) == \"Taylor\"\n  TeamHasName(t1) == \"Home\"\n  TeamHasName(t2) == \"Away\"\nend","category":"page"},{"location":"#6.-Identify-the-match-from-the-rule-to-the-state","page":"AlgebraicRewriting.jl","title":"6. Identify the match from the rule to the state","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"This can be done manually or automatically. ","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"To manually identify the match, fully-specify an ACSet transformation. For this example, we would like to rule to swap p2::Player and p3::Player","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"pattern_match = ACSetTransformation(L, state, Player=[2, 3], Member=[2, 3], \n                                    Team=[1, 2], Name=[\"Alex\", \"Casey\"])","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"To automatically identify the match, use the backtracking search algorithm provided by AlgebraicRewriting. This may return multiple matches, so you can provide logic for deciding which match to select. ","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"pattern_match = homomorphism(L, state; initial=(Name=[\"Alex\", \"Casey\"],))\n\nmatches = get_matches(rule, state)# get all four possible matches, then pick one","category":"page"},{"location":"#7.-Apply-the-rewrite-rule","page":"AlgebraicRewriting.jl","title":"7. Apply the rewrite rule","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"This executes the rewrite process using using the defined rule and match.","category":"page"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"result = rewrite_match(rule, pattern_match)","category":"page"},{"location":"#Authors","page":"AlgebraicRewriting.jl","title":"Authors","text":"","category":"section"},{"location":"","page":"AlgebraicRewriting.jl","title":"AlgebraicRewriting.jl","text":"This documentation is maintained by Angeline Aguinaldo and Kristopher Brown.","category":"page"}]
}
