<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conway&#39;s Game of Life · AlgebraicRewriting.jl</title><meta name="title" content="Conway&#39;s Game of Life · AlgebraicRewriting.jl"/><meta property="og:title" content="Conway&#39;s Game of Life · AlgebraicRewriting.jl"/><meta property="twitter:title" content="Conway&#39;s Game of Life · AlgebraicRewriting.jl"/><meta name="description" content="Documentation for AlgebraicRewriting.jl."/><meta property="og:description" content="Documentation for AlgebraicRewriting.jl."/><meta property="twitter:description" content="Documentation for AlgebraicRewriting.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AlgebraicRewriting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AlgebraicRewriting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">AlgebraicRewriting.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../full_demo/">Full Demo</a></li><li class="is-active"><a class="tocitem" href>Conway&#39;s Game of Life</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Schema"><span>Schema</span></a></li><li class="toplevel"><a class="tocitem" href="#Helper"><span>Helper</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Constructions-for-Life-ACSets-/-maps-between-them"><span>Constructions for Life ACSets / maps between them</span></a></li><li><a class="tocitem" href="#Initialization-of-LifeCoords"><span>Initialization of LifeCoords</span></a></li><li class="toplevel"><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li class="toplevel"><a class="tocitem" href="#Schedule"><span>Schedule</span></a></li></ul></li><li><a class="tocitem" href="../lotka_volterra/">Lotka Volterra</a></li><li><a class="tocitem" href="../ptg_simple/">Slice Bread</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Conway&#39;s Game of Life</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conway&#39;s Game of Life</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/main/docs/literate/game_of_life.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conway&#39;s-Game-of-Life"><a class="docs-heading-anchor" href="#Conway&#39;s-Game-of-Life">Conway&#39;s Game of Life</a><a id="Conway&#39;s-Game-of-Life-1"></a><a class="docs-heading-anchor-permalink" href="#Conway&#39;s-Game-of-Life" title="Permalink"></a></h1><pre><code class="language-julia hljs">using AlgebraicRewriting
using Catlab, Catlab.Graphs, Catlab.CategoricalAlgebra, Catlab.Theories
import Catlab.Graphics: to_graphviz
using Catlab.Graphics.Graphviz: Attributes, Statement, Node, Edge, Digraph
using PrettyTables
using Luxor</code></pre><p>The game of life has two rules: one which turns living things dead, and one that brings dead things to life. We model the terrain as a symmetric graph: cells are vertices. Neighboring cells have edges between them.</p><p>Implementation wise, if we are going to update cells one at a time, we must keep track of two bits of information (the cell&#39;s living status for the <em>current</em> timestep and whether it will be alive in the <em>next</em> timestep). Thus we need helper rule to overwrite the &quot;current&quot; life status with the &quot;next&quot; life status at the end of each timestep.</p><h1 id="Schema"><a class="docs-heading-anchor" href="#Schema">Schema</a><a id="Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Schema" title="Permalink"></a></h1><p><code>curr</code> and <code>next</code> pick out subsets of V which are marked as currently alive or to be alive in the next timestep.</p><pre><code class="language-julia hljs">@present SchLife &lt;: SchSymmetricGraph begin
  (Curr, Next)::Ob
  curr::Hom(Curr, V)
  next::Hom(Next, V)
end
@present SchLifeCoords &lt;: SchLife begin
  Coords::AttrType
  coords::Attr(V, Coords)
end
@acset_type Life(SchLife, part_type=BitSetParts) &lt;: AbstractSymmetricGraph
@acset_type AbsLifeCoords(SchLifeCoords, part_type=BitSetParts) &lt;: AbstractSymmetricGraph
const LifeCoords = AbsLifeCoords{Tuple{Int,Int}}
F = Migrate(
  Dict(x =&gt; x for x in Symbol.(generators(SchLife, :Ob))),
  Dict(x =&gt; x for x in Symbol.(generators(SchLife, :Hom))), LifeCoords; delta=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Migrate(Dict(:Curr =&gt; :Curr, :V =&gt; :V, :Next =&gt; :Next, :E =&gt; :E), Dict(:src =&gt; :src, :next =&gt; :next, :curr =&gt; :curr, :tgt =&gt; :tgt, :inv =&gt; :inv), Main.AbsLifeCoords{Tuple{Int64, Int64}}, Main.AbsLifeCoords{Tuple{Int64, Int64}}, false)</code></pre><h1 id="Helper"><a class="docs-heading-anchor" href="#Helper">Helper</a><a id="Helper-1"></a><a class="docs-heading-anchor-permalink" href="#Helper" title="Permalink"></a></h1><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><pre><code class="language-julia hljs">function view_life(f::ACSetTransformation, pth=tempname())
  v = collect(f[:V])
  view_life(codom(f), pth; star=isempty(v) ? nothing : only(v))
end
function view_life(X::Life, pth=tempname(); star=nothing)
  pg = PropertyGraph{Any}(; prog=&quot;neato&quot;, graph=Dict(),
    node=Dict(:shape =&gt; &quot;circle&quot;, :style =&gt; &quot;filled&quot;, :margin =&gt; &quot;0&quot;),
    edge=Dict(:dir =&gt; &quot;none&quot;, :minlen =&gt; &quot;1&quot;))
  add_vertices!(pg, nparts(X, :V))
  for v in vertices(X)
    set_vprop!(pg, v, :fillcolor, isempty(incident(X, v, :curr)) ? &quot;red&quot; : &quot;green&quot;)
    if !isempty(incident(X, v, :next))
      set_vprop!(pg, v, :penwidth, &quot;4.0&quot;)
    end
    set_vprop!(pg, v, :label, star == v ? &quot;*&quot; : &quot;&quot;)
  end
  for e in filter(e -&gt; X[e, :inv] &gt; e, edges(X))
    add_edge!(pg, X[e, :src], X[e, :tgt])
  end
  G = to_graphviz(pg)
  open(pth, &quot;w&quot;) do io
    show(io, &quot;image/svg+xml&quot;, G)
  end
  G
end
function view_life(X::LifeCoords, pth=tempname(); star=nothing)
  n = Int(sqrt(nparts(X, :V)))
  coords = Dict([(i, j) =&gt; findfirst(==((i, j)), X[:coords])
                 for (i, j) in Iterators.product(1:n, 1:n)])
  mat = pretty_table(String, reduce(hcat, map(1:n) do i
      map(1:n) do j
        c, x = [!isempty(incident(X, coords[(i, j)], x)) for x in [:curr, :next]]
        res = c ? (x ? &quot;O&quot; : &quot;o&quot;) : (x ? &quot;X&quot; : &quot;x&quot;)
        return res * ((star == coords[(i, j)]) ? &quot;.&quot; : &quot;&quot;)
      end
    end); show_header=false, tf=tf_markdown)
  open(pth, &quot;w&quot;) do io
    write(io, mat)
  end
  return mat
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">view_life (generic function with 6 methods)</code></pre><h2 id="Constructions-for-Life-ACSets-/-maps-between-them"><a class="docs-heading-anchor" href="#Constructions-for-Life-ACSets-/-maps-between-them">Constructions for Life ACSets / maps between them</a><a id="Constructions-for-Life-ACSets-/-maps-between-them-1"></a><a class="docs-heading-anchor-permalink" href="#Constructions-for-Life-ACSets-/-maps-between-them" title="Permalink"></a></h2><pre><code class="language-julia hljs">Next() = @acset Life begin
  V = 1
  Next = 1
  next = 1
end
Curr() = @acset Life begin
  V = 1
  Curr = 1
  curr = 1
end
to_next() = homomorphism(Life(1), Next())
to_curr() = homomorphism(Life(1), Curr())

&quot;&quot;&quot;Construct a cell connected to n living neighbors&quot;&quot;&quot;
function living_neighbors(n::Int; alive=false)
  X = Life(1)
  if alive
    add_part!(X, :Curr, curr=1)
  end
  for _ in 1:n
    v = add_part!(X, :V)
    add_part!(X, :Curr, curr=v)
    add_edge!(X, v, 1)
  end
  return X
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.living_neighbors</code></pre><h2 id="Initialization-of-LifeCoords"><a class="docs-heading-anchor" href="#Initialization-of-LifeCoords">Initialization of LifeCoords</a><a id="Initialization-of-LifeCoords-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-of-LifeCoords" title="Permalink"></a></h2><pre><code class="language-julia hljs">function make_grid(curr::AbstractMatrix, next=nothing)
  n, m = size(curr)
  n == m || error(&quot;Must be square&quot;)
  X, coords = LifeCoords(), Dict()
  for i in 1:n
    for j in 1:n
      coords[i=&gt;j] = add_vertex!(X; coords=(i, j))
      if Bool(curr[i, j])
        add_part!(X, :Curr, curr=coords[i=&gt;j])
      end
      if !isnothing(next) &amp;&amp; Bool(next[i, j])
        add_part!(X, :Curr, curr=coords[i=&gt;j])
      end
    end
  end
  for i in 1:n
    for j in 1:n
      if i &lt; n
        add_edge!(X, coords[i=&gt;j], coords[i+1=&gt;j])
      end
      if j &lt; n
        add_edge!(X, coords[i=&gt;j], coords[i=&gt;j+1])
      end
      if i &lt; n &amp;&amp; j &lt; n
        add_edge!(X, coords[i=&gt;j], coords[i+1=&gt;j+1])
      end
      if i &lt; n &amp;&amp; j &gt; 1
        add_edge!(X, coords[i=&gt;j], coords[i+1=&gt;j-1])
      end
    end
  end
  return X
end
make_grid(n::Int, random=false) = make_grid((random ? rand : zeros)(Bool, (n, n)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">make_grid (generic function with 4 methods)</code></pre><h1 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h1><p>A dead cell becomes alive iff exactly 3 living neighbors</p><pre><code class="language-julia hljs">BirthP1 = living_neighbors(3) # must have 3 neighbors
BirthN1 = living_neighbors(4) # forbid the cell to have 4 neighbors
BirthN2 = Curr() # forbid the cell to be alive (i.e. it&#39;s currently dead)
BP1, BN1, BN2 = homomorphism.(Ref(Life(1)), [BirthP1, BirthN1, BirthN2])
bac = [AppCond(BP1; monic=true), AppCond.([BN1, BN2], false; monic=true)...]
Birth = Rule(id(Life(1)), to_next(); ac=bac)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rule{:DPO}(ACSetTransformation((V = id(FinSet(1)), E = id(FinSet(0)), Curr = id(FinSet(0)), Next = id(FinSet(0))), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:0}), ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 0), Next = FinFunction(Int64[], 0, 1)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:1}), Constraint[Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1, 2, 3, 4]
  E = [1, 2, 3, 4, 5, 6]
  Curr = [1, 2, 3]
  Next = Int64[]
  src : E → V = [2, 1, 3, 1, 4, 1]
  tgt : E → V = [1, 2, 1, 3, 1, 4]
  inv : E → E = [2, 1, 4, 3, 6, 5]
  curr : Curr → V = [2, 3, 4]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = Int64[]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = Int64[]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 4), E = FinFunction(Int64[], 0, 6), Curr = FinFunction(Int64[], 0, 3), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:4, E:6, Curr:3, Next:0}), nothing, 1], ∃2 (monic, ): (1⋅2 = 3)), Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1, 2, 3, 4, 5]
  E = [1, 2, 3, 4, 5, 6, 7, 8]
  Curr = [1, 2, 3, 4]
  Next = Int64[]
  src : E → V = [2, 1, 3, 1, 4, 1, 5, 1]
  tgt : E → V = [1, 2, 1, 3, 1, 4, 1, 5]
  inv : E → E = [2, 1, 4, 3, 6, 5, 8, 7]
  curr : Curr → V = [2, 3, 4, 5]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = Int64[]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = Int64[]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 5), E = FinFunction(Int64[], 0, 8), Curr = FinFunction(Int64[], 0, 4), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:5, E:8, Curr:4, Next:0}), nothing, 1], ¬∃2 (monic, ): (1⋅2 = 3)), Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1]
  E = Int64[]
  Curr = [1]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = [1]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = Int64[]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = Int64[]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 1), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:1, Next:0}), nothing, 1], ¬∃2 (monic, ): (1⋅2 = 3))], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())</code></pre><p>A living cell stays alive iff 2 or 3 living neighbors</p><pre><code class="language-julia hljs">PersistR = @acset Life begin
  V = 1
  Curr = 1
  Next = 1
  curr = 1
  next = 1
end
PersistP1 = living_neighbors(2; alive=true)
PersistN1 = living_neighbors(4; alive=true)
DR, DP1, DN1 = homomorphism.(Ref(Curr()), [PersistR, PersistP1, PersistN1])
pac = [AppCond(DP1; monic=true), AppCond(DN1, false; monic=true)]
Persist = Rule(id(Curr()), DR; ac=pac)

ClearCurr = Rule(to_curr(), id(Life(1))) # remove &quot;Curr&quot; status
ClearNext = Rule(to_next(), id(Life(1))) # remove &quot;Next&quot; status
CopyNext = Rule(to_next(), to_curr())   # Copy &quot;Next&quot; to &quot;Curr&quot;

rules = [:Birth =&gt; Birth, :Persist =&gt; Persist, :ClearCurr =&gt; ClearCurr,
  :ClearNext =&gt; ClearNext, :CopyNext =&gt; CopyNext]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Pair{Symbol, Rule{:DPO}}}:
     :Birth =&gt; Rule{:DPO}(ACSetTransformation((V = id(FinSet(1)), E = id(FinSet(0)), Curr = id(FinSet(0)), Next = id(FinSet(0))), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:0}), ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 0), Next = FinFunction(Int64[], 0, 1)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:1}), Constraint[Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1, 2, 3, 4]
  E = [1, 2, 3, 4, 5, 6]
  Curr = [1, 2, 3]
  Next = Int64[]
  src : E → V = [2, 1, 3, 1, 4, 1]
  tgt : E → V = [1, 2, 1, 3, 1, 4]
  inv : E → E = [2, 1, 4, 3, 6, 5]
  curr : Curr → V = [2, 3, 4]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = Int64[]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = Int64[]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 4), E = FinFunction(Int64[], 0, 6), Curr = FinFunction(Int64[], 0, 3), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:4, E:6, Curr:3, Next:0}), nothing, 1], ∃2 (monic, ): (1⋅2 = 3)), Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1, 2, 3, 4, 5]
  E = [1, 2, 3, 4, 5, 6, 7, 8]
  Curr = [1, 2, 3, 4]
  Next = Int64[]
  src : E → V = [2, 1, 3, 1, 4, 1, 5, 1]
  tgt : E → V = [1, 2, 1, 3, 1, 4, 1, 5]
  inv : E → E = [2, 1, 4, 3, 6, 5, 8, 7]
  curr : Curr → V = [2, 3, 4, 5]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = Int64[]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = Int64[]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 5), E = FinFunction(Int64[], 0, 8), Curr = FinFunction(Int64[], 0, 4), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:5, E:8, Curr:4, Next:0}), nothing, 1], ¬∃2 (monic, ): (1⋅2 = 3)), Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1]
  E = Int64[]
  Curr = [1]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = [1]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = Int64[]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = Int64[]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 1), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:1, Next:0}), nothing, 1], ¬∃2 (monic, ): (1⋅2 = 3))], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())
   :Persist =&gt; Rule{:DPO}(ACSetTransformation((V = id(FinSet(1)), E = id(FinSet(0)), Curr = id(FinSet(1)), Next = id(FinSet(0))), Main.Life {V:1, E:0, Curr:1, Next:0}, Main.Life {V:1, E:0, Curr:1, Next:0}), ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction([1], 1, 1), Next = FinFunction(Int64[], 0, 1)), Main.Life {V:1, E:0, Curr:1, Next:0}, Main.Life {V:1, E:0, Curr:1, Next:1}), Constraint[Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1, 2, 3]
  E = [1, 2, 3, 4]
  Curr = [1, 2, 3]
  Next = Int64[]
  src : E → V = [2, 1, 3, 1]
  tgt : E → V = [1, 2, 1, 3]
  inv : E → E = [2, 1, 4, 3]
  curr : Curr → V = [1, 2, 3]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = [1]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = [1]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 3), E = FinFunction(Int64[], 0, 4), Curr = FinFunction([1], 1, 3), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:1, Next:0}, Main.Life {V:3, E:4, Curr:3, Next:0}), nothing, 1], ∃2 (monic, ): (1⋅2 = 3)), Constraint(CGraph:
  V = 1:3
  E = 1:3
  VLabel = 1:0
  ELabel = 1:0
  src : E → V = [2, 1, 2]
  tgt : E → V = [1, 3, 3]
  vlabel : V → VLabel = Union{Nothing, Main.Life}[Main.Life:
  V = [1, 2, 3, 4, 5]
  E = [1, 2, 3, 4, 5, 6, 7, 8]
  Curr = [1, 2, 3, 4, 5]
  Next = Int64[]
  src : E → V = [2, 1, 3, 1, 4, 1, 5, 1]
  tgt : E → V = [1, 2, 1, 3, 1, 4, 1, 5]
  inv : E → E = [2, 1, 4, 3, 6, 5, 8, 7]
  curr : Curr → V = [1, 2, 3, 4, 5]
  next : Next → V = Int64[], Main.Life:
  V = [1]
  E = Int64[]
  Curr = [1]
  Next = Int64[]
  src : E → V = Int64[]
  tgt : E → V = Int64[]
  inv : E → E = Int64[]
  curr : Curr → V = [1]
  next : Next → V = Int64[], nothing]
  elabel : E → ELabel = Any[ACSetTransformation((V = FinFunction([1], 1, 5), E = FinFunction(Int64[], 0, 8), Curr = FinFunction([1], 1, 5), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:1, Next:0}, Main.Life {V:5, E:8, Curr:5, Next:0}), nothing, 1], ¬∃2 (monic, ): (1⋅2 = 3))], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())
 :ClearCurr =&gt; Rule{:DPO}(ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 1), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:1, Next:0}), ACSetTransformation((V = id(FinSet(1)), E = id(FinSet(0)), Curr = id(FinSet(0)), Next = id(FinSet(0))), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:0}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())
 :ClearNext =&gt; Rule{:DPO}(ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 0), Next = FinFunction(Int64[], 0, 1)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:1}), ACSetTransformation((V = id(FinSet(1)), E = id(FinSet(0)), Curr = id(FinSet(0)), Next = id(FinSet(0))), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:0}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())
  :CopyNext =&gt; Rule{:DPO}(ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 0), Next = FinFunction(Int64[], 0, 1)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:0, Next:1}), ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 0), Curr = FinFunction(Int64[], 0, 1), Next = FinFunction(Int64[], 0, 0)), Main.Life {V:1, E:0, Curr:0, Next:0}, Main.Life {V:1, E:0, Curr:1, Next:0}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())</code></pre><h1 id="Schedule"><a class="docs-heading-anchor" href="#Schedule">Schedule</a><a id="Schedule-1"></a><a class="docs-heading-anchor-permalink" href="#Schedule" title="Permalink"></a></h1><p>All rules have interface of a single distinguished cell. Never distinguish control flow of successful vs unsuccessful application</p><pre><code class="language-julia hljs">rBirth, rPersist, rClearCurr, rClearNext, rCopyNext =
  [tryrule(RuleApp(n, r, Life(1))) for (n, r) in rules]

update_next = agent(rBirth ⋅ rPersist, Life(1); n=:Cell)
next_step = agent(compose(rClearCurr, rCopyNext, rClearNext), Life(1); n=:Cell)
life(n::Int) = for_schedule(update_next ⋅ next_step, n) |&gt; F
const L = life(1)

G = make_grid([1 0 1 0 1; 0 1 0 1 0; 0 1 0 1 0; 1 0 1 0 1; 1 0 1 0 1])

res = interpret(L, G; maxstep=100);
view_traj(L, res[1:10], view_life; agent=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Exceeded maximum number of steps
└ @ AlgebraicRewriting.Schedules.Eval ~/work/AlgebraicRewriting.jl/AlgebraicRewriting.jl/src/schedules/Eval.jl:72</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../full_demo/">« Full Demo</a><a class="docs-footer-nextpage" href="../lotka_volterra/">Lotka Volterra »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 28 February 2024 01:29">Wednesday 28 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
