<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full Demo · AlgebraicRewriting.jl</title><meta name="title" content="Full Demo · AlgebraicRewriting.jl"/><meta property="og:title" content="Full Demo · AlgebraicRewriting.jl"/><meta property="twitter:title" content="Full Demo · AlgebraicRewriting.jl"/><meta name="description" content="Documentation for AlgebraicRewriting.jl."/><meta property="og:description" content="Documentation for AlgebraicRewriting.jl."/><meta property="twitter:description" content="Documentation for AlgebraicRewriting.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AlgebraicRewriting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AlgebraicRewriting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">AlgebraicRewriting.jl</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Full Demo</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#1.-DPO"><span>1. DPO</span></a></li><li class="toplevel"><a class="tocitem" href="#2.-SPO"><span>2. SPO</span></a></li><li class="toplevel"><a class="tocitem" href="#3.-SqPO"><span>3. SqPO</span></a></li><li class="toplevel"><a class="tocitem" href="#4.-PBPO"><span>4. PBPO+</span></a></li><li class="toplevel"><a class="tocitem" href="#5.-Generalizing-Graphs"><span>5. Generalizing Graphs</span></a></li><li class="toplevel"><a class="tocitem" href="#6.-Application-conditions"><span>6. Application conditions</span></a></li><li class="toplevel"><a class="tocitem" href="#7.-Attribute-variables"><span>7. Attribute variables</span></a></li><li class="toplevel"><a class="tocitem" href="#8.-Graph-processes"><span>8. Graph processes</span></a></li><li class="toplevel"><a class="tocitem" href="#9.-Trajectory"><span>9. Trajectory</span></a></li></ul></li><li><a class="tocitem" href="../game_of_life/">Conway&#39;s Game of Life</a></li><li><a class="tocitem" href="../lotka_volterra/">Lotka Volterra</a></li><li><a class="tocitem" href="../ptg_simple/">Slice Bread</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Full Demo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Full Demo</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/main/docs/literate/full_demo.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-Demo"><a class="docs-heading-anchor" href="#Full-Demo">Full Demo</a><a id="Full-Demo-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Demo" title="Permalink"></a></h1><pre><code class="language-julia hljs">using AlgebraicRewriting, Catlab, AlgebraicPetri, DataMigrations
using Test</code></pre><p>This is a self-contained walkthrough of the main features of AlgebraicRewriting. This is a regular julia file that can be run interactively.</p><p>Importantly:</p><ul><li>use Julia 1.10</li><li>activate the environment in AlgebraicRewriting.jl/docs</li><li>check that graphviz is installed locally (test via &quot;which dot&quot; in terminal)</li></ul><p>Table of contents:</p><ol><li>DPO</li><li>SPO</li><li>SqPO</li><li>PBPO+</li><li>Generalizing graphs: C-Sets, Slices, etc.</li><li>Application conditions</li><li>Attribute variables</li><li>Graph processes</li><li>General purpose programming / agent-based modeling</li></ol><p>a. Rewrite and Control Flow boxes   b. Agents and Query boxes   c. Data migration   d. Monadic output</p><p>The VS Code REPL makes it easy to have figures automatically pop up in a side window, so this is the preferred way of interacting with this file. However, if that is not available, your options are to 1.) copy-paste the code into a Jupyter notebook 2.) use the following <code>to_svg</code> function, which will write a graphviz output to     a SVG file and can be viewed in a browser. The Julia pipe syntax |&gt; allows     you to easily append &quot; |&gt; to_svg &quot; to a line with a visualization.</p><pre><code class="language-julia hljs">to_svg(G, filename=&quot;tmp.svg&quot;) =
  open(filename, &quot;w&quot;) do io
    show(io, &quot;image/svg+xml&quot;, G)
  end

to_graphviz(path_graph(Graph, 3))</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="91pt" height="12pt"
 viewBox="0.00 0.00 90.80 11.60" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 7.6)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-7.6 86.8,-7.6 86.8,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="black" stroke="black" cx="1.8" cy="-1.8" rx="1.8" ry="1.8"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="black" stroke="black" cx="41.4" cy="-1.8" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n2 -->
<g id="edge1" class="edge">
<title>n1&%2345;&gt;n2</title>
<path fill="none" stroke="black" d="M3.73,-1.8C7.85,-1.8 24.64,-1.8 34.01,-1.8"/>
<polygon fill="black" stroke="black" points="34.06,-3.55 39.06,-1.8 34.06,-0.05 34.06,-3.55"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="black" stroke="black" cx="81" cy="-1.8" rx="1.8" ry="1.8"/>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge2" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M43.33,-1.8C47.45,-1.8 64.24,-1.8 73.61,-1.8"/>
<polygon fill="black" stroke="black" points="73.66,-3.55 78.66,-1.8 73.66,-0.05 73.66,-3.55"/>
</g>
</g>
</svg>
'/><h1 id="1.-DPO"><a class="docs-heading-anchor" href="#1.-DPO">1. DPO</a><a id="1.-DPO-1"></a><a class="docs-heading-anchor-permalink" href="#1.-DPO" title="Permalink"></a></h1><p>We construct a rule by providing a span, L ← I → R</p><pre><code class="language-julia hljs">L = path_graph(Graph, 2)  # • → •
I = Graph(1) # •
R = @acset Graph begin
  V = 1
  E = 1
  src = 1
  tgt = 1
end # •↺
l = ACSetTransformation(I, L; V=[1]) # graph homomorphism data
r = ACSetTransformation(I, R; V=[1])
rule = Rule(l, r)

G = path_graph(Graph, 5)  # • → • → • → • → •
m = only(get_matches(rule, G)) # only one match which satisfies dangling condition</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ACSetTransformation((V = FinFunction([4, 5], 2, 5), E = FinFunction([4], 1, 4)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:1}, Catlab.Graphs.BasicGraphs.Graph {V:5, E:4})</code></pre><p>Provided a specific match (<code>m</code>), we can use the <code>rule</code> to rewrite the graph (<code>G</code>) using <code>rewrite_match(rule, m)</code>.</p><pre><code class="language-julia hljs">res = rewrite_match(rule, m) # • → • → • → •↺
to_graphviz(res; node_labels=true)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="201pt" height="47pt"
 viewBox="0.00 0.00 201.18 47.21" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 43.21)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-43.21 197.18,-43.21 197.18,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="182.25" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="182.25" y="-6.91" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n1&%2345;&gt;n1 -->
<g id="edge1" class="edge">
<title>n1&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M174.71,-18.51C169.02,-28.03 171.53,-39.21 182.25,-39.21 191.12,-39.21 194.37,-31.55 191.99,-23.5"/>
<polygon fill="black" stroke="black" points="193.41,-22.38 189.78,-18.51 190.21,-23.79 193.41,-22.38"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="10.61" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="10.61" y="-6.91" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="67.82" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="67.82" y="-6.91" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge2" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M21.22,-10.61C29.67,-10.61 42.1,-10.61 51.84,-10.61"/>
<polygon fill="black" stroke="black" points="51.94,-12.36 56.94,-10.61 51.94,-8.86 51.94,-12.36"/>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="none" stroke="black" cx="125.03" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="125.03" y="-6.91" font-family="Times,serif" font-size="14.00">4</text>
</g>
<!-- n3&%2345;&gt;n4 -->
<g id="edge3" class="edge">
<title>n3&%2345;&gt;n4</title>
<path fill="none" stroke="black" d="M78.44,-10.61C86.88,-10.61 99.31,-10.61 109.06,-10.61"/>
<polygon fill="black" stroke="black" points="109.15,-12.36 114.15,-10.61 109.15,-8.86 109.15,-12.36"/>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="edge4" class="edge">
<title>n4&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M135.65,-10.61C144.1,-10.61 156.52,-10.61 166.27,-10.61"/>
<polygon fill="black" stroke="black" points="166.37,-12.36 171.37,-10.61 166.37,-8.86 166.37,-12.36"/>
</g>
</g>
</svg>
'/><p>Note that C-Sets are morally regarded up to isomorphism - in particular, limits and colimits may modify the orderings of edges/vertices</p><pre><code class="language-julia hljs">expected = @acset Graph begin
  V = 4
  E = 4
  src = [1, 2, 3, 4]
  tgt = [2, 3, 4, 4]
end
@test is_isomorphic(expected, res)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>We can also specify the rule via a colimit-of-representables (i.e. generators and relations) syntax. As your schema gets bigger, this becomes more and more convenient. Assigning temporary tags, e.g. <code>e</code>, <code>v</code>, <code>eᵣ</code> to the C-Set elements can also be helpful.</p><pre><code class="language-julia hljs">yG = yoneda_cache(Graph, clear=true); # compute representables

rule2 = Rule(@migration(SchRulel, SchGraph, begin
    L =&gt; @join begin
      e::E
    end
    K =&gt; @join begin
      v::V
    end
    R =&gt; @join begin
      eᵣ::E
      src(eᵣ) == tgt(eᵣ)
    end
    l =&gt; begin
      v =&gt; src(e)
    end
  end), yG)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rule{:DPO}(ACSetTransformation((V = FinFunction([2], 1, 2), E = FinFunction(Int64[], 0, 1)), Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:1}), ACSetTransformation((V = FinFunction([1], 1, 1), E = FinFunction(Int64[], 0, 1)), Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:1}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())</code></pre><p>We can also rewrite without a match (and let it pick an arbitrary match).</p><pre><code class="language-julia hljs">@test res == rewrite(rule, G)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h1 id="2.-SPO"><a class="docs-heading-anchor" href="#2.-SPO">2. SPO</a><a id="2.-SPO-1"></a><a class="docs-heading-anchor-permalink" href="#2.-SPO" title="Permalink"></a></h1><p>Rules are by default DPO, but if we specify a type parameter we can change the semantics</p><pre><code class="language-julia hljs">rule_spo = Rule{:SPO}(l, r)  # (same data as before)

@test length(get_matches(rule_spo, G)) == 4 # there are now four matches
res = rewrite(rule_spo, G)
to_graphviz(res)
@test is_isomorphic(res, path_graph(Graph, 3) ⊕ R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p><strong>Note</strong>: ⊕ and ⊗ are shorthand for (co)products <em>Tip: Julia lets you easily write unicode symbols via &quot;\&quot; followed by a LaTeX name, then hit &quot;Tab&quot; to convert the symbol</em></p><h1 id="3.-SqPO"><a class="docs-heading-anchor" href="#3.-SqPO">3. SqPO</a><a id="3.-SqPO-1"></a><a class="docs-heading-anchor-permalink" href="#3.-SqPO" title="Permalink"></a></h1><p>If we duplicate a vertex with an incident edge, it will duplicate the edge</p><pre><code class="language-julia hljs">L = Graph(1)
I = Graph(2)
R = path_graph(Graph, 2)</code></pre><div class="c-set">
<span class="c-set-summary">Catlab.Graphs.BasicGraphs.Graph {V:2, E:1}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
    </tr>
  </tbody>
</table>
</div>
<p>We can use automated homomorphism search to reduce the tedium of specifying data manually. In this case, there is a unique option.</p><pre><code class="language-julia hljs">l = homomorphism(I, L)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ACSetTransformation((V = FinFunction([1, 1], 2, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0})</code></pre><p>There are many constraints we can put on the search, such as being monic.</p><pre><code class="language-julia hljs">r = homomorphism(I, R; monic=true)

rule_sqpo = Rule{:SqPO}(l, r) # same data as before)


G = star_graph(Graph, 6) # a 5-pointed star
to_graphviz(G; prog=&quot;neato&quot;) # changing &quot;prog&quot; can sometimes make it look better

m = ACSetTransformation(Graph(1), G; V=[6]) # point at the center
res = rewrite_match(rule_sqpo, m)
to_graphviz(res; prog=&quot;neato&quot;)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="83pt" height="85pt"
 viewBox="0.00 0.00 83.11 85.34" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 81.34)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-81.34 79.11,-81.34 79.11,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="black" stroke="black" cx="26.63" cy="-39.27" rx="1.8" ry="1.8"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="black" stroke="black" cx="42.22" cy="-36.33" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n2 -->
<g id="edge1" class="edge">
<title>n1&%2345;&gt;n2</title>
<path fill="none" stroke="black" d="M28.54,-38.91C30.22,-38.59 32.78,-38.11 35.23,-37.64"/>
<polygon fill="black" stroke="black" points="35.7,-39.34 40.29,-36.69 35.05,-35.9 35.7,-39.34"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="black" stroke="black" cx="48.74" cy="-1.8" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n3 -->
<g id="edge2" class="edge">
<title>n1&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M27.58,-37.66C30.59,-32.55 40.03,-16.55 45.23,-7.75"/>
<polygon fill="black" stroke="black" points="46.78,-8.56 47.82,-3.36 43.77,-6.78 46.78,-8.56"/>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="black" stroke="black" cx="1.8" cy="-59.65" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n4 -->
<g id="edge4" class="edge">
<title>n1&%2345;&gt;n4</title>
<path fill="none" stroke="black" d="M25,-40.6C21.49,-43.48 13.09,-50.38 7.42,-55.03"/>
<polygon fill="black" stroke="black" points="6.22,-53.75 3.47,-58.28 8.44,-56.46 6.22,-53.75"/>
</g>
<!-- n5 -->
<g id="node5" class="node">
<title>n5</title>
<ellipse fill="black" stroke="black" cx="73.31" cy="-43.59" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n5 -->
<g id="edge6" class="edge">
<title>n1&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M28.63,-39.45C35.05,-40.05 55.31,-41.92 66.2,-42.93"/>
<polygon fill="black" stroke="black" points="66.22,-44.69 71.36,-43.41 66.55,-41.21 66.22,-44.69"/>
</g>
<!-- n6 -->
<g id="node6" class="node">
<title>n6</title>
<ellipse fill="black" stroke="black" cx="42.72" cy="-75.54" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n6 -->
<g id="edge8" class="edge">
<title>n1&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M27.49,-41.22C29.79,-46.38 36.09,-60.6 39.83,-69.02"/>
<polygon fill="black" stroke="black" points="38.3,-69.89 41.93,-73.75 41.5,-68.47 38.3,-69.89"/>
</g>
<!-- n7 -->
<g id="node7" class="node">
<title>n7</title>
<ellipse fill="black" stroke="black" cx="6.35" cy="-11.06" rx="1.8" ry="1.8"/>
</g>
<!-- n1&%2345;&gt;n7 -->
<g id="edge10" class="edge">
<title>n1&%2345;&gt;n7</title>
<path fill="none" stroke="black" d="M25.54,-37.75C22.76,-33.88 15.29,-23.49 10.53,-16.88"/>
<polygon fill="black" stroke="black" points="11.88,-15.76 7.54,-12.72 9.04,-17.8 11.88,-15.76"/>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge3" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M42.57,-34.47C43.46,-29.74 45.86,-17.02 47.39,-8.92"/>
<polygon fill="black" stroke="black" points="49.15,-9.08 48.35,-3.84 45.71,-8.43 49.15,-9.08"/>
</g>
<!-- n2&%2345;&gt;n4 -->
<g id="edge5" class="edge">
<title>n2&%2345;&gt;n4</title>
<path fill="none" stroke="black" d="M40.48,-37.33C34.92,-40.54 17.39,-50.65 7.95,-56.1"/>
<polygon fill="black" stroke="black" points="6.94,-54.66 3.49,-58.67 8.69,-57.69 6.94,-54.66"/>
</g>
<!-- n2&%2345;&gt;n5 -->
<g id="edge7" class="edge">
<title>n2&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M44.26,-36.8C48.64,-37.83 59.15,-40.28 66.25,-41.94"/>
<polygon fill="black" stroke="black" points="66.27,-43.74 71.54,-43.18 67.07,-40.34 66.27,-43.74"/>
</g>
<!-- n2&%2345;&gt;n6 -->
<g id="edge9" class="edge">
<title>n2&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M42.25,-38.44C42.32,-44.02 42.51,-59.38 42.63,-68.5"/>
<polygon fill="black" stroke="black" points="40.88,-68.63 42.69,-73.61 44.38,-68.59 40.88,-68.63"/>
</g>
<!-- n2&%2345;&gt;n7 -->
<g id="edge11" class="edge">
<title>n2&%2345;&gt;n7</title>
<path fill="none" stroke="black" d="M40.68,-35.24C35.79,-31.8 20.47,-21.01 12.05,-15.07"/>
<polygon fill="black" stroke="black" points="12.94,-13.56 7.84,-12.11 10.92,-16.42 12.94,-13.56"/>
</g>
</g>
</svg>
'/><h1 id="4.-PBPO"><a class="docs-heading-anchor" href="#4.-PBPO">4. PBPO+</a><a id="4.-PBPO-1"></a><a class="docs-heading-anchor-permalink" href="#4.-PBPO" title="Permalink"></a></h1><p>PBPO+ requires not merely a span but also additional data for L and K which can be thought of as type graphs. The graph G that we rewrite will be typed over the L&#39; type graph to determine how it is rewritten.</p><pre><code class="language-julia hljs">L = Graph(1)
K = Graph(2)
l = homomorphism(K, L)
r = id(K)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ACSetTransformation((V = id(FinSet(2)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0})</code></pre><p>We allow edges into and out of the matched vertex as well as edges between the vertices incident to the matched vertex</p><pre><code class="language-julia hljs">L′ = @acset Graph begin
  V = 3
  E = 6
  src = [1, 1, 1, 2, 3, 3]
  tgt = [1, 2, 3, 3, 3, 1]
end
tl = ACSetTransformation(L, L′; V=[2]) # 2 is the matched vertex
to_graphviz(L′; node_labels=true)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="144pt" height="77pt"
 viewBox="0.00 0.00 144.03 77.21" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 73.21)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-73.21 140.03,-73.21 140.03,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="10.67" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="10.67" y="-6.91" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n1&%2345;&gt;n1 -->
<g id="edge1" class="edge">
<title>n1&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M3.13,-18.51C-2.56,-28.03 -0.05,-39.21 10.67,-39.21 19.54,-39.21 22.79,-31.55 20.41,-23.5"/>
<polygon fill="black" stroke="black" points="21.83,-22.38 18.2,-18.51 18.63,-23.79 21.83,-22.38"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="67.88" cy="-58.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="67.88" y="-54.91" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- n1&%2345;&gt;n2 -->
<g id="edge2" class="edge">
<title>n1&%2345;&gt;n2</title>
<path fill="none" stroke="black" d="M19.34,-17.28C28.66,-25.38 44.45,-39.1 55.25,-48.5"/>
<polygon fill="black" stroke="black" points="54.35,-50.03 59.27,-51.99 56.64,-47.39 54.35,-50.03"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="125.09" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="125.09" y="-6.91" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- n1&%2345;&gt;n3 -->
<g id="edge3" class="edge">
<title>n1&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M20.87,-6.69C40.48,-3.18 86.52,-2.93 109.92,-5.94"/>
<polygon fill="black" stroke="black" points="109.87,-7.7 115.08,-6.73 110.4,-4.24 109.87,-7.7"/>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge4" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M76.56,-51.93C85.87,-43.84 101.66,-30.11 112.47,-20.71"/>
<polygon fill="black" stroke="black" points="113.86,-21.83 116.48,-17.22 111.56,-19.18 113.86,-21.83"/>
</g>
<!-- n3&%2345;&gt;n1 -->
<g id="edge6" class="edge">
<title>n3&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M115.08,-14.48C95.63,-18.02 49.6,-18.29 26.07,-15.3"/>
<polygon fill="black" stroke="black" points="26.07,-13.53 20.87,-14.52 25.55,-16.99 26.07,-13.53"/>
</g>
<!-- n3&%2345;&gt;n3 -->
<g id="edge5" class="edge">
<title>n3&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M117.56,-18.51C111.86,-28.03 114.37,-39.21 125.09,-39.21 133.97,-39.21 137.22,-31.55 134.84,-23.5"/>
<polygon fill="black" stroke="black" points="136.25,-22.38 132.63,-18.51 133.05,-23.79 136.25,-22.38"/>
</g>
</g>
</svg>
'/><p>The outneighbors of the matched vertex are duplicated (an edge connects the old ones to the new ones) and the matched vertex is duplicated. The new copy of the matched vertex points at the new ones. It does not have any inneighbors.</p><pre><code class="language-julia hljs">K′ = @acset Graph begin
  V = 5
  E = 9
  src = [1, 1, 1, 2, 3, 3, 3, 4, 5]
  tgt = [1, 2, 3, 3, 3, 1, 5, 5, 5]
end
tk = ACSetTransformation(K, K′; V=[2, 4])
to_graphviz(K′; node_labels=true)

l′ = homomorphism(K′, L′; initial=(V=[1, 2, 3, 2, 3],))

prule = PBPORule(l, r, tl, tk, l′)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PBPORule(ACSetTransformation((V = FinFunction([1, 1], 2, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}), ACSetTransformation((V = id(FinSet(2)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}), ACSetTransformation((V = FinFunction([2], 1, 3), E = FinFunction(Int64[], 0, 6)), Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:3, E:6}), ACSetTransformation((V = FinFunction([2, 4], 2, 5), E = FinFunction(Int64[], 0, 9)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:5, E:9}), ACSetTransformation((V = FinFunction([1, 2, 3, 2, 3], 5, 3), E = FinFunction([1, 2, 3, 4, 5, 6, 5, 4, 5], 9, 6)), Catlab.Graphs.BasicGraphs.Graph {V:5, E:9}, Catlab.Graphs.BasicGraphs.Graph {V:3, E:6}), false, Constraint[], Constraint[], Dict{Any, Any}(), Dict{Any, Any}(), nothing)</code></pre><p>Apply to an example vertex (#3) with two inneighbors and one outneighbor.</p><pre><code class="language-julia hljs">G = @acset Graph begin
  V = 4
  E = 5
  src = [1, 1, 2, 3, 4]
  tgt = [2, 3, 3, 4, 4]
end
to_graphviz(G; node_labels=true)

m = get_match(prule, G; initial=(V=[3],) =&gt; Dict())

res = rewrite_match(prule, m)</code></pre><div class="c-set">
<span class="c-set-summary">Catlab.Graphs.BasicGraphs.Graph {V:6, E:8}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">5</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">5</td>
      <td style = "text-align: right;">5</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td>
      <td style = "text-align: right;">5</td>
      <td style = "text-align: right;">6</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">6</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td>
      <td style = "text-align: right;">6</td>
      <td style = "text-align: right;">6</td>
    </tr>
  </tbody>
</table>
</div>
<p>V1 is copied to V2. Outneighbor V5 (w/ loop) is copied to V6, creating an edge</p><pre><code class="language-julia hljs">to_graphviz(res; node_labels=true)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="258pt" height="105pt"
 viewBox="0.00 0.00 258.39 105.21" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 101.21)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-101.21 254.39,-101.21 254.39,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="125.03" cy="-29.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="125.03" y="-25.91" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n5 -->
<g id="node5" class="node">
<title>n5</title>
<ellipse fill="none" stroke="black" cx="182.25" cy="-29.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="182.25" y="-25.91" font-family="Times,serif" font-size="14.00">5</text>
</g>
<!-- n1&%2345;&gt;n5 -->
<g id="edge4" class="edge">
<title>n1&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M135.65,-29.61C144.1,-29.61 156.52,-29.61 166.27,-29.61"/>
<polygon fill="black" stroke="black" points="166.37,-31.36 171.37,-29.61 166.37,-27.86 166.37,-31.36"/>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="182.25" cy="-86.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="182.25" y="-82.91" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- n6 -->
<g id="node6" class="node">
<title>n6</title>
<ellipse fill="none" stroke="black" cx="239.46" cy="-57.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="239.46" y="-53.91" font-family="Times,serif" font-size="14.00">6</text>
</g>
<!-- n2&%2345;&gt;n6 -->
<g id="edge7" class="edge">
<title>n2&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M191.87,-82.08C200.82,-77.38 214.91,-69.98 225.25,-64.54"/>
<polygon fill="black" stroke="black" points="226.1,-66.08 229.71,-62.2 224.47,-62.98 226.1,-66.08"/>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="10.61" cy="-29.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="10.61" y="-25.91" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- n3&%2345;&gt;n1 -->
<g id="edge2" class="edge">
<title>n3&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M21.39,-29.88C30.63,-30.13 44.86,-30.47 57.21,-30.61 66.64,-30.71 69,-30.71 78.43,-30.61 88.66,-30.49 100.18,-30.24 109.08,-30.02"/>
<polygon fill="black" stroke="black" points="109.29,-31.76 114.25,-29.88 109.2,-28.26 109.29,-31.76"/>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="none" stroke="black" cx="67.82" cy="-10.61" rx="10.71" ry="10.71"/>
<text text-anchor="middle" x="67.82" y="-6.91" font-family="Times,serif" font-size="14.00">4</text>
</g>
<!-- n3&%2345;&gt;n4 -->
<g id="edge1" class="edge">
<title>n3&%2345;&gt;n4</title>
<path fill="none" stroke="black" d="M20.97,-26.38C29.67,-23.39 42.74,-18.89 52.71,-15.46"/>
<polygon fill="black" stroke="black" points="53.43,-17.06 57.59,-13.78 52.29,-13.75 53.43,-17.06"/>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="edge3" class="edge">
<title>n4&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M78.19,-13.83C86.88,-16.82 99.96,-21.32 109.92,-24.75"/>
<polygon fill="black" stroke="black" points="109.51,-26.46 114.81,-26.43 110.65,-23.15 109.51,-26.46"/>
</g>
<!-- n5&%2345;&gt;n5 -->
<g id="edge5" class="edge">
<title>n5&%2345;&gt;n5</title>
<path fill="none" stroke="black" d="M174.71,-37.51C169.02,-47.03 171.53,-58.21 182.25,-58.21 191.12,-58.21 194.37,-50.55 191.99,-42.5"/>
<polygon fill="black" stroke="black" points="193.41,-41.38 189.78,-37.51 190.21,-42.79 193.41,-41.38"/>
</g>
<!-- n5&%2345;&gt;n6 -->
<g id="edge6" class="edge">
<title>n5&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M192.12,-34.11C201.02,-38.62 214.86,-45.64 225.09,-50.83"/>
<polygon fill="black" stroke="black" points="224.54,-52.51 229.79,-53.21 226.12,-49.39 224.54,-52.51"/>
</g>
<!-- n6&%2345;&gt;n6 -->
<g id="edge8" class="edge">
<title>n6&%2345;&gt;n6</title>
<path fill="none" stroke="black" d="M231.92,-65.51C226.23,-75.03 228.74,-86.21 239.46,-86.21 248.34,-86.21 251.58,-78.55 249.2,-70.5"/>
<polygon fill="black" stroke="black" points="250.62,-69.38 247,-65.51 247.42,-70.79 250.62,-69.38"/>
</g>
</g>
</svg>
'/><h1 id="5.-Generalizing-Graphs"><a class="docs-heading-anchor" href="#5.-Generalizing-Graphs">5. Generalizing Graphs</a><a id="5.-Generalizing-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Generalizing-Graphs" title="Permalink"></a></h1><p>Any data structure which implements the required functions we need can, in principle, be used for rewriting. Importantly this includes pushout_complement, pushout, and homomorphism search. These are all implemented generically for any C-Set schema (allowing us to rewrite Petri nets, Semisimplicial sets, etc.)</p><p>Here we&#39;ll do rewriting in graphs sliced over •⇆•, which is isomorphic to the category of (whole-grain) Petri nets, with States and Transitions.</p><pre><code class="language-julia hljs">function graph_slice(s::Slice)
  h = s.slice
  V, E = collect.([h[:V], h[:E]])
  g = dom(h)
  (S, T), (I, O) = [[findall(==(i), X) for i in 1:2] for X in [V, E]]
  nS, nT, nI, nO = length.([S, T, I, O])
  findS, findT = [x -&gt; findfirst(==(x), X) for X in [S, T]]
  to_graphviz(@acset AlgebraicPetri.PetriNet begin
    S = nS
    T = nT
    I = nI
    O = nO
    is = findS.(g[I, :src])
    it = findT.(g[I, :tgt])
    ot = findT.(g[O, :src])
    os = findS.(g[O, :tgt])
  end)
end;</code></pre><p>This is the graph we are slicing over.</p><pre><code class="language-julia hljs">two = @acset Graph begin
  V = 2
  E = 2
  src = [1, 2]
  tgt = [2, 1]
end</code></pre><div class="c-set">
<span class="c-set-summary">Catlab.Graphs.BasicGraphs.Graph {V:2, E:2}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
    </tr>
  </tbody>
</table>
</div>
<p>Define a rule which deletes a [T] -&gt; S edge</p><pre><code class="language-julia hljs">L_ = path_graph(Graph, 2)
L = Slice(ACSetTransformation(L_, two, V=[2, 1], E=[2])) # [T] ⟶ (S)
graph_slice(L)

I_ = Graph(1)
I = Slice(ACSetTransformation(I_, two, V=[2])) # [T]
R_ = Graph(2)
R = Slice(ACSetTransformation(R_, two, V=[2, 1])) # [T]  (S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Catlab.CategoricalAlgebra.SliceCategories.Slice{Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, @NamedTuple{V::Catlab.CategoricalAlgebra.FinSets.FinDomFunctionVector{Int64, Vector{Int64}, Catlab.CategoricalAlgebra.FinSets.FinSetInt}, E::Catlab.CategoricalAlgebra.FinSets.FinDomFunctionVector{Int64, Vector{Int64}, Catlab.CategoricalAlgebra.FinSets.FinSetInt}}, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph}}(ACSetTransformation((V = FinFunction([2, 1], 2, 2), E = FinFunction(Int64[], 0, 2)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:2}))</code></pre><p>Using homomorphism search in the slice category</p><pre><code class="language-julia hljs">rule = Rule(homomorphism(I, L), homomorphism(I, R))

G_ = path_graph(Graph, 3)
G = Slice(ACSetTransformation(G_, two, V=[1, 2, 1], E=[1, 2])) # (S) ⟶ [T] ⟶ (S)
graph_slice(G)

res = rewrite(rule, G) # (S) ⟶ [T]  (S)
graph_slice(res)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="126pt" height="98pt"
 viewBox="0.00 0.00 126.00 98.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 94)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-94 122,-94 122,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="%236c9ac3" stroke="%236c9ac3" cx="18" cy="-18" rx="18" ry="18"/>
<text text-anchor="middle" x="18" y="-14.3" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="%236c9ac3" stroke="%236c9ac3" cx="18" cy="-72" rx="18" ry="18"/>
<text text-anchor="middle" x="18" y="-68.3" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<polygon fill="%23e28f41" stroke="%23e28f41" points="118,-90 82,-90 82,-54 118,-54 118,-90"/>
<text text-anchor="middle" x="100" y="-68.3" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge1" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M36.36,-72C46.7,-72 60.06,-72 71.78,-72"/>
<polygon fill="black" stroke="black" points="71.95,-75.5 81.95,-72 71.95,-68.5 71.95,-75.5"/>
<text text-anchor="middle" x="59" y="-75.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
</g>
</svg>
'/><p>While the vast majority of functionality is focused on ACSets at the present moment, but there is nothing in principle which limits this.</p><h1 id="6.-Application-conditions"><a class="docs-heading-anchor" href="#6.-Application-conditions">6. Application conditions</a><a id="6.-Application-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Application-conditions" title="Permalink"></a></h1><p>We can construct commutative diagrams with certain edges left unspecified or marked with ∀ or ∃. If only one edge is left free, we can treat the diagram as a boolean function which tests whether the morphism makes the specified paths commute (or not commute). This generalizes positive/negative application conditions and lifting conditions, but because those are most common there are constructors AppCond and LiftCond to make these directly.</p><pre><code class="nohighlight hljs">     ∀</code></pre><p>[↻•]   →  ?     ↓    ↗ ∃ ↓   [↻•⟶•]  → [↻•⟶•⟵•↺]</p><p>Every vertex with a loop also has a map to the vertex marked by the bottom map.</p><pre><code class="language-julia hljs">t = terminal(Graph) |&gt; apex
looparr = @acset_colim yG begin
  (e1, e2)::E
  src(e1) == tgt(e1)
  src(e1) == src(e2)
end

v = homomorphism(t, looparr)
loop_csp = @acset Graph begin
  V = 3
  E = 4
  src = [1, 3, 1, 3]
  tgt = [1, 3, 2, 2]
end
b = homomorphism(looparr, loop_csp; monic=true)
constr = LiftCond(v, b)

@test !apply_constraint(constr, homomorphism(t, loop_csp))
@test apply_constraint(constr, b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>We can combining constraints with logical combinators.</p><p>match vertex iff it has 2 or 3 self loops</p><pre><code class="language-julia hljs">one, two, three, four, five = [@acset(Graph, begin
  V = 1
  E = n
  src = 1
  tgt = 1
end) for n in 1:5]

c2 = AppCond(homomorphism(Graph(1), two); monic=true)         # PAC
c3 = AppCond(homomorphism(Graph(1), four), false; monic=true) # NAC
constr = c2 ⊗ c3 # logical conjunction: 2 ≤ |E| &lt; 4

rule = Rule(id(Graph(1)), id(Graph(1)); ac=[constr])

G = two ⊕ three ⊕ two ⊕ four ⊕ five ⊕ one

@test length(get_matches(rule, G)) == 3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h1 id="7.-Attribute-variables"><a class="docs-heading-anchor" href="#7.-Attribute-variables">7. Attribute variables</a><a id="7.-Attribute-variables-1"></a><a class="docs-heading-anchor-permalink" href="#7.-Attribute-variables" title="Permalink"></a></h1><p>Normally ACSet morphisms must match attribute values exactly, i.e. a weighted graph edge of 8.3 can only be mapped to another edge weighted at 8.3. This becomes very restricted, especially when we want to do some simple computations with attribute values (e.g. when merging two edges, add their values together)</p><p>A recent extension of ACSets makes this possible - each attribute type comes equipped with a finite set of &quot;variables&quot; which can be mapped to any concrete value (or another variable).</p><pre><code class="language-julia hljs">yWG = yoneda_cache(WeightedGraph{Int}; clear=true);
L = @acset_colim yWG begin
  (e1, e2)::E
  src(e1) == src(e2)
  tgt(e1) == tgt(e2)
end
I = WeightedGraph{Int}(2)
R = @acset WeightedGraph{Int} begin
  V = 2
  E = 1
  Weight = 1
  src = 1
  tgt = 2
  weight = [AttrVar(1)]
end

l = homomorphism(I, L; monic=true)
r = homomorphism(I, R; monic=true)
rule = Rule(l, r; monic=[:E], expr=Dict(:Weight =&gt; [xs -&gt; xs[1] + xs[2]]))

G = @acset WeightedGraph{Int} begin
  V = 1
  E = 3
  src = 1
  tgt = 1
  weight = [10, 20, 100]
end

@test rewrite(rule, G) == @acset WeightedGraph{Int} begin
  V = 1
  E = 2
  src = 1
  tgt = 1
  weight = [30, 100]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h1 id="8.-Graph-processes"><a class="docs-heading-anchor" href="#8.-Graph-processes">8. Graph processes</a><a id="8.-Graph-processes-1"></a><a class="docs-heading-anchor-permalink" href="#8.-Graph-processes" title="Permalink"></a></h1><p>A sequence of rewrite applications can be given a poset structure where α ≤ β means that the rule application α needed to occur before β.  This is computed via analyzing the colimit of all the partial maps induced by the rewrites.</p><pre><code class="language-julia hljs">using AlgebraicRewriting.Processes: RWStep, find_deps

G0, G1, G2, G3 = Graph.([0, 1, 2, 3])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Catlab.Graphs.BasicGraphs.Graph}:
 Catlab.Graphs.BasicGraphs.Graph:
  V = 1:0
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[]
 Catlab.Graphs.BasicGraphs.Graph:
  V = 1:1
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[]
 Catlab.Graphs.BasicGraphs.Graph:
  V = 1:2
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[]
 Catlab.Graphs.BasicGraphs.Graph:
  V = 1:3
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[]</code></pre><p>Delete a node</p><pre><code class="language-julia hljs">Rule1 = Span(create(G1), id(G0));</code></pre><p>Merge two nodes</p><pre><code class="language-julia hljs">Rule2 = Span(id(G2), homomorphism(G2, G1));</code></pre><p>Add a node</p><pre><code class="language-julia hljs">Rule3 = Span(id(G0), create(G1))

R1, R2, R3 = [Rule(l, r) for (l, r) in [Rule1, Rule2, Rule3]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Rule{:DPO}}:
 Rule{:DPO}(ACSetTransformation((V = FinFunction(Int64[], 0, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}), ACSetTransformation((V = id(FinSet(0)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())
 Rule{:DPO}(ACSetTransformation((V = id(FinSet(2)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}), ACSetTransformation((V = FinFunction([1, 1], 2, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())
 Rule{:DPO}(ACSetTransformation((V = id(FinSet(0)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}), ACSetTransformation((V = FinFunction(Int64[], 0, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}), Constraint[], false, Dict{Symbol, Dict{Int64, Union{Nothing, Function}}}())</code></pre><h1 id="9.-Trajectory"><a class="docs-heading-anchor" href="#9.-Trajectory">9. Trajectory</a><a id="9.-Trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#9.-Trajectory" title="Permalink"></a></h1><p>Step 1: add node 3 to G2</p><pre><code class="language-julia hljs">M1 = create(G2)
CM1 = ACSetTransformation(G1, G3; V=[3])
Pmap1 = Span(id(G2), ACSetTransformation(G2, G3; V=[1, 2]))
RS1 = RWStep(Rule3, Pmap1, M1, CM1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AlgebraicRewriting.Processes.RWStep(Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Catlab.Graphs.BasicGraphs.Graph, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple, StaticArraysCore.SVector{2, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple}}(Catlab.Graphs.BasicGraphs.Graph:
  V = 1:0
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[], Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple[ACSetTransformation((V = id(FinSet(0)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}), ACSetTransformation((V = FinFunction(Int64[], 0, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0})]), Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Catlab.Graphs.BasicGraphs.Graph, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple, StaticArraysCore.SVector{2, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple}}(Catlab.Graphs.BasicGraphs.Graph:
  V = 1:2
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[], Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple[ACSetTransformation((V = id(FinSet(2)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}), ACSetTransformation((V = FinFunction([1, 2], 2, 3), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:3, E:0})]), ACSetTransformation((V = FinFunction(Int64[], 0, 2), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:0, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}), ACSetTransformation((V = FinFunction([3], 1, 3), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:3, E:0}))</code></pre><p>Step 2: merge node 2 and 3 to yield a G2</p><pre><code class="language-julia hljs">M2 = ACSetTransformation(G2, G3; V=[2, 3])
CM2 = ACSetTransformation(G1, G2; V=[2])
Pmap2 = Span(id(G3), ACSetTransformation(G3, G2; V=[1, 2, 2]))
RS2 = RWStep(Rule2, Pmap2, M2, CM2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AlgebraicRewriting.Processes.RWStep(Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Catlab.Graphs.BasicGraphs.Graph, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple, StaticArraysCore.SVector{2, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple}}(Catlab.Graphs.BasicGraphs.Graph:
  V = 1:2
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[], Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple[ACSetTransformation((V = id(FinSet(2)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}), ACSetTransformation((V = FinFunction([1, 1], 2, 1), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:1, E:0})]), Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Catlab.Graphs.BasicGraphs.Graph, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple, StaticArraysCore.SVector{2, Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple}}(Catlab.Graphs.BasicGraphs.Graph:
  V = 1:3
  E = 1:0
  src : E → V = Int64[]
  tgt : E → V = Int64[], Catlab.CategoricalAlgebra.CSets.StructTightACSetTransformation{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:V, :E}, Tuple{(:src, :E, :V), (:tgt, :E, :V)}, Tuple{}, Tuple{}}, Comp, Catlab.Graphs.BasicGraphs.Graph, Catlab.Graphs.BasicGraphs.Graph} where Comp&lt;:NamedTuple[ACSetTransformation((V = id(FinSet(3)), E = id(FinSet(0))), Catlab.Graphs.BasicGraphs.Graph {V:3, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:3, E:0}), ACSetTransformation((V = FinFunction([1, 2, 2], 3, 2), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:3, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0})]), ACSetTransformation((V = FinFunction([2, 3], 2, 3), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:3, E:0}), ACSetTransformation((V = FinFunction([2], 1, 2), E = FinFunction(Int64[], 0, 0)), Catlab.Graphs.BasicGraphs.Graph {V:1, E:0}, Catlab.Graphs.BasicGraphs.Graph {V:2, E:0}))</code></pre><p>Step 3: delete vertex 1</p><pre><code class="language-julia hljs">M3 = ACSetTransformation(G1, G2; V=[1])
CM3 = create(G1)
Pmap3 = Span(ACSetTransformation(G1, G2; V=[2]), id(G1))
RS3 = RWStep(Rule1, Pmap3, M3, CM3)


steps = [RS1, RS2, RS3]

g = find_deps(steps)
to_graphviz(g; node_labels=true)

expected = @acset Graph begin
  V = 3
  E = 1
  src = 1
  tgt = 2
end
@test expected == g</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>Interface that just uses rules and match morphisms: The matches needed to be updated to reflect the particular isomorph that DPO rewriting produces when applying the rule.</p><pre><code class="language-julia hljs">σ₂ = ACSetTransformation(G2, G2; V=[2, 1])
σ₃ = ACSetTransformation(G3, G3; V=[3, 1, 2])

g′ = find_deps([R3 =&gt; M1, R2 =&gt; M2 ⋅ σ₃, R1 =&gt; M3 ⋅ σ₂])
@test g′ == g</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« AlgebraicRewriting.jl</a><a class="docs-footer-nextpage" href="../game_of_life/">Conway&#39;s Game of Life »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 28 February 2024 02:00">Wednesday 28 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
