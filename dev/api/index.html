<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · AlgebraicRewriting.jl</title><meta name="title" content="Library Reference · AlgebraicRewriting.jl"/><meta property="og:title" content="Library Reference · AlgebraicRewriting.jl"/><meta property="twitter:title" content="Library Reference · AlgebraicRewriting.jl"/><meta name="description" content="Documentation for AlgebraicRewriting.jl."/><meta property="og:description" content="Documentation for AlgebraicRewriting.jl."/><meta property="twitter:description" content="Documentation for AlgebraicRewriting.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlgebraicRewriting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlgebraicRewriting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AlgebraicRewriting.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/full_demo/">Full Demo</a></li><li><a class="tocitem" href="../generated/game_of_life/">Conway&#39;s Game of Life</a></li><li><a class="tocitem" href="../generated/lotka_volterra/">Lotka Volterra</a></li><li><a class="tocitem" href="../generated/ptg_simple/">Slice Bread</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Rewrite"><span>Rewrite</span></a></li><li><a class="tocitem" href="#Schedules"><span>Schedules</span></a></li><li><a class="tocitem" href="#CategoricalAlgebra"><span>CategoricalAlgebra</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><h2 id="Rewrite"><a class="docs-heading-anchor" href="#Rewrite">Rewrite</a><a id="Rewrite-1"></a><a class="docs-heading-anchor-permalink" href="#Rewrite" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{CGraph}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{CGraph}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Apply migration to all literals in the constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolAnd" href="#AlgebraicRewriting.Rewrite.Constraints.BoolAnd"><code>AlgebraicRewriting.Rewrite.Constraints.BoolAnd</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Conjunction of multiple expressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolConst" href="#AlgebraicRewriting.Rewrite.Constraints.BoolConst"><code>AlgebraicRewriting.Rewrite.Constraints.BoolConst</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constant, independent of context</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolExpr" href="#AlgebraicRewriting.Rewrite.Constraints.BoolExpr"><code>AlgebraicRewriting.Rewrite.Constraints.BoolExpr</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Something that, in a context, can be evaluated to a bool</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolNot" href="#AlgebraicRewriting.Rewrite.Constraints.BoolNot"><code>AlgebraicRewriting.Rewrite.Constraints.BoolNot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Negation of an expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolOr" href="#AlgebraicRewriting.Rewrite.Constraints.BoolOr"><code>AlgebraicRewriting.Rewrite.Constraints.BoolOr</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Disjunction of multiple expressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.CGraph" href="#AlgebraicRewriting.Rewrite.Constraints.CGraph"><code>AlgebraicRewriting.Rewrite.Constraints.CGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>&quot;nothing&quot; means something that will be determined via a quantifier Ints are explicit arguments provided when apply_constraint is called</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.Commutes" href="#AlgebraicRewriting.Rewrite.Constraints.Commutes"><code>AlgebraicRewriting.Rewrite.Constraints.Commutes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A commutative diagram with multiple parallel paths, asserted to either  commute or to not commute</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L136-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.Constraint" href="#AlgebraicRewriting.Rewrite.Constraints.Constraint"><code>AlgebraicRewriting.Rewrite.Constraints.Constraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A constraint graph and a BoolExpr (which refers to the constraint graph)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.Quantifier" href="#AlgebraicRewriting.Rewrite.Constraints.Quantifier"><code>AlgebraicRewriting.Rewrite.Constraints.Quantifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Quantified edge</p><p>e - which edge is filled in kind - Exists, Forall, or Exists!  st - &quot;such that&quot;, restrict the domain of quantification via a condition monic - restrict domain of quanitification to only monic matches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L163-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.AppCond" href="#AlgebraicRewriting.Rewrite.Constraints.AppCond"><code>AlgebraicRewriting.Rewrite.Constraints.AppCond</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constraint a constraint that asserts (or denies) the existence of a  triangle commuting.</p><pre><code class="nohighlight hljs"> f₁</code></pre><p>(1) &lt;- (2)    ∃₂↘  ↓ λ₃       (3)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L448-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.LiftCond-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.Rewrite.Constraints.LiftCond-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.Rewrite.Constraints.LiftCond</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  ∀₂</code></pre><p>(1)  →  (3)  ₁↓  ↗∃₃  ↓ λ₅  (2)  →  (4)       ⁴</p><p>Test a map (3)→(4), given maps (1)-&gt;(2)-&gt;(4). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L468-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.arity-Tuple{CGraph}" href="#AlgebraicRewriting.Rewrite.Constraints.arity-Tuple{CGraph}"><code>AlgebraicRewriting.Rewrite.Constraints.arity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Number of variables in a constraint graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.check_expr-Tuple{CGraph, Commutes}" href="#AlgebraicRewriting.Rewrite.Constraints.check_expr-Tuple{CGraph, Commutes}"><code>AlgebraicRewriting.Rewrite.Constraints.check_expr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Validate a commutative diagram constraint makes sense</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr-Tuple{Commutes, CGraph, Vector{Union{Nothing, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}}}" href="#AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr-Tuple{Commutes, CGraph, Vector{Union{Nothing, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}}}"><code>AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check whether homs are equal by looping over domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.get_ob-Tuple{CGraph, Int64, Vector{Union{Nothing, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}}}" href="#AlgebraicRewriting.Rewrite.Constraints.get_ob-Tuple{CGraph, Int64, Vector{Union{Nothing, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}}}"><code>AlgebraicRewriting.Rewrite.Constraints.get_ob</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the C-Set associated with a vertex in a CGraph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.merge_graphs-Tuple{Any, Any}" href="#AlgebraicRewriting.Rewrite.Constraints.merge_graphs-Tuple{Any, Any}"><code>AlgebraicRewriting.Rewrite.Constraints.merge_graphs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Take two CGraphs and merge them along their overlapping vertices and edges Returns an ACSetColimit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L69-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.:⊕-Tuple{Constraint, Constraint}" href="#Catlab.Theories.:⊕-Tuple{Constraint, Constraint}"><code>Catlab.Theories.:⊕</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Combine two constraints disjunctively, sharing as much of the computation graph  as possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L396-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.:⊗-Tuple{Constraint, Constraint}" href="#Catlab.Theories.:⊗-Tuple{Constraint, Constraint}"><code>Catlab.Theories.:⊗</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Combine two constraints conjunctively, sharing as much of the computation graph  as possible (i.e. pushout along the maximum common subgraph)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Constraints.jl#L379-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.Rule" href="#AlgebraicRewriting.Rewrite.Utils.Rule"><code>AlgebraicRewriting.Rewrite.Utils.Rule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Rewrite rules which are (usually) encoded as spans.  The L structure encodes a pattern to be matched.  The R morphism encodes a replacement pattern to be substituted in. They are related to each other by an interface I with maps: L ⟵ I ⟶ R </p><p>A semantics (DPO, SPO, CoNeg, or SqPO) must be chosen.</p><p>Control the match-finding process by specifying whether the match is intended to be monic or not, as well as an optional application condition(s) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.can_match-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.can_match-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.can_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns nothing if the match is acceptable for rewriting according to the rule, otherwise returns the reason why it should be rejected</p><p>homsearch = if we know ahead of time that m was obtained m via automatic hom              search, then we do not need to make certain checks</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.freevars-Union{Tuple{T}, Tuple{Rule{T}, Symbol}} where T" href="#AlgebraicRewriting.Rewrite.Utils.freevars-Union{Tuple{T}, Tuple{Rule{T}, Symbol}} where T"><code>AlgebraicRewriting.Rewrite.Utils.freevars</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get a list of AttrVar indices which are NOT bound by the I→R morphism</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Any, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Any, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Don&#39;t bind variables for things that are not ACSets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given the match morphism and the result, construct a map X → X′ which  binds any free variables introduced into the result.</p><p>L &lt;- I -&gt; R  m ↓    ↓    ↓ res   G &lt;- • -&gt; X              ↓               X′</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L235-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_match-Tuple" href="#AlgebraicRewriting.Rewrite.Utils.get_match-Tuple"><code>AlgebraicRewriting.Rewrite.Utils.get_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get one match (if any exist) otherwise return </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{Rule, ACSets.ACSetInterface.ACSet}" href="#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{Rule, ACSets.ACSetInterface.ACSet}"><code>AlgebraicRewriting.Rewrite.Utils.get_matches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get list of possible matches based on the constraints of the rule</p><p>This function has the same behavior as the generic <code>get_matches</code>, but it is  more performant because we do not have to query all homomorphisms before finding  a valid match, in case n=1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{Rule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{Rule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_matches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>If not rewriting ACSets, we have to compute entire Hom(L,G).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_pmap-Tuple{Symbol, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_pmap-Tuple{Symbol, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_pmap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract the partial map (derived rule) from full output data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_rmap-Tuple{Symbol, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_rmap-Tuple{Symbol, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_rmap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract the map from the R to the result from the full output data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite(r::Rule, G; kw...)</code></pre><p>Perform a rewrite (automatically finding an arbitrary match) and return result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L270-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_match(r::Rule, m; kw...)</code></pre><p>Perform a rewrite (with a supplied match morphism) and return result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Utils.jl#L280-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:DPO}, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:DPO}, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_match_maps(r::Rule{:DPO}, m)</code></pre><p>Apply a DPO rewrite rule (given as a span, L&lt;-I-&gt;R) to a ACSet using a match morphism <code>m</code> which indicates where to apply the rewrite.               l   r            L &lt;- I -&gt; R          m ↓    ↓    ↓            G &lt;- K -&gt; H</p><p>This works for any type that implements <code>pushout_complement</code> and <code>pushout</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/DPO.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:CoNeg}, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:CoNeg}, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_match_maps(r::Rule{:CoNeg}, m)</code></pre><p>Apply a CoNegation rewrite rule (given as a span, L↩I-&gt;R) to a ACSet using a monic match morphism <code>m</code> which indicates where to apply the rewrite.               l   r            L &lt;- I -&gt; R          m ↓    ↓    ↓            G &lt;- K -&gt; H   where  K = ~L ∨ I</p><p>This works for any type that implements bi-Heyting logic operators ~ and ∨.</p><p>This is described <a href="https://topos.site/blog/2023/04/conegation-rewriting">here</a>. Essentially, it is partway between DPO and SPO. Suppose the rule tries to delete two things, one of which satisfies the dangling condition, the other violates it. While DPO would fail to apply at all, and SPO would delete both things (cascading  the deletion for the latter), co-negation rewriting would simply delete the item  which can be deleted without cascading and ignore the other element.</p><p>It includes a quote which indicates that this method should work even when the  match morphism isn&#39;t monic, if it satisfies the identification condition.  Supporting this is not yet implemented.</p><p>Match morphisms which bind attribute variables are not monic, hence we this  form of rewriting doesn&#39;t support VarACSets. Intuitively, it feels like this  restriction could be relaxed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/CoNeg.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.SPO.partial_pushout-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}" href="#AlgebraicRewriting.Rewrite.SPO.partial_pushout-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}"><code>AlgebraicRewriting.Rewrite.SPO.partial_pushout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>C ← Ag ↪ A ↩ Af → B </p><p>A ↩ f∇g → Bgf ↪ B       ↓   ⌜ ↓ C ↩ Cfg -&gt; D</p><p>Implementation of Construction 6 in Löwe&#39;s  &quot;Algebraic approach to SPO graph transformation&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/SPO.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.ComposableHoms.ComposablePair{Ob, Hom} where {Ob, Hom}}" href="#AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.ComposableHoms.ComposablePair{Ob, Hom} where {Ob, Hom}}"><code>AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See Theorem 2 of &#39;Concurrency Theorems for Non-linear Rewriting Theories&#39;       f   B &lt;–- A m ↓      ↓ n   C &lt;–  D      g</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/SqPO.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:SqPO}, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:SqPO}, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_match_maps(r::Rule{:SqPO},m; pres::Union{Nothing, Presentation}=nothing)</code></pre><p>Sesqui-pushout is just like DPO, except we use a final pullback complement instead of a pushout complement.</p><pre><code class="nohighlight hljs">r.L  r.R</code></pre><p>L &lt;-⌞K -&gt; R m ↓    ↓k   ↓ r   I &lt;- • -&gt;⌜O      i   o</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/SqPO.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.PBPORule" href="#AlgebraicRewriting.Rewrite.PBPO.PBPORule"><code>AlgebraicRewriting.Rewrite.PBPO.PBPORule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  l    r</code></pre><p>L  ⟵ K ⟶ R  tl ↓     ↓ tk     &lt;== tl, tk must be monic     L&#39; ⟵ K&#39;</p><p>It is assumed we never want the typing/adherence match to be monic, but we  can optionally restrict the match L → G to be monic.</p><p>We can attach application conditions to both the match morphism as well as the  adherence morphism. Until morphism search under constraints becomes efficient, it&#39;s sometimes needed to just directly state the adherence morphism as a  function of the match morphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.canon-NTuple{5, Any}" href="#AlgebraicRewriting.Rewrite.PBPO.canon-NTuple{5, Any}"><code>AlgebraicRewriting.Rewrite.PBPO.canon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Take a PBPO rule and put into normal form, i.e.  where the lower square forms a pullback</p><p>See Prop 2.4 of &quot;The PBPO graph transformation approach&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.partial_abstract-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.Rewrite.PBPO.partial_abstract-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.Rewrite.PBPO.partial_abstract</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This construction addresses the following problem: ideally when we &#39;abstract&#39;  an ACSet from X to A-&gt;X, maps <em>into</em> X, say B-&gt;X, can be canonically pulled back  to maps B-&gt;A which commute. However, A won&#39;t do  here, because there may not even exist any maps B-&gt;A. If B has concrete  attributes, then those cannot be sent to an AttrVar in A. Furthermore, if B  has multiple &#39;references&#39; to an AttrVar (two different edges, each with  AttrVar(1), sent to two different edges with the same atttribute value in X),  then there is no longer a <em>canonical</em> place to send AttrVar(1) to in A, as there  is a distinct AttrVar for every single part+attr in X. So we need a construction  which does two things to A-&gt;X, starting with a map B-&gt;X. 1.) replaces exactly the  variables we need with concrete values in order to allow a map B-&gt;A, 2.) quotients  variables in A so that there is exactly one choice for where to send attrvars in  B such that the triangle commutes.</p><p>Starting with a map L -&gt; G (where G has no AttrVars),  we want the analogous map into a &quot;partially abstracted&quot; version of G that  has concrete attributes replaced with AttrVars <em>EXCEPT</em> for those attributes  which are mapped to by concrete attributes of L. Likewise, multiple occurences  of the same variable in L correspond to AttrVars which should be merged in the  partially-abstracted G.</p><p>For example, for a schema with a single Ob and Attr (where all combinatorial  maps are just {1↦1, 2↦2}):</p><ul><li><p>L = [AttrVar(1), :foo]</p></li><li><p>G = [:bar, :foo, :baz]</p></li><li><p>abs(G) = [AttrVar(1), AttrVar(2), AttrVar(3)]</p></li><li><p>expected result: [AttrVar(1), :foo, AttrVar(2)]</p><p>L  -&gt; Partial_abs(G)  ↓          ↑  G  &lt;-   abs(G)</p></li></ul><p>This function computes the top arrow of this diagram starting with the left  arrow. The bottom arrow is computed by <code>abstract_attributes</code> and the right  arrow by <code>sub_vars</code>. Furthermore, a map from Partial_abs(G) to G is provided.</p><p>This is the factorization system arising from a coreflective subcategory.</p><p>(see https://ncatlab.org/nlab/show/reflective+factorization+system  and https://blog.algebraicjulia.org/post/2023/06/varacsets/)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L188-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.test_adherence-Tuple{PBPORule, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.Rewrite.PBPO.test_adherence-Tuple{PBPORule, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.Rewrite.PBPO.test_adherence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <code>get_matches(::PBPORule, ::ACSet)</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Tuple{PBPORule, Any, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Tuple{PBPORule, Any, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Use exprs and k_exprs to fill in variables introduced by applying the rw rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L329-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{PBPORule, ACSets.ACSetInterface.ACSet}" href="#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{PBPORule, ACSets.ACSetInterface.ACSet}"><code>AlgebraicRewriting.Rewrite.Utils.get_matches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>PBPO matches consist of <em>two</em> morphisms. First, a match m: L → G, and secondly  a typing G → L′. With attributes, it is not so simple because G has concrete  values for attributes and L′ may have variables. Therefore, we actually change the  typing to map out of A, an abstracted version of G (with its attributes replaced  by variables). So we lift matches L-&gt;G to matches L-&gt;A, then search α∈Hom(A,L′).</p><p>In general, we want α to be uniquely determined by m, so by default <code>α_unique</code>   is set to true.</p><pre><code class="nohighlight hljs"> m</code></pre><p>L⌟ ⟶ G   ||     ↓ α   L  ⟶ L′      tl</p><pre><code class="nohighlight hljs"> m</code></pre><p>L ⟶ G  tl ↓ ↘a ↑ (abs = partial abstraction. Note <code>a</code> is <code>Labs</code> in the code.)    L′⟵ A        α</p><p>The &quot;strong match&quot; condition we enforce is that: tl⁻¹(α(A)) = a⁻¹(A). This means  we can deduce precisely what m is by looking at α.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L98-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{PBPORule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{PBPORule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">         r
      K ----&gt; R
gₗ    u ↓ gᵣ ⌜ ↓ w</code></pre><p>Gₗ &lt;–– Gk ––&gt; Gᵣ α ↓    ⌞ ↓ u&#39;  L′ &lt;–  K′      tₗ</p><p>For the adherence morphism α to be valid, it must satisfy a condition with  m, tₗ. This is checked for matches provided by get_matches, so by default  we do not check it.</p><p>L &lt;–⌞• m ↓     ↓   G ⟵ Gk</p><p>See Lemma 7.2 of &quot;TERMINATION OF GRAPH TRANSFORMATION SYSTEMS USING WEIGHTED  SUBGRAPH COUNTING&quot; by Overbeek and Endrullis (2023)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/PBPO.jl#L294-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Migration.pres_hash-Tuple{GATlab.Models.Presentations.Presentation}" href="#AlgebraicRewriting.Rewrite.Migration.pres_hash-Tuple{GATlab.Models.Presentations.Presentation}"><code>AlgebraicRewriting.Rewrite.Migration.pres_hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Want a filename that is stable to multiple Julia sessions but changes when the schema changes. This minimizes the need to clear the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/rewrite/Migration.jl#L37-L40">source</a></section></article><h2 id="Schedules"><a class="docs-heading-anchor" href="#Schedules">Schedules</a><a id="Schedules-1"></a><a class="docs-heading-anchor-permalink" href="#Schedules" title="Permalink"></a></h2><pre><code class="language- hljs">Modules = [
  AlgebraicRewriting.Theories,
  AlgebraicRewriting.Poly,
  AlgebraicRewriting.Wiring,
  AlgebraicRewriting.Eval,
  AlgebraicRewriting.Basic,
  AlgebraicRewriting.Conditionals,
  AlgebraicRewriting.RuleApps,
  AlgebraicRewriting.Queries,
  AlgebraicRewriting.Visuals
]</code></pre><h2 id="CategoricalAlgebra"><a class="docs-heading-anchor" href="#CategoricalAlgebra">CategoricalAlgebra</a><a id="CategoricalAlgebra-1"></a><a class="docs-heading-anchor-permalink" href="#CategoricalAlgebra" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#243" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#243"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#243</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute a pushout complement of finite sets, if possible.</p><p>Given functions <span>$l: I → L$</span> and <span>$m: L → G$</span> to form a pushout square</p><pre><code class="nohighlight hljs">l</code></pre><p>L ← I m ↓   ↓k   G ← K     g</p><p>define the set <span>$K := G / m(L / l(I))$</span> and take <span>$g: K ↪ G$</span> to be the inclusion. Then the map <span>$k: I → K$</span> is determined by the map <span>$l⋅m: I → G$</span> from the requirement that the square commutes.</p><p>Pushout complements exist only if the identification condition is satisfied. An error will be raised if the pushout complement cannot be constructed. To check this in advance, use <a href="@ref"><code>can_pushout_complement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/FinSets.jl#L14-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#249" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#249"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#249</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute a pushout complement of finite sets, if possible.</p><p>Given functions <span>$l: I → L$</span> and <span>$m: L → G$</span> to form a pushout square</p><pre><code class="nohighlight hljs">l</code></pre><p>L ← I m ↓   ↓k   G ← K     g</p><p>define the set <span>$K := G ∖ m(L ∖ l(I))$</span> and take <span>$g: K ↪ G$</span> to be the inclusion. Then the map <span>$k: I → K$</span> is determined by the map <span>$l⋅m: I → G$</span> from the requirement that the square commutes.</p><p>For example, if L = I = {1} and G = {1,2}, then  l({1}) = {1}, L ∖ l(I) = {} and G∖ m({}) = {1,2}.</p><p>Pushout complements exist only if the identification condition is satisfied. An error will be raised if the pushout complement cannot be constructed. To check this in advance, use <a href="@ref"><code>can_pushout_complement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/FinSets.jl#L72-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#252" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#252"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.##docsink#252</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Because l is monic, the map l:I+T ↣ L+T secretly is just a map l′:I↣L and T=T</p><p>We&#39;ll also assume that the map m: L+T-&gt;G+T is secretly just a map L-&gt;T (G=∅).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/FinSets.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.BasicSets.FinDomFunctions.FinDomFunction, Catlab.BasicSets.FinDomFunctions.FinDomFunction}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.BasicSets.FinDomFunctions.FinDomFunction, Catlab.BasicSets.FinDomFunctions.FinDomFunction}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Kleisli composition </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/FinSets.jl#L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.BasicSets.FinFunctions.FinFunction, Catlab.BasicSets.FinFunctions.FinFunction}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.BasicSets.FinFunctions.FinFunction, Catlab.BasicSets.FinFunctions.FinFunction}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check identification condition for pushout complement of finite sets.</p><p>The identification condition says that the functions do not map (1) both a deleted item and a preserved item in L to the same item in G or (2) two distinct deleted items to the same item. It is trivially satisfied for injective functions.</p><p>Returns pair of iterators of</p><p>(1) a nondeleted item that maps to a deleted item in G   (2) a pair of distinct items in L that are deleted yet mapped to the same       item in G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/FinSets.jl#L135-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>TODO: check if functorial</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.##docsink#255" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.##docsink#255"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.##docsink#255</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute pushout complement of attributed C-sets, if possible.</p><p>The pushout complement is constructed pointwise from pushout complements of finite sets. If any of the pointwise identification conditions fail (in FinSet), this method will raise an error. If the dangling condition fails, the resulting C-set will be only partially defined. To check all these conditions in advance, use the function <a href="@ref"><code>can_pushout_complement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L173-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj-Tuple{ACSets.ACSetInterface.ACSet, Any}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj-Tuple{ACSets.ACSetInterface.ACSet, Any}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Recursively delete anything, e.g. deleting a vertex deletes its edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb-NTuple{4, Any}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb-NTuple{4, Any}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Y   i↘  f_     X → •  g_ ↓ ⌟ ↓ f     • → •          g</p><p>Check whether (X, f<em>,g</em>) is the pullback of (f,g), up to isomorphism (i.e. the  pullback of f and g produces (Y,π₁,π₂), where Y is isomorphic to X and  i⋅f_ = π₁ &amp; i⋅g_ = π₂.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.fibers-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.fibers-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.fibers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Every morphism induces a partition of the parts of the domain. This function  finds every nontrivial partition (size greater than one element) for the objects of the schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Invert a morphism which may not be monic nor epic. When the morphism is not  monic, an arbitrary element of the preimage is mapped to. When it is not epic, a completely arbitrary element is mapped to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Invert some (presumed iso) components of an ACSetTransformation (given by s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.lift_morphism_constraints-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.lift_morphism_constraints-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.lift_morphism_constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given   f: A-&gt;C and g: B-&gt;C, find all morphisms A-&gt;B that make the triangle commute </p><pre><code class="nohighlight hljs">                ??? 
              A  ⇉  B 
              f ↘ ↙ g
                 C</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a value for each variable, create a morphism X → X′ which applies the  substitution. We do this via pushout.</p><p>O –&gt; X    where C has AttrVars for <code>merge</code> equivalence classes    ↓          and O has only AttrVars (sent to concrete values or eq classes    C          in the map to C.</p><p><code>subs</code> and <code>merge</code> are dictionaries keyed by attrtype names</p><p><code>subs</code> values are int-keyed dictionaries indicating binding, e.g.  <code>; subs = (Weight = Dict(1 =&gt; 3.20, 5 =&gt; 2.32), ...)</code></p><p><code>merge</code> values are vectors of vectors indicating equivalence classes, e.g. <code>; merge = (Weight = [[2,3], [4,6]], ...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L347-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.var_eqs-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.var_eqs-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.var_eqs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Further induced equations between AttrVars, given a specific match morphism</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback-Union{Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multicospan{var&quot;#s110&quot;, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {var&quot;#s110&quot;&lt;:(ACSets.DenseACSets.StructACSet{S, Ts}), Hom, Foot}}, Tuple{Ts}, Tuple{S}} where {S, Ts}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback-Union{Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multicospan{var&quot;#s110&quot;, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {var&quot;#s110&quot;&lt;:(ACSets.DenseACSets.StructACSet{S, Ts}), Hom, Foot}}, Tuple{Ts}, Tuple{S}} where {S, Ts}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Take an ACSet pullback combinatorially and freely add variables for all  attribute subparts.</p><p>This relies on implementation details of <code>abstract</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/CSets.jl#L388-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A component-wise map between two cospans. The first component given is the apex map, with the following maps being the legs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A span of StructuredMulticospanHoms, interpreted as a DPO rewrite rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Tuple{openrule, openrule}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Tuple{openrule, openrule}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composeH_(r₁, r₂)</code></pre><p>compose two rewrite rules horizontally (via pushouts) as shown below:     L₁₋₍ₙ₋₁₎-&gt; L &lt;- Lₙ    X₁ -&gt; X &lt;- X₂₋ₘ     L₁₋₍ₙ₋₁₎ -&gt; L +Lₙ X &lt;- X₂₋ₘ     ↑        λ ↑    ↑     ↑    ↑ χ    ↑          ↑           ↑        ↑     I₁₋₍ₙ₋₁₎-&gt; I &lt;- Iₙ ∘h Y₁ -&gt; Y &lt;- Y₂₋ₘ  =  I₁₋₍ₙ₋₁₎ -&gt; I +Iₙ Y &lt;- Y₂₋ₘ     ↓        ρ ↓    ↓     ↓    ↓ ζ    ↓          ↓           ↓        ↓     R₁₋₍ₙ₋₁₎-&gt; R &lt;- Rₙ    Z₁ -&gt; Z &lt;- Z₂₋ₘ     R₁₋₍ₙ₋₁₎ -&gt; R +Rₙ Z &lt;- Z₂₋ₘ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L175-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Union{Tuple{L}, Tuple{Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan{L}, Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan{L}}} where L" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Union{Tuple{L}, Tuple{Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan{L}, Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan{L}}} where L"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Cospan composition given by pushout</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Finset span composition given by pullback</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{openrule, openrule}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{openrule, openrule}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composeV_(r₁, r₂)</code></pre><p>compose two rewrite rules vertically with pullbacks, as shown below:        L₁₋ₙ -&gt; L        ↑       ↑        I₁₋ₙ -&gt; I        ↓       ↓         L₁₋ₙ        -&gt;   L        R₁₋ₙ -&gt; R           ↑              ↑            ∘v      = I₁₋ₙ ×ᵣ₁₋ₙ  Θ₁₋ₙ -&gt; I ×ᵣ Θ        Λ₁₋ₙ -&gt; Λ           ↓              ↓        ↑       ↑         Ω₁₋ₙ        -&gt;   Ω        Θ₁₋ₙ -&gt; Θ        ↓       ↓        Ω₁₋ₙ -&gt; Ω</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L217-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_-Union{Tuple{L_}, Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb{L_}}} where L_" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_-Union{Tuple{L_}, Tuple{Catlab.CategoricalAlgebra.Cats.FreeDiagrams.Multispans.Multispan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb{L_}}} where L_"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Pass dummy value in because a span of invertible FinFunctions does not retain L type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L157-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_-Union{Tuple{Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb{L}}, Tuple{L}} where L" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_-Union{Tuple{Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb{L}}, Tuple{L}} where L"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Vertical arrows are spans of invertible finfunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement-Tuple{openrule, StructuredMultiCospanHom}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement-Tuple{openrule, StructuredMultiCospanHom}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Initial data: 4 structured cospans + 3 cospan morphisms: μ, λ, ρ      g G₁₋ₙ –&gt; G ↑    l  ↑ μ L₁₋ₙ –&gt; L ↑    i  ↑ λ I₁₋ₙ –&gt; I ↓    r  ↓ ρ R₁₋ₙ –&gt; R</p><p>Computed data: 2 new structured cospans + 4 cospan morphisms: γ, η, ik, rh         G₁₋ₙ      G           ↑    k  ↑ γ   ik  I₁₋ₙ -&gt; K₁₋ₙ  –&gt; K    &lt;– I           ↓    h  ↓ η   rh  R₁₋ₙ -&gt; H₁₋ₙ  –&gt; H    &lt;– R In the context of the legs of a multicospan, the indices 1-n refer to the n legs of the cospan. In the context of a map of multicospans, there are 1-(n+1) maps, with the first one designating the map of the apexes. Hence it can make sense to have the elements: zip(legs, maps[2:end]) = [(legᵢ, mapᵢ), ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L251-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite-Tuple{openrule, StructuredMulticospan}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite-Tuple{openrule, StructuredMulticospan}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Apply a rewrite rule to a structured multicospan, where a matching cospan homomorphism is found automatically. If multiple matches are found, a particular one can be selected using <code>m_index</code>. Returns <code>nothing</code> if none are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match-Tuple{openrule, StructuredMultiCospanHom}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match-Tuple{openrule, StructuredMultiCospanHom}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract the rewritten structured cospan from the induced rewrite rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L306-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.HomSearch.homomorphisms-Union{Tuple{L}, Tuple{StructuredMulticospan{L}, StructuredMulticospan{L}}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.HomSearch.homomorphisms-Union{Tuple{L}, Tuple{StructuredMulticospan{L}, StructuredMulticospan{L}}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.HomSearch.homomorphisms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Find homomorphisms between structured cospans. These are constrained to be iso on the legs of the cospans. Solving this w/ homomorphism finding  requires a dynamic acset, and the current hack will be replaced once those are available.</p><p>A homomorphism backend that uses SAT/SMT would also make this viable to do without hacking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/StructuredCospans.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs-Tuple{ACSets.DenseACSets.StructACSet, GATlab.Models.Presentations.Presentation, Symbol, Int64}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs-Tuple{ACSets.DenseACSets.StructACSet, GATlab.Models.Presentations.Presentation, Symbol, Int64}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Confirm a C-Set satisfies its equational axioms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path-Tuple{ACSets.DenseACSets.StructACSet, Any, Int64}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path-Tuple{ACSets.DenseACSets.StructACSet, Any, Int64}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Take a GATExpr (an id morphism, a generator, or a composite) and evaluate, starting at a particular point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta-Tuple{ACSets.DenseACSets.StructCSet}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta-Tuple{ACSets.DenseACSets.StructCSet}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The natural injection from X ⟶ T(X) When evaluated on the terminal object, this gives the subobject classfier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation, Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A partial function is defined by the following span:                           m   f                         A ↩ X → B</p><p>We compute ϕ(m,f): A ⟶ T(B) such that the following is a pullback square:      f   X  ⟶ B m ↓     ↓ η(B)   A  ⟶ T(B)      ϕ</p><p>Essentially, ϕ sends elements of A to the &#39;real&#39; values in T(B) when A is in the subobject picked out by X. When A is &#39;deleted&#39;, it picks out the right element of the additional data added by T(B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L152-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom-Tuple{Catlab.CategoricalAlgebra.Pointwise.ACSetTransformations.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Because the functorial embedding of objects keeps a copy of the original data, what to do with morphisms is just carry them along. Because our implementation adds all of the additional stuff afterwards, index-wise, we can use literally the same data for a morphism lifted from X⟶Y to T(X)⟶T(Y).</p><p>However, we still need to map the extra stuff in T(X) to the proper extra stuff in T(Y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L104-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob-Tuple{ACSets.DenseACSets.StructCSet}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob-Tuple{ACSets.DenseACSets.StructCSet}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A functor T, playing the role of Maybe in Set, but generalized to C-Sets.</p><p>When called on the terminal object, this produces the subobject classifier: See Mulry &quot;Partial map classifiers and cartesian closed categories&quot; (1994)</p><p>This function specifies what T does on objects. The key properties:</p><ol><li>for all X ∈ Ob(C), η(X):X⟶T(X) is monic.                 m   f                                    ϕ(m,f)</li><li>for each span A ↩ X → B, there exists a unique morphism A ⟶ T(B) such that (m,f) is the pullback of ϕ(m,f),η(B))</li></ol><p>Not only do we add an extra element to each component of the C-Set, but we need to consider the possibility that a component (with n outgoing morphisms) has any combination of the targets of those morphisms deleted (like the subobject classifier, there are different <em>ways</em> for something to be deleted).</p><p>For example, in Graph, an edge can be deleted that goes between any two vertices of the graph. We can&#39;t map all deleted edges to the same point in T(E) (if we&#39;re going to satisfy that desired property #2), so we need an extra edge in T(E) for every possibility (from V1 to V2, from V1 to V3, ..., from [Deleted] to V1, ..., from V2 to [Deleted], ... from [Deleted] to [Deleted]), where [Deleted] is our name for the extra element added to T(V).</p><pre><code class="nohighlight hljs">                [src]     [tgt]</code></pre><p>Thus, T(E) ≅ |E| + (|V|+1) × (|V|+1).</p><p>In general, T(X) ≅ |X| + ∏ₕ(|T(codom(h))|) for each outgoing morphism h::X⟶Y</p><ul><li>the |X| corresponds to the &#39;real&#39; elements of X</li><li>the second term corresponds to the possible ways an X can be deleted.</li><li>This recursive formula means we require the schema of the C-set to be acyclic otherwise the size is infinite (assumes schema is free).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L40-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs-Tuple{Any}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs-Tuple{Any}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get topological sort of objects of a schema. Fail if cyclic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/23f444de687d3926cbd0c8e7fd2fc574b40af8e6/src/categorical_algebra/PartialMap.jl#L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/ptg_simple/">« Slice Bread</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 21:52">Friday 1 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
