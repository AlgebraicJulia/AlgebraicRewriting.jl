<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · AlgebraicRewriting.jl</title><meta name="title" content="Library Reference · AlgebraicRewriting.jl"/><meta property="og:title" content="Library Reference · AlgebraicRewriting.jl"/><meta property="twitter:title" content="Library Reference · AlgebraicRewriting.jl"/><meta name="description" content="Documentation for AlgebraicRewriting.jl."/><meta property="og:description" content="Documentation for AlgebraicRewriting.jl."/><meta property="twitter:description" content="Documentation for AlgebraicRewriting.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlgebraicRewriting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlgebraicRewriting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AlgebraicRewriting.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/full_demo/">Full Demo</a></li><li><a class="tocitem" href="../generated/game_of_life/">Conway&#39;s Game of Life</a></li><li><a class="tocitem" href="../generated/lotka_volterra/">Lotka Volterra</a></li><li><a class="tocitem" href="../generated/ptg_simple/">Slice Bread</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Rewrite"><span>Rewrite</span></a></li><li><a class="tocitem" href="#Schedules"><span>Schedules</span></a></li><li><a class="tocitem" href="#CategoricalAlgebra"><span>CategoricalAlgebra</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><h2 id="Rewrite"><a class="docs-heading-anchor" href="#Rewrite">Rewrite</a><a id="Rewrite-1"></a><a class="docs-heading-anchor-permalink" href="#Rewrite" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{CGraph}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{CGraph}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply migration to all literals in the constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolAnd" href="#AlgebraicRewriting.Rewrite.Constraints.BoolAnd"><code>AlgebraicRewriting.Rewrite.Constraints.BoolAnd</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Conjunction of multiple expressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolConst" href="#AlgebraicRewriting.Rewrite.Constraints.BoolConst"><code>AlgebraicRewriting.Rewrite.Constraints.BoolConst</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Constant, independent of context</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolExpr" href="#AlgebraicRewriting.Rewrite.Constraints.BoolExpr"><code>AlgebraicRewriting.Rewrite.Constraints.BoolExpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Something that, in a context, can be evaluated to a bool</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolNot" href="#AlgebraicRewriting.Rewrite.Constraints.BoolNot"><code>AlgebraicRewriting.Rewrite.Constraints.BoolNot</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Negation of an expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.BoolOr" href="#AlgebraicRewriting.Rewrite.Constraints.BoolOr"><code>AlgebraicRewriting.Rewrite.Constraints.BoolOr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Disjunction of multiple expressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.CGraph" href="#AlgebraicRewriting.Rewrite.Constraints.CGraph"><code>AlgebraicRewriting.Rewrite.Constraints.CGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>&quot;nothing&quot; means something that will be determined via a quantifier Ints are explicit arguments provided when apply_constraint is called</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.Commutes" href="#AlgebraicRewriting.Rewrite.Constraints.Commutes"><code>AlgebraicRewriting.Rewrite.Constraints.Commutes</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A commutative diagram with multiple parallel paths, asserted to either  commute or to not commute</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L134-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.Constraint" href="#AlgebraicRewriting.Rewrite.Constraints.Constraint"><code>AlgebraicRewriting.Rewrite.Constraints.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A constraint graph and a BoolExpr (which refers to the constraint graph)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.Quantifier" href="#AlgebraicRewriting.Rewrite.Constraints.Quantifier"><code>AlgebraicRewriting.Rewrite.Constraints.Quantifier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Quantified edge</p><p>e - which edge is filled in kind - Exists, Forall, or Exists!  st - &quot;such that&quot;, restrict the domain of quantification via a condition monic - restrict domain of quanitification to only monic matches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.AppCond" href="#AlgebraicRewriting.Rewrite.Constraints.AppCond"><code>AlgebraicRewriting.Rewrite.Constraints.AppCond</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Constraint a constraint that asserts (or denies) the existence of a  triangle commuting.</p><pre><code class="nohighlight hljs"> f₁</code></pre><p>(1) &lt;- (2)    ∃₂↘  ↓ λ₃       (3)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L443-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.LiftCond-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}" href="#AlgebraicRewriting.Rewrite.Constraints.LiftCond-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}"><code>AlgebraicRewriting.Rewrite.Constraints.LiftCond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">  ∀₂</code></pre><p>(1)  →  (3)  ₁↓  ↗∃₃  ↓ λ₅  (2)  →  (4)       ⁴</p><p>Test a map (3)→(4), given maps (1)-&gt;(2)-&gt;(4). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L462-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.arity-Tuple{CGraph}" href="#AlgebraicRewriting.Rewrite.Constraints.arity-Tuple{CGraph}"><code>AlgebraicRewriting.Rewrite.Constraints.arity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of variables in a constraint graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.check_expr-Tuple{CGraph, Commutes}" href="#AlgebraicRewriting.Rewrite.Constraints.check_expr-Tuple{CGraph, Commutes}"><code>AlgebraicRewriting.Rewrite.Constraints.check_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Validate a commutative diagram constraint makes sense</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr-Tuple{Commutes, CGraph, Vector{Union{Nothing, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}}}" href="#AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr-Tuple{Commutes, CGraph, Vector{Union{Nothing, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}}}"><code>AlgebraicRewriting.Rewrite.Constraints.eval_boolexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check whether homs are equal by looping over domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.get_ob-Tuple{CGraph, Int64, Vector{Union{Nothing, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}}}" href="#AlgebraicRewriting.Rewrite.Constraints.get_ob-Tuple{CGraph, Int64, Vector{Union{Nothing, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}}}"><code>AlgebraicRewriting.Rewrite.Constraints.get_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the C-Set associated with a vertex in a CGraph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Constraints.merge_graphs-Tuple{Any, Any}" href="#AlgebraicRewriting.Rewrite.Constraints.merge_graphs-Tuple{Any, Any}"><code>AlgebraicRewriting.Rewrite.Constraints.merge_graphs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take two CGraphs and merge them along their overlapping vertices and edges Returns an ACSetColimit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L67-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.:⊕-Tuple{Constraint, Constraint}" href="#Catlab.Theories.:⊕-Tuple{Constraint, Constraint}"><code>Catlab.Theories.:⊕</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Combine two constraints disjunctively, sharing as much of the computation graph  as possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L391-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.:⊗-Tuple{Constraint, Constraint}" href="#Catlab.Theories.:⊗-Tuple{Constraint, Constraint}"><code>Catlab.Theories.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Combine two constraints conjunctively, sharing as much of the computation graph  as possible (i.e. pushout along the maximum common subgraph)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Constraints.jl#L374-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.Rule" href="#AlgebraicRewriting.Rewrite.Utils.Rule"><code>AlgebraicRewriting.Rewrite.Utils.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rewrite rules which are (usually) encoded as spans.  The L structure encodes a pattern to be matched.  The R morphism encodes a replacement pattern to be substituted in. They are related to each other by an interface I with maps: L ⟵ I ⟶ R </p><p>A semantics (DPO, SPO, CoNeg, or SqPO) must be chosen.</p><p>Control the match-finding process by specifying whether the match is intended to be monic or not, as well as an optional application condition(s) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L24-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.can_match-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.can_match-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.can_match</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns nothing if the match is acceptable for rewriting according to the rule, otherwise returns the reason why it should be rejected</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L140-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.freevars-Union{Tuple{T}, Tuple{Rule{T}, Symbol}} where T" href="#AlgebraicRewriting.Rewrite.Utils.freevars-Union{Tuple{T}, Tuple{Rule{T}, Symbol}} where T"><code>AlgebraicRewriting.Rewrite.Utils.freevars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a list of AttrVar indices which are NOT bound by the I→R morphism</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Any, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Any, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Don&#39;t bind variables for things that are not ACSets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Union{Tuple{T}, Tuple{Rule{T}, Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the match morphism and the result, construct a map X → X′ which  binds any free variables introduced into the result.</p><p>L &lt;- I -&gt; R  m ↓    ↓    ↓ res   G &lt;- • -&gt; X              ↓               X′</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L228-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_match-Tuple" href="#AlgebraicRewriting.Rewrite.Utils.get_match-Tuple"><code>AlgebraicRewriting.Rewrite.Utils.get_match</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get one match (if any exist) otherwise return </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_matches-Union{Tuple{T}, Tuple{Rule{T}, ACSets.ACSetInterface.ACSet}} where T" href="#AlgebraicRewriting.Rewrite.Utils.get_matches-Union{Tuple{T}, Tuple{Rule{T}, ACSets.ACSetInterface.ACSet}} where T"><code>AlgebraicRewriting.Rewrite.Utils.get_matches</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get list of possible matches based on the constraints of the rule</p><p>This function has the same behavior as the generic <code>get_matches</code>, but it is  more performant because we do not have to query all homomorphisms before finding  a valid match, in case n=1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_matches-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T" href="#AlgebraicRewriting.Rewrite.Utils.get_matches-Union{Tuple{T}, Tuple{Rule{T}, Any}} where T"><code>AlgebraicRewriting.Rewrite.Utils.get_matches</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If not rewriting ACSets, we have to compute entire Hom(L,G).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_pmap-Tuple{Symbol, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_pmap-Tuple{Symbol, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_pmap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract the partial map (derived rule) from full output data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_rmap-Tuple{Symbol, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_rmap-Tuple{Symbol, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_rmap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract the map from the R to the result from the full output data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite(r::Rule, G; kw...)</code></pre><p>Perform a rewrite (automatically finding an arbitrary match) and return result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L267-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match-Tuple{AlgebraicRewriting.Rewrite.Utils.AbsRule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_match(r::Rule, m; kw...)</code></pre><p>Perform a rewrite (with a supplied match morphism) and return result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/Utils.jl#L276-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:DPO}, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:DPO}, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_match_maps(r::Rule{:DPO}, m)</code></pre><p>Apply a DPO rewrite rule (given as a span, L&lt;-I-&gt;R) to a ACSet using a match morphism <code>m</code> which indicates where to apply the rewrite.               l   r            L &lt;- I -&gt; R          m ↓    ↓    ↓            G &lt;- K -&gt; H</p><p>This works for any type that implements <code>pushout_complement</code> and <code>pushout</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/DPO.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:CoNeg}, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:CoNeg}, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_match_maps(r::Rule{:CoNeg}, m)</code></pre><p>Apply a CoNegation rewrite rule (given as a span, L↩I-&gt;R) to a ACSet using a monic match morphism <code>m</code> which indicates where to apply the rewrite.               l   r            L &lt;- I -&gt; R          m ↓    ↓    ↓            G &lt;- K -&gt; H   where  K = ~L ∨ I</p><p>This works for any type that implements bi-Heyting logic operators ~ and ∨.</p><p>This is described <a href="https://topos.site/blog/2023/04/conegation-rewriting">here</a>. Essentially, it is partway between DPO and SPO. Suppose the rule tries to delete two things, one of which satisfies the dangling condition, the other violates it. While DPO would fail to apply at all, and SPO would delete both things (cascading  the deletion for the latter), co-negation rewriting would simply delete the item  which can be deleted without cascading and ignore the other element.</p><p>It includes a quote which indicates that this method should work even when the  match morphism isn&#39;t monic, if it satisfies the identification condition.  Supporting this is not yet implemented.</p><p>Match morphisms which bind attribute variables are not monic, hence we this  form of rewriting doesn&#39;t support VarACSets. Intuitively, it feels like this  restriction could be relaxed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/CoNeg.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.SPO.partial_pushout-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#AlgebraicRewriting.Rewrite.SPO.partial_pushout-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>AlgebraicRewriting.Rewrite.SPO.partial_pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>C ← Ag ↪ A ↩ Af → B </p><p>A ↩ f∇g → Bgf ↪ B       ↓   ⌜ ↓ C ↩ Cfg -&gt; D</p><p>Implementation of Construction 6 in Löwe&#39;s  &quot;Algebraic approach to SPO graph transformation&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/SPO.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{Ob, Hom} where {Ob, Hom}}" href="#AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{Ob, Hom} where {Ob, Hom}}"><code>AlgebraicRewriting.Rewrite.SqPO.final_pullback_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See Theorem 2 of &#39;Concurrency Theorems for Non-linear Rewriting Theories&#39;       f   B &lt;–- A m ↓      ↓ n   C &lt;–  D      g</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/SqPO.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:SqPO}, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{Rule{:SqPO}, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_match_maps(r::Rule{:SqPO},m; pres::Union{Nothing, Presentation}=nothing)</code></pre><p>Sesqui-pushout is just like DPO, except we use a final pullback complement instead of a pushout complement.</p><pre><code class="nohighlight hljs">r.L  r.R</code></pre><p>L &lt;-⌞K -&gt; R m ↓    ↓k   ↓ r   I &lt;- • -&gt;⌜O      i   o</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/SqPO.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.PBPORule" href="#AlgebraicRewriting.Rewrite.PBPO.PBPORule"><code>AlgebraicRewriting.Rewrite.PBPO.PBPORule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">  l    r</code></pre><p>L  ⟵ K ⟶ R  tl ↓     ↓ tk     &lt;== tl, tk must be monic     L&#39; ⟵ K&#39;</p><p>It is assumed we never want the typing/adherence match to be monic, but we  can optionally restrict the match L → G to be monic.</p><p>We can attach application conditions to both the match morphism as well as the  adherence morphism. Until morphism search under constraints becomes efficient, it&#39;s sometimes needed to just directly state the adherence morphism as a  function of the match morphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/PBPO.jl#L20-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.canon-NTuple{5, Any}" href="#AlgebraicRewriting.Rewrite.PBPO.canon-NTuple{5, Any}"><code>AlgebraicRewriting.Rewrite.PBPO.canon</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take a PBPO rule and put into normal form, i.e.  where the lower square forms a pullback</p><p>See Prop 2.4 of &quot;The PBPO graph transformation approach&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/PBPO.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.PBPO.partial_abstract-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}" href="#AlgebraicRewriting.Rewrite.PBPO.partial_abstract-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}"><code>AlgebraicRewriting.Rewrite.PBPO.partial_abstract</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This construction addresses the following problem: ideally when we &#39;abstract&#39;  an ACSet from X to A-&gt;X, maps <em>into</em> X, say B-&gt;X, can be canonically pulled back  to maps B-&gt;A which commute. However, A won&#39;t do  here, because there may not even exist any maps B-&gt;A. If B has concrete  attributes, then those cannot be sent to an AttrVar in A. Furthermore, if B  has multiple &#39;references&#39; to an AttrVar (two different edges, each with  AttrVar(1), sent to two different edges with the same atttribute value in X),  then there is no longer a <em>canonical</em> place to send AttrVar(1) to in A, as there  is a distinct AttrVar for every single part+attr in X. So we need a construction  which does two things to A-&gt;X, starting with a map B-&gt;X. 1.) replaces exactly the  variables we need with concrete values in order to allow a map B-&gt;A, 2.) quotients  variables in A so that there is exactly one choice for where to send attrvars in  B such that the triangle commutes.</p><p>Starting with a map L -&gt; G (where G has no AttrVars),  we want the analogous map into a &quot;partially abstracted&quot; version of G that  has concrete attributes replaced with AttrVars <em>EXCEPT</em> for those attributes  which are mapped to by concrete attributes of L. Likewise, multiple occurences  of the same variable in L correspond to AttrVars which should be merged in the  partially-abstracted G.</p><p>For example, for a schema with a single Ob and Attr (where all combinatorial  maps are just {1↦1, 2↦2}):</p><ul><li><p>L = [AttrVar(1), :foo]</p></li><li><p>G = [:bar, :foo, :baz]</p></li><li><p>abs(G) = [AttrVar(1), AttrVar(2), AttrVar(3)]</p></li><li><p>expected result: [AttrVar(1), :foo, AttrVar(2)]</p><p>L  -&gt; Partial_abs(G)  ↓          ↑  G  &lt;-   abs(G)</p></li></ul><p>This function computes the top arrow of this diagram starting with the left  arrow. The bottom arrow is computed by <code>abstract_attributes</code> and the right  arrow by <code>sub_vars</code>. Furthermore, a map from Partial_abs(G) to G is provided.</p><p>This is the factorization system arising from a coreflective subcategory.</p><p>(see https://ncatlab.org/nlab/show/reflective+factorization+system  and https://blog.algebraicjulia.org/post/2023/06/varacsets/)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/PBPO.jl#L194-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Tuple{PBPORule, Any, Any}" href="#AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map-Tuple{PBPORule, Any, Any}"><code>AlgebraicRewriting.Rewrite.Utils.get_expr_binding_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use exprs and k_exprs to fill in variables introduced by applying the rw rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/PBPO.jl#L324-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{PBPORule, ACSets.ACSetInterface.ACSet}" href="#AlgebraicRewriting.Rewrite.Utils.get_matches-Tuple{PBPORule, ACSets.ACSetInterface.ACSet}"><code>AlgebraicRewriting.Rewrite.Utils.get_matches</code></a> — <span class="docstring-category">Method</span></header><section><div><p>PBPO matches consist of <em>two</em> morphisms. First, a match m: L → G, and secondly  a typing G → L′. With attributes, it is not so simple because G has concrete  values for attributes and L′ may have variables. Therefore, we actually change the  typing to map out of A, an abstracted version of G (with its attributes replaced  by variables). So we lift matches L-&gt;G to matches L-&gt;A, then search α∈Hom(A,L′).</p><p>In general, we want α to be uniquely determined by m, so by default <code>α_unique</code>   is set to true.</p><pre><code class="nohighlight hljs"> m</code></pre><p>L⌟ ⟶ G   ||     ↓ α   L  ⟶ L′      tl</p><pre><code class="nohighlight hljs"> m</code></pre><p>L ⟶ G  tl ↓ ↘a ↑ (abs = partial abstraction. Note <code>a</code> is <code>Labs</code> in the code.)    L′⟵ A        α</p><p>The &quot;strong match&quot; condition we enforce is that: tl⁻¹(α(A)) = a⁻¹(A). This means  we can deduce precisely what m is by looking at α.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/PBPO.jl#L93-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{PBPORule, Any}" href="#AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps-Tuple{PBPORule, Any}"><code>AlgebraicRewriting.Rewrite.Utils.rewrite_match_maps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">         r
      K ----&gt; R
gₗ    u ↓ gᵣ ⌜ ↓ w</code></pre><p>Gₗ &lt;–– Gk ––&gt; Gᵣ α ↓    ⌞ ↓ u&#39;  L′ &lt;–  K′      tₗ</p><p>For the adherence morphism α to be valid, it must satisfy a condition with  m, tₗ. This is checked for matches provided by get_matches, so by default  we do not check it.</p><p>L &lt;–⌞• m ↓     ↓   G ⟵ Gk</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/rewrite/PBPO.jl#L292-L309">source</a></section></article><h2 id="Schedules"><a class="docs-heading-anchor" href="#Schedules">Schedules</a><a id="Schedules-1"></a><a class="docs-heading-anchor-permalink" href="#Schedules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly" href="#AlgebraicRewriting.Schedules.Poly"><code>AlgebraicRewriting.Schedules.Poly</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Mealy machines (augmented with monadic output) are a user-friendly format for specifying a behavior tree. Behavior trees in general are not finitely  expressible, but we focus on trees which can be lazily generated by functions.</p><p>Although it is conceptually simple to think of a single set of &quot;input doors&quot; out  &quot;output doors&quot; to enter/leave the Mealy machine, such that a Mealy machine has  type A → B, we use Σᵢ Aᵢ → Σⱼ Bⱼ, where Aᵢ and Bⱼ are Julia types. This allows  us to represent a Mealy machine with (Int + String)-many input doors, for  example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.List" href="#AlgebraicRewriting.Schedules.Poly.List"><code>AlgebraicRewriting.Schedules.Poly.List</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>&quot;The list monad returns the set of packages labeled with a natural number N,  each of which has N-many slots.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.Maybe" href="#AlgebraicRewriting.Schedules.Poly.Maybe"><code>AlgebraicRewriting.Schedules.Poly.Maybe</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>&quot;The Maybe monad, y+1, consists of two packages, one with one slot and the  other with no slots.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L48-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.BTree" href="#AlgebraicRewriting.Schedules.Poly.BTree"><code>AlgebraicRewriting.Schedules.Poly.BTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Lazily grown behavior tree induced by a Mealy machine. The future behavior is  dictated by the inputs seen thus far (i.e. a vector of WireVals).</p><p>Each vertex is identified by a sequence of inputs and has a state of the Mealy  machine associated with it.</p><p>Each nonempty sequence of inputs has a MealyRes associated with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.BTree-Tuple{Vector{WireVal}}" href="#AlgebraicRewriting.Schedules.Poly.BTree-Tuple{Vector{WireVal}}"><code>AlgebraicRewriting.Schedules.Poly.BTree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grow a tree and return the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.Mealy" href="#AlgebraicRewriting.Schedules.Poly.Mealy"><code>AlgebraicRewriting.Schedules.Poly.Mealy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A function that maintains a state (initially s0) and has monadic output for some  polynomial monad t.</p><p>The function f must be of type S × WireVal → S × (t ◁ WireVal) </p><pre><code class="nohighlight hljs">                            (i.e. S × Wireval → MealyRes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.MealyRes" href="#AlgebraicRewriting.Schedules.Poly.MealyRes"><code>AlgebraicRewriting.Schedules.Poly.MealyRes</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output of a Mealy machine</p><p>newS - The new state of the Mealy machine  mval - outputs along with their monadic values (e.g. probability weights) msg  - A message reporting something about the computation </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.PMonad" href="#AlgebraicRewriting.Schedules.Poly.PMonad"><code>AlgebraicRewriting.Schedules.Poly.PMonad</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Quotes in this docstring and others taken from David Spivak: https://topos.site/blog/2023/09/powers-of-polynomial-monads/#exponentiating-monads</p><p>&quot;A polynomial monad is a polynomial functor t with coherent maps η: y → t and  μ: t ◁ t → t.</p><p>Polynomial monads can be thought of as offering compositional (possibly labeled)  packages with some number of slots. The compositionality of this packaging says  that (via the monad unit) we know how to package up a given element of any set,  and that (via the monad multiplication) we can take a package of packages and  simplify it to a single package.&quot;</p><p>We consider monads t of the form: t = Σ_{i ∈ t(1)} y^{t[i]}</p><p>I is the type of labels, e.g. probability weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L21-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.Simulator" href="#AlgebraicRewriting.Schedules.Poly.Simulator"><code>AlgebraicRewriting.Schedules.Poly.Simulator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Equips a wiring diagram description of a simulator with mutable data structures (now behavior trees for each box, but possibly incremental homomorphism caches  in the future). Requires that all the boxes of the WiringDiagram be convertable  to BTrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.TrajStep" href="#AlgebraicRewriting.Schedules.Poly.TrajStep"><code>AlgebraicRewriting.Schedules.Poly.TrajStep</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A trajectory step is a box being fed a particular value</p><p>This only makes sense with reference to a WiringDiagram which <code>box</code> refers to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.WireVal" href="#AlgebraicRewriting.Schedules.Poly.WireVal"><code>AlgebraicRewriting.Schedules.Poly.WireVal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For an in/output, Σᵢ Aᵢ, provide wire index + value on wire</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.add_edge-Union{Tuple{I}, Tuple{Traj{I}, TrajStep{I}}} where I" href="#AlgebraicRewriting.Schedules.Poly.add_edge-Union{Tuple{I}, Tuple{Traj{I}, TrajStep{I}}} where I"><code>AlgebraicRewriting.Schedules.Poly.add_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Append without mutating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.apply_schedule-Union{Tuple{I}, Tuple{Simulator, Any}, Tuple{Simulator, Any, PMonad{I}}} where I" href="#AlgebraicRewriting.Schedules.Poly.apply_schedule-Union{Tuple{I}, Tuple{Simulator, Any}, Tuple{Simulator, Any, PMonad{I}}} where I"><code>AlgebraicRewriting.Schedules.Poly.apply_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In theory applying a schedule should result in a list of ACSets associated with  out ports and monad labels (e.g. probabilities), and if one were to want to  recover the trajectory of the output one would have to use a Writer monad  of some sort. For simplicity, the application of a schedule will simply return  the trajectories themselves (monadic multiplication could in principle condense  this output to the pure output).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L253-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.apply_traj_step-Tuple{Simulator, Traj, Catlab.WiringDiagrams.DirectedWiringDiagrams.Wire}" href="#AlgebraicRewriting.Schedules.Poly.apply_traj_step-Tuple{Simulator, Traj, Catlab.WiringDiagrams.DirectedWiringDiagrams.Wire}"><code>AlgebraicRewriting.Schedules.Poly.apply_traj_step</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A particular trajectory enters a box. Out of the box comes a  list of trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L297-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.curr_state-Tuple{Traj}" href="#AlgebraicRewriting.Schedules.Poly.curr_state-Tuple{Traj}"><code>AlgebraicRewriting.Schedules.Poly.curr_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Current state of the world</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.currwire-Tuple{Simulator, Traj}" href="#AlgebraicRewriting.Schedules.Poly.currwire-Tuple{Simulator, Traj}"><code>AlgebraicRewriting.Schedules.Poly.currwire</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the wire which the traj is currently on</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.joindist-Tuple{Any}" href="#AlgebraicRewriting.Schedules.Poly.joindist-Tuple{Any}"><code>AlgebraicRewriting.Schedules.Poly.joindist</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;The lotteries monad returns the set of packages labeled with a lottery  (a natural number N and a probability distribution on it) and again containing  N-many slots.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Poly.joinstr-Tuple{Any}" href="#AlgebraicRewriting.Schedules.Poly.joinstr-Tuple{Any}"><code>AlgebraicRewriting.Schedules.Poly.joinstr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Writer monad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Poly.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{Schedule}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate-Tuple{Schedule}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Map a functor over the data of a schedule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Wiring.AgentBox" href="#AlgebraicRewriting.Schedules.Wiring.AgentBox"><code>AlgebraicRewriting.Schedules.Wiring.AgentBox</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for primitive boxes used in a schedule. These are the generating morphisms of a traced monoidal category, with objects being lists of ACSets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L112-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACSets.DenseACSets.sparsify-Tuple{Schedule}" href="#ACSets.DenseACSets.sparsify-Tuple{Schedule}"><code>ACSets.DenseACSets.sparsify</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Map sparisfication over the data of a schedule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Wiring.merge_wires" href="#AlgebraicRewriting.Schedules.Wiring.merge_wires"><code>AlgebraicRewriting.Schedules.Wiring.merge_wires</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The comonoid structure - merging multiple wires into one. This is unproblematic because the world state only ever exists on one wire at a given time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L247-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Wiring.mk_sched-Union{Tuple{T}, Tuple{NamedTuple, NamedTuple, Names{T}, Union{AbstractDict, NamedTuple}, Expr}} where T" href="#AlgebraicRewriting.Schedules.Wiring.mk_sched-Union{Tuple{T}, Tuple{NamedTuple, NamedTuple, Names{T}, Union{AbstractDict, NamedTuple}, Expr}} where T"><code>AlgebraicRewriting.Schedules.Wiring.mk_sched</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Make a wiring diagram with ob/hom generators using @program macro</p><p>TODO double check that this does not introduce any wire splitting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Wiring.singleton-Tuple{AlgebraicRewriting.Schedules.Wiring.AgentBox}" href="#AlgebraicRewriting.Schedules.Wiring.singleton-Tuple{AlgebraicRewriting.Schedules.Wiring.AgentBox}"><code>AlgebraicRewriting.Schedules.Wiring.singleton</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Make a wiring diagram around a box</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Wiring.str_hom-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}" href="#AlgebraicRewriting.Schedules.Wiring.str_hom-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}"><code>AlgebraicRewriting.Schedules.Wiring.str_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Visualize the data of a CSet homomorphism</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Wiring.wire_vals-Tuple{Catlab.WiringDiagrams.DirectedWiringDiagrams.WiringDiagram, Int64}" href="#AlgebraicRewriting.Schedules.Wiring.wire_vals-Tuple{Catlab.WiringDiagrams.DirectedWiringDiagrams.WiringDiagram, Int64}"><code>AlgebraicRewriting.Schedules.Wiring.wire_vals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>1 = inwire, 2 = outwire</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Wiring.jl#L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Eval" href="#AlgebraicRewriting.Schedules.Eval"><code>AlgebraicRewriting.Schedules.Eval</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Specialized code for handling rewriting of ACSets with the identity monad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Eval.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Eval.interpret!-Tuple{Catlab.WiringDiagrams.DirectedWiringDiagrams.WiringDiagram, Catlab.CategoricalAlgebra.CSets.ACSetTransformation{&lt;:ACSets.ACSetInterface.ACSet{&lt;:ACSets.ACSetInterface.MarkAsDeleted}}}" href="#AlgebraicRewriting.Schedules.Eval.interpret!-Tuple{Catlab.WiringDiagrams.DirectedWiringDiagrams.WiringDiagram, Catlab.CategoricalAlgebra.CSets.ACSetTransformation{&lt;:ACSets.ACSetInterface.ACSet{&lt;:ACSets.ACSetInterface.MarkAsDeleted}}}"><code>AlgebraicRewriting.Schedules.Eval.interpret!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>interpret a wiring diagram, with each box updating its state in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Eval.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Eval.interpret-Tuple{Catlab.WiringDiagrams.DirectedWiringDiagrams.WiringDiagram, Catlab.CategoricalAlgebra.CSets.ACSetTransformation{&lt;:ACSets.ACSetInterface.ACSet{&lt;:ACSets.ACSetInterface.MarkAsDeleted}}}" href="#AlgebraicRewriting.Schedules.Eval.interpret-Tuple{Catlab.WiringDiagrams.DirectedWiringDiagrams.WiringDiagram, Catlab.CategoricalAlgebra.CSets.ACSetTransformation{&lt;:ACSets.ACSetInterface.ACSet{&lt;:ACSets.ACSetInterface.MarkAsDeleted}}}"><code>AlgebraicRewriting.Schedules.Eval.interpret</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpret a wiring diagram, recording the trajectory taken</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Eval.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Basic.Initialize" href="#AlgebraicRewriting.Schedules.Basic.Initialize"><code>AlgebraicRewriting.Schedules.Basic.Initialize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A box that spits out a constant ACSet with an empty agent above it. Possibly,  it does not take any inputs, so it can act as a comonoid counit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Basic.jl#L76-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Basic.Strengthen" href="#AlgebraicRewriting.Schedules.Basic.Strengthen"><code>AlgebraicRewriting.Schedules.Basic.Strengthen</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Adds to both agent and the state of the world via a pushout.</p><pre><code class="nohighlight hljs">    Agent₁  →  Agent₂
      ↓          ⇣    
    World₁ --&gt;⌜World₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Basic.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Basic.Weaken" href="#AlgebraicRewriting.Schedules.Basic.Weaken"><code>AlgebraicRewriting.Schedules.Basic.Weaken</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Change the agent to a subobject of the current agent without changing the world</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Basic.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Conditionals.Conditional" href="#AlgebraicRewriting.Schedules.Conditionals.Conditional"><code>AlgebraicRewriting.Schedules.Conditionals.Conditional</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A primitive box in a NestedDWD which does not change the state but redirects it  out of one of n wires. </p><p>It contains a function (A-&gt;X) -&gt; ℝⁿ. This optionally depends on the internal  state. This weights probability for n outports, conditional on the status of an  ACSet. If the function just depends on X rather than the whole morphism,  <code>withagent</code> is <code>false</code>. If the function does not depend on the internal state  (assumed to be true iff initial state is <code>nothing</code>), then <code>withstate</code> is <code>false</code>.</p><p>The state and update function are by default trivial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Conditionals.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Conditionals.const_cond-Tuple{Vector{Float64}, ACSets.DenseACSets.StructACSet}" href="#AlgebraicRewriting.Schedules.Conditionals.const_cond-Tuple{Vector{Float64}, ACSets.DenseACSets.StructACSet}"><code>AlgebraicRewriting.Schedules.Conditionals.const_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a branching point with fixed probabilities for each branch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Conditionals.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Conditionals.for_schedule-Tuple{Schedule, Int64}" href="#AlgebraicRewriting.Schedules.Conditionals.for_schedule-Tuple{Schedule, Int64}"><code>AlgebraicRewriting.Schedules.Conditionals.for_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a 1-1 schedule <code>n</code> times</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Conditionals.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Conditionals.if_cond-Tuple{Symbol, Function, ACSets.DenseACSets.StructACSet}" href="#AlgebraicRewriting.Schedules.Conditionals.if_cond-Tuple{Symbol, Function, ACSets.DenseACSets.StructACSet}"><code>AlgebraicRewriting.Schedules.Conditionals.if_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Enter the 1st branch iff the world state evaluates to true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Conditionals.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Conditionals.uniform-Tuple{Int64, ACSets.DenseACSets.StructACSet}" href="#AlgebraicRewriting.Schedules.Conditionals.uniform-Tuple{Int64, ACSets.DenseACSets.StructACSet}"><code>AlgebraicRewriting.Schedules.Conditionals.uniform</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A uniform chance of leaving each of n branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Conditionals.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Conditionals.while_schedule-Tuple{Schedule, Function}" href="#AlgebraicRewriting.Schedules.Conditionals.while_schedule-Tuple{Schedule, Function}"><code>AlgebraicRewriting.Schedules.Conditionals.while_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a 1-1 schedule until a condition is met</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Conditionals.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.RuleApps.RuleApp" href="#AlgebraicRewriting.Schedules.RuleApps.RuleApp"><code>AlgebraicRewriting.Schedules.RuleApps.RuleApp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Has the semantics of applying the rule to <em>some</em> match that is found  (no guarantees on <em>which</em> one, which should be controlled by application  conditions). If rewrite occurs, exit mode 1, else exit mode 2.</p><p>The agent is related to the L and R patterns of the rule. This can be done  via a Span, or implicitly as a homomorphism into &quot;I&quot; of the rewrite  rule, and alternatively just from the shape of the agent alone (if it is  identical to I, take the id map, otherwise take the unique morphism into I).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/RuleApps.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.RuleApps.has_match-Tuple{String, AlgebraicRewriting.Rewrite.Utils.AbsRule, ACSets.DenseACSets.StructACSet}" href="#AlgebraicRewriting.Schedules.RuleApps.has_match-Tuple{String, AlgebraicRewriting.Rewrite.Utils.AbsRule, ACSets.DenseACSets.StructACSet}"><code>AlgebraicRewriting.Schedules.RuleApps.has_match</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A box that takes the first output iff there is a match from a rule into the  current state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/RuleApps.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.RuleApps.loop_rule-Tuple{RuleApp}" href="#AlgebraicRewriting.Schedules.RuleApps.loop_rule-Tuple{RuleApp}"><code>AlgebraicRewriting.Schedules.RuleApps.loop_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Feed the &quot;rewrite applied&quot; output back into the input of the rule application</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/RuleApps.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.Schedules.Queries.Query" href="#AlgebraicRewriting.Schedules.Queries.Query"><code>AlgebraicRewriting.Schedules.Queries.Query</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Has an A input/output and a B input/output (by default, the B input can be  changed to some other type if needed). </p><pre><code class="nohighlight hljs">A  R ---------↖
↓  ↓          []</code></pre><p>⌜–––-⌝       []   | Query | [agent subroutine]    ⌞–––-⌟       []    ↓  ↓  ↓        []    A  B  ∅        []       ↘–––––-↗ Performs one action per element of Hom(B,X), optionally with some constraints. (i.e. sends you out along the B wire with agent Bₙ-&gt;X). </p><p>After you have done this for all Bₙ, then you exit the A port (you need to  update the A-&gt;X map, and, if at any point the agent was deleted, then you exit a  third door typed by 0).</p><p>A constraint optionally will be applied to (1) the A-&gt;W&lt;-B cospan of old agent  and purported new agent. (the new agent is the first argument to the constraint) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/schedules/Queries.jl#L18-L40">source</a></section></article><h2 id="CategoricalAlgebra"><a class="docs-heading-anchor" href="#CategoricalAlgebra">CategoricalAlgebra</a><a id="CategoricalAlgebra-1"></a><a class="docs-heading-anchor-permalink" href="#CategoricalAlgebra" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s1&quot;, Hom} where {var&quot;#s1&quot;&lt;:(Catlab.CategoricalAlgebra.FinSets.FinSet{Int64}), Hom}}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s1&quot;, Hom} where {var&quot;#s1&quot;&lt;:(Catlab.CategoricalAlgebra.FinSets.FinSet{Int64}), Hom}}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.id_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check identification condition for pushout complement of finite sets.</p><p>The identification condition says that the functions do not map (1) both a deleted item and a preserved item in L to the same item in G or (2) two distinct deleted items to the same item. It is trivially satisfied for injective functions.</p><p>Returns pair of iterators of</p><p>(1) a nondeleted item that maps to a deleted item in G   (2) a pair of distinct items in L that are deleted yet mapped to the same       item in G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/FinSets.jl#L83-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s3&quot;, Hom} where {var&quot;#s3&quot;&lt;:(Catlab.CategoricalAlgebra.FinSets.FinSet{Int64}), Hom}}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s3&quot;, Hom} where {var&quot;#s3&quot;&lt;:(Catlab.CategoricalAlgebra.FinSets.FinSet{Int64}), Hom}}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute a pushout complement of finite sets, if possible.</p><p>Given functions <span>$l: I → L$</span> and <span>$m: L → G$</span> to form a pushout square</p><pre><code class="nohighlight hljs">l</code></pre><p>L ← I m ↓   ↓k   G ← K     g</p><p>define the set <span>$K := G / m(L / l(I))$</span> and take <span>$g: K ↪ G$</span> to be the inclusion. Then the map <span>$k: I → K$</span> is determined by the map <span>$l⋅m: I → G$</span> from the requirement that the square commutes.</p><p>Pushout complements exist only if the identification condition is satisfied. An error will be raised if the pushout complement cannot be constructed. To check this in advance, use <a href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.can_pushout_complement-Tuple{Any, Any}"><code>can_pushout_complement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/FinSets.jl#L12-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Union{Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s1&quot;, Hom} where {var&quot;#s1&quot;&lt;:Catlab.CategoricalAlgebra.FinSets.VarSet{T}, Hom}}, Tuple{T}} where T" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Union{Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s1&quot;, Hom} where {var&quot;#s1&quot;&lt;:Catlab.CategoricalAlgebra.FinSets.VarSet{T}, Hom}}, Tuple{T}} where T"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This may not be the actual pushout complement in the relevant (Kleisli) category</p><pre><code class="nohighlight hljs">  l
L ← I</code></pre><p>m ↓   ↓ k     G ← K       g</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/FinSets.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.Migrate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>To do: check if functorial</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj-Tuple{ACSets.ACSetInterface.ACSet, Any}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj-Tuple{ACSets.ACSetInterface.ACSet, Any}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.cascade_subobj</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recursively delete anything, e.g. deleting a vertex deletes its edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb-NTuple{4, Any}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb-NTuple{4, Any}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.check_pb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Y   i↘  f_     X → •  g_ ↓ ⌟ ↓ f     • → •          g</p><p>Check whether (X, f<em>,g</em>) is the pullback of (f,g), up to isomorphism (i.e. the  pullback of f and g produces (Y,π₁,π₂), where Y is isomorphic to X and  i⋅f_ = π₁ &amp; i⋅g_ = π₂.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.gluing_conditions-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s55&quot;, Hom} where {var&quot;#s55&quot;&lt;:ACSets.ACSetInterface.ACSet, Hom}}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.gluing_conditions-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s55&quot;, Hom} where {var&quot;#s55&quot;&lt;:ACSets.ACSetInterface.ACSet, Hom}}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.gluing_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check both id condition and dangling condition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.invert_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Invert a morphism which may not be monic nor epic. When the morphism is not  monic, an arbitrary element of the preimage is mapped to. When it is not epic, a completely arbitrary element is mapped to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.invert_iso</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Invert some (presumed iso) components of an ACSetTransformation (given by s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.sub_vars</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a value for each variable, create a morphism X → X′ which applies the  substitution. We do this via pushout.</p><p>O –&gt; X    where C has AttrVars for <code>merge</code> equivalence classes    ↓          and O has only AttrVars (sent to concrete values or eq classes    C          in the map to C.</p><p><code>subs</code> and <code>merge</code> are dictionaries keyed by attrtype names</p><p><code>subs</code> values are int-keyed dictionaries indicating binding, e.g.  <code>; subs = (Weight = Dict(1 =&gt; 3.20, 5 =&gt; 2.32), ...)</code></p><p><code>merge</code> values are vectors of vectors indicating equivalence classes, e.g. <code>; merge = (Weight = [[2,3], [4,6]], ...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L301-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback-Union{Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan{var&quot;#s66&quot;, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {var&quot;#s66&quot;&lt;:(ACSets.DenseACSets.StructACSet{S, Ts}), Hom}}, Tuple{Ts}, Tuple{S}} where {S, Ts}" href="#AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback-Union{Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan{var&quot;#s66&quot;, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {var&quot;#s66&quot;&lt;:(ACSets.DenseACSets.StructACSet{S, Ts}), Hom}}, Tuple{Ts}, Tuple{S}} where {S, Ts}"><code>AlgebraicRewriting.CategoricalAlgebra.CSets.var_pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take an ACSet pullback combinatorially and freely add variables for all  attribute subparts.</p><p>This relies on implementation details of <code>abstract</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L342-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.can_pushout_complement-Tuple{Any, Any}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.can_pushout_complement-Tuple{Any, Any}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.can_pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Can a pushout complement be constructed for a composable pair?</p><p>Even in nice categories, this is not generally possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Any, Any}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Any, Any}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout complement: extend composable pair to a pushout square.</p><p><a href="https://ncatlab.org/nlab/show/pushout+complement">Pushout complements</a> are the essential ingredient for double pushout (DPO) rewriting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s56&quot;, Hom} where {var&quot;#s56&quot;&lt;:Catlab.CategoricalAlgebra.SliceCategories.Slice, Hom}}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s56&quot;, Hom} where {var&quot;#s56&quot;&lt;:Catlab.CategoricalAlgebra.SliceCategories.Slice, Hom}}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pushout_complement(f::SliceHom, g::SliceHom)</code></pre><p>Compute a pushout complement in a slice category by using the pushout complement in the underlying category.</p><pre><code class="nohighlight hljs"> f</code></pre><p>B &lt;– A –-⌝   | ↘ ↙      |  g|  X       | f′   ↓ ↗  ↖ cx  |   D &lt;–- C &lt;–       g′</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L185-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s56&quot;, var&quot;#s57&quot;, &lt;:StaticArraysCore.StaticArray{Tuple{2}, var&quot;#s57&quot;, 1}} where {var&quot;#s56&quot;&lt;:ACSets.ACSetInterface.ACSet, var&quot;#s57&quot;&lt;:Catlab.CategoricalAlgebra.CSets.TightACSetTransformation}}" href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair{var&quot;#s56&quot;, var&quot;#s57&quot;, &lt;:StaticArraysCore.StaticArray{Tuple{2}, var&quot;#s57&quot;, 1}} where {var&quot;#s56&quot;&lt;:ACSets.ACSetInterface.ACSet, var&quot;#s57&quot;&lt;:Catlab.CategoricalAlgebra.CSets.TightACSetTransformation}}"><code>AlgebraicRewriting.CategoricalAlgebra.FinSets.pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute pushout complement of attributed C-sets, if possible.</p><p>The pushout complement is constructed pointwise from pushout complements of finite sets. If any of the pointwise identification conditions fail (in FinSet), this method will raise an error. If the dangling condition fails, the resulting C-set will be only partially defined. To check all these conditions in advance, use the function <a href="#AlgebraicRewriting.CategoricalAlgebra.FinSets.can_pushout_complement-Tuple{Any, Any}"><code>can_pushout_complement</code></a>.</p><p>Because Subobject does not work well with AttrVars, a correction is made</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L106-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.HomSearch.homomorphisms-Tuple{Catlab.CategoricalAlgebra.SliceCategories.Slice, Catlab.CategoricalAlgebra.SliceCategories.Slice}" href="#Catlab.CategoricalAlgebra.HomSearch.homomorphisms-Tuple{Catlab.CategoricalAlgebra.SliceCategories.Slice, Catlab.CategoricalAlgebra.SliceCategories.Slice}"><code>Catlab.CategoricalAlgebra.HomSearch.homomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This could be made more efficient as a constraint during homomorphism finding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/CSets.jl#L396-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.StructuredMultiCospanHom</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A component-wise map between two cospans. The first component given is the apex map, with the following maps being the legs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.openrule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A span of StructuredMulticospanHoms, interpreted as a DPO rewrite rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Tuple{openrule, openrule}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Tuple{openrule, openrule}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">composeH_(r₁, r₂)</code></pre><p>compose two rewrite rules horizontally (via pushouts) as shown below:     L₁₋₍ₙ₋₁₎-&gt; L &lt;- Lₙ    X₁ -&gt; X &lt;- X₂₋ₘ     L₁₋₍ₙ₋₁₎ -&gt; L +Lₙ X &lt;- X₂₋ₘ     ↑        λ ↑    ↑     ↑    ↑ χ    ↑          ↑           ↑        ↑     I₁₋₍ₙ₋₁₎-&gt; I &lt;- Iₙ ∘h Y₁ -&gt; Y &lt;- Y₂₋ₘ  =  I₁₋₍ₙ₋₁₎ -&gt; I +Iₙ Y &lt;- Y₂₋ₘ     ↓        ρ ↓    ↓     ↓    ↓ ζ    ↓          ↓           ↓        ↓     R₁₋₍ₙ₋₁₎-&gt; R &lt;- Rₙ    Z₁ -&gt; Z &lt;- Z₂₋ₘ     R₁₋₍ₙ₋₁₎ -&gt; R +Rₙ Z &lt;- Z₂₋ₘ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L169-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Union{Tuple{L}, Tuple{Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan{L}, Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan{L}}} where L" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_-Union{Tuple{L}, Tuple{Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan{L}, Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan{L}}} where L"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeH_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cospan composition given by pushout</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Finset span composition given by pullback</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{openrule, openrule}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_-Tuple{openrule, openrule}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.composeV_</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">composeV_(r₁, r₂)</code></pre><p>compose two rewrite rules vertically with pullbacks, as shown below:        L₁₋ₙ -&gt; L        ↑       ↑        I₁₋ₙ -&gt; I        ↓       ↓         L₁₋ₙ        -&gt;   L        R₁₋ₙ -&gt; R           ↑              ↑            ∘v      = I₁₋ₙ ×ᵣ₁₋ₙ  Θ₁₋ₙ -&gt; I ×ᵣ Θ        Λ₁₋ₙ -&gt; Λ           ↓              ↓        ↑       ↑         Ω₁₋ₙ        -&gt;   Ω        Θ₁₋ₙ -&gt; Θ        ↓       ↓        Ω₁₋ₙ -&gt; Ω</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L204-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_-Union{Tuple{L_}, Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb{L_}}} where L_" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_-Union{Tuple{L_}, Tuple{Catlab.CategoricalAlgebra.FreeDiagrams.Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb{L_}}} where L_"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.id2H_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pass dummy value in because a span of invertible FinFunctions does not retain L type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L151-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_-Union{Tuple{Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb{L}}, Tuple{L}} where L" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_-Union{Tuple{Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb{L}}, Tuple{L}} where L"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.idV_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Vertical arrows are spans of invertible finfunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement-Tuple{openrule, StructuredMultiCospanHom}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement-Tuple{openrule, StructuredMultiCospanHom}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial data: 4 structured cospans + 3 cospan morphisms: μ, λ, ρ      g G₁₋ₙ –&gt; G ↑    l  ↑ μ L₁₋ₙ –&gt; L ↑    i  ↑ λ I₁₋ₙ –&gt; I ↓    r  ↓ ρ R₁₋ₙ –&gt; R</p><p>Computed data: 2 new structured cospans + 4 cospan morphisms: γ, η, ik, rh         G₁₋ₙ      G           ↑    k  ↑ γ   ik  I₁₋ₙ -&gt; K₁₋ₙ  –&gt; K    &lt;– I           ↓    h  ↓ η   rh  R₁₋ₙ -&gt; H₁₋ₙ  –&gt; H    &lt;– R In the context of the legs of a multicospan, the indices 1-n refer to the n legs of the cospan. In the context of a map of multicospans, there are 1-(n+1) maps, with the first one designating the map of the apexes. Hence it can make sense to have the elements: zip(legs, maps[2:end]) = [(legᵢ, mapᵢ), ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L237-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite-Tuple{openrule, StructuredMulticospan}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite-Tuple{openrule, StructuredMulticospan}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a rewrite rule to a structured multicospan, where a matching cospan homomorphism is found automatically. If multiple matches are found, a particular one can be selected using <code>m_index</code>. Returns <code>nothing</code> if none are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L298-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match-Tuple{openrule, StructuredMultiCospanHom}" href="#AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match-Tuple{openrule, StructuredMultiCospanHom}"><code>AlgebraicRewriting.CategoricalAlgebra.StructuredCospans.open_rewrite_match</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract the rewritten structured cospan from the induced rewrite rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L290-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.HomSearch.homomorphisms-Union{Tuple{L}, Tuple{StructuredMulticospan{L}, StructuredMulticospan{L}}} where L" href="#Catlab.CategoricalAlgebra.HomSearch.homomorphisms-Union{Tuple{L}, Tuple{StructuredMulticospan{L}, StructuredMulticospan{L}}} where L"><code>Catlab.CategoricalAlgebra.HomSearch.homomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find homomorphisms between structured cospans. These are constrained to be iso on the legs of the cospans. Solving this w/ homomorphism finding  requires a dynamic acset, and the current hack will be replaced once those are available.</p><p>A homomorphism backend that uses SAT/SMT would also make this viable to do without hacking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/StructuredCospans.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs-Tuple{ACSets.DenseACSets.StructACSet, GATlab.Models.Presentations.Presentation, Symbol, Int64}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs-Tuple{ACSets.DenseACSets.StructACSet, GATlab.Models.Presentations.Presentation, Symbol, Int64}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.check_eqs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Confirm a C-Set satisfies its equational axioms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path-Tuple{ACSets.DenseACSets.StructACSet, Any, Int64}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path-Tuple{ACSets.DenseACSets.StructACSet, Any, Int64}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.eval_path</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take a GATExpr (an id morphism, a generator, or a composite) and evaluate, starting at a particular point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta-Tuple{ACSets.DenseACSets.StructCSet}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta-Tuple{ACSets.DenseACSets.StructCSet}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_eta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The natural injection from X ⟶ T(X) When evaluated on the terminal object, this gives the subobject classfier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Catlab.CategoricalAlgebra.CSets.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_classifier_universal_property</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A partial function is defined by the following span:                           m   f                         A ↩ X → B</p><p>We compute ϕ(m,f): A ⟶ T(B) such that the following is a pullback square:      f   X  ⟶ B m ↓     ↓ η(B)   A  ⟶ T(B)      ϕ</p><p>Essentially, ϕ sends elements of A to the &#39;real&#39; values in T(B) when A is in the subobject picked out by X. When A is &#39;deleted&#39;, it picks out the right element of the additional data added by T(B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L152-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Because the functorial embedding of objects keeps a copy of the original data, what to do with morphisms is just carry them along. Because our implementation adds all of the additional stuff afterwards, index-wise, we can use literally the same data for a morphism lifted from X⟶Y to T(X)⟶T(Y).</p><p>However, we still need to map the extra stuff in T(X) to the proper extra stuff in T(Y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L104-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob-Tuple{ACSets.DenseACSets.StructCSet}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob-Tuple{ACSets.DenseACSets.StructCSet}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.partial_map_functor_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A functor T, playing the role of Maybe in Set, but generalized to C-Sets.</p><p>When called on the terminal object, this produces the subobject classifier: See Mulry &quot;Partial map classifiers and cartesian closed categories&quot; (1994)</p><p>This function specifies what T does on objects. The key properties:</p><ol><li>for all X ∈ Ob(C), η(X):X⟶T(X) is monic.                 m   f                                    ϕ(m,f)</li><li>for each span A ↩ X → B, there exists a unique morphism A ⟶ T(B) such that (m,f) is the pullback of ϕ(m,f),η(B))</li></ol><p>Not only do we add an extra element to each component of the C-Set, but we need to consider the possibility that a component (with n outgoing morphisms) has any combination of the targets of those morphisms deleted (like the subobject classifier, there are different <em>ways</em> for something to be deleted).</p><p>For example, in Graph, an edge can be deleted that goes between any two vertices of the graph. We can&#39;t map all deleted edges to the same point in T(E) (if we&#39;re going to satisfy that desired property #2), so we need an extra edge in T(E) for every possibility (from V1 to V2, from V1 to V3, ..., from [Deleted] to V1, ..., from V2 to [Deleted], ... from [Deleted] to [Deleted]), where [Deleted] is our name for the extra element added to T(V).</p><pre><code class="nohighlight hljs">                [src]     [tgt]</code></pre><p>Thus, T(E) ≅ |E| + (|V|+1) × (|V|+1).</p><p>In general, T(X) ≅ |X| + ∏ₕ(|T(codom(h))|) for each outgoing morphism h::X⟶Y</p><ul><li>the |X| corresponds to the &#39;real&#39; elements of X</li><li>the second term corresponds to the possible ways an X can be deleted.</li><li>This recursive formula means we require the schema of the C-set to be acyclic otherwise the size is infinite (assumes schema is free).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L40-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs-Tuple{Any}" href="#AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs-Tuple{Any}"><code>AlgebraicRewriting.CategoricalAlgebra.PartialMap.topo_obs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get topological sort of objects of a schema. Fail if cyclic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/b9f01df9572100187aeb2b3cafeb6ebb55a260b4/src/categorical_algebra/PartialMap.jl#L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/ptg_simple/">« Slice Bread</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 27 February 2024 22:20">Tuesday 27 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
