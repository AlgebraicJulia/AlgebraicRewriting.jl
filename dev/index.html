<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AlgebraicRewriting.jl · AlgebraicRewriting.jl</title><meta name="title" content="AlgebraicRewriting.jl · AlgebraicRewriting.jl"/><meta property="og:title" content="AlgebraicRewriting.jl · AlgebraicRewriting.jl"/><meta property="twitter:title" content="AlgebraicRewriting.jl · AlgebraicRewriting.jl"/><meta name="description" content="Documentation for AlgebraicRewriting.jl."/><meta property="og:description" content="Documentation for AlgebraicRewriting.jl."/><meta property="twitter:description" content="Documentation for AlgebraicRewriting.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="AlgebraicRewriting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>AlgebraicRewriting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AlgebraicRewriting.jl</a><ul class="internal"><li><a class="tocitem" href="#Setup-Environment"><span>Setup Environment</span></a></li><li><a class="tocitem" href="#Design-a-rewrite-rule"><span>Design a rewrite rule</span></a></li><li><a class="tocitem" href="#Apply-the-rule"><span>Apply the rule</span></a></li><li class="toplevel"><a class="tocitem" href="#Authors"><span>Authors</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="generated/full_demo/">Full Demo</a></li><li><a class="tocitem" href="generated/game_of_life/">Conway&#39;s Game of Life</a></li><li><a class="tocitem" href="generated/lotka_volterra/">Lotka Volterra</a></li><li><a class="tocitem" href="generated/ptg_simple/">Slice Bread</a></li></ul></li><li><a class="tocitem" href="api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AlgebraicRewriting.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AlgebraicRewriting.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicRewriting.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AlgebraicRewriting.jl"><a class="docs-heading-anchor" href="#AlgebraicRewriting.jl">AlgebraicRewriting.jl</a><a id="AlgebraicRewriting.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AlgebraicRewriting.jl" title="Permalink"></a></h1><p>Algebraic rewriting is a context-aware find-and-replace operation that is useful for maintaining structure in various scenarios. This package provides tools for such operations in Julia, ensuring that rewrite rules adhere to structures defined using ACSets (see <a href="https://github.com/AlgebraicJulia/ACSets.jl">ACSets.jl</a> and <a href="https://github.com/AlgebraicJulia/Catlab.jl">Catlab.jl</a>). This documentation provides a basic guide to using the AlgebraicRewriting package in Julia. </p><p>This page will provide you with a gentle overview of how to design and apply rewrite rules for a simple ACSet. <strong>More sophisticated examples</strong> can be found in the side-bar.</p><h2 id="Setup-Environment"><a class="docs-heading-anchor" href="#Setup-Environment">Setup Environment</a><a id="Setup-Environment-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Environment" title="Permalink"></a></h2><p>To begin, set up your environment by importing necessary packages.</p><pre><code class="language-julia hljs">using Catlab
using AlgebraicRewriting
using DataMigrations</code></pre><h2 id="Design-a-rewrite-rule"><a class="docs-heading-anchor" href="#Design-a-rewrite-rule">Design a rewrite rule</a><a id="Design-a-rewrite-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Design-a-rewrite-rule" title="Permalink"></a></h2><p>The general process for designing a rewrite rule is as follows:</p><h3 id="1.-Define-your-schema"><a class="docs-heading-anchor" href="#1.-Define-your-schema">1. Define your schema</a><a id="1.-Define-your-schema-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Define-your-schema" title="Permalink"></a></h3><p>A schema defined by a finite presentation of a generalized algebraic theory model using generators, <code>Ob</code>, <code>Hom</code>, <code>AttrType</code>, and <code>Attr</code>.</p><pre><code class="language-julia hljs">@present SchSportsTeam(FreeSchema) begin
  Player::Ob
  Team::Ob
  Member::Ob
  IsMember::Hom(Member, Player)
  MemberOf::Hom(Member, Team)

  Name::AttrType
  PlayerHasName::Attr(Player, Name)
  TeamHasName::Attr(Team, Name)
end
to_graphviz(SchSportsTeam)</code></pre><h3 id="2.-Create-the-schema-type"><a class="docs-heading-anchor" href="#2.-Create-the-schema-type">2. Create the schema type</a><a id="2.-Create-the-schema-type-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Create-the-schema-type" title="Permalink"></a></h3><p>Data for rules are stored in a data structure called an ACSet. </p><pre><code class="language-julia hljs">@acset_type SportsTeam(SchSportsTeam)</code></pre><h3 id="3.-Define-rule-parts"><a class="docs-heading-anchor" href="#3.-Define-rule-parts">3. Define rule parts</a><a id="3.-Define-rule-parts-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Define-rule-parts" title="Permalink"></a></h3><p>A rewrite rule consists of a span of ACSets (<code>L &lt;-l- K -r-&gt; R</code>), namely three ACSets (<code>L</code>, <code>K</code>, <code>R</code>) and two natural transformations (<code>l</code>, <code>r</code>):</p><ul><li>Left ACSet, <code>L</code>, is the pre-condition for the rule to be applied.</li><li>Keep ACSet, <code>K</code>, is the data for the part of the state that remain consistent when the rule is applied.</li><li>Right ACSet, <code>R</code>, is the effect of the rule.</li><li>Left transformation, <code>l</code>, embeds <code>K</code> in <code>L</code>.</li><li>Right transformation, <code>r</code>, embed <code>K</code> in <code>R</code>.</li></ul><p>To define a rule, all five parts need to be defined. </p><p>It is possible to insert data according to the schema using a <strong>static</strong> approach <em>or</em> the <strong>colimit-of-representables</strong> approach.</p><h4 id="Static-Instantiation-(@acset)"><a class="docs-heading-anchor" href="#Static-Instantiation-(@acset)">Static Instantiation (<code>@acset</code>)</a><a id="Static-Instantiation-(@acset)-1"></a><a class="docs-heading-anchor-permalink" href="#Static-Instantiation-(@acset)" title="Permalink"></a></h4><p>If using the <strong>static</strong> approach, you must fully specify the ACSet functors and natural transformation. Here is a rule that defines the ACSet statically. </p><p>In this example, the rule swaps players, one from each team. <code>AttrVar.(1:2)</code>, or <code>[AttrVar(1), AttrVar(2)]</code>, are used as variable placeholders for the names of the players. This allows the rule to be applied independent of player names, as long as two players are specified from opposing teams. Contrastingly, <code>[&quot;Home&quot;, &quot;Away&quot;]</code>, are specified explicitly and, therefore, this rule can only be applied to teams whose names are &quot;Home&quot; and &quot;Away&quot;</p><pre><code class="language-julia hljs"># Both L and R are the same: two players are members of a Home and Away team
L = R = @acset SportsTeam{String} begin
  Player = 2; Team = 2; Member = 2; Name = 2
  IsMember = [1, 2]; MemberOf = [1, 2]
  PlayerHasName = AttrVar.(1:2)
  TeamHasName = [&quot;Home&quot;, &quot;Away&quot;]
end
# K is missing the Member relation. L &lt;- K removes the two players&#39; memberships
# and K -&gt; R adds in a new membership relation.
K = @acset SportsTeam{String} begin
  Player = 2; Team = 2; Name = 2
  PlayerHasName = AttrVar.(1:2)
  TeamHasName = [&quot;Home&quot;, &quot;Away&quot;]
end

# Manually specify K-&gt;L and K-&gt;R
# Important that the player removed from Home (as determined by l: K-&gt;L) is 
# assigned (via r: K-&gt;R) to the player which is added to away, and vice-versa.
l = ACSetTransformation(K, L, Player=[1,2], Team=[1, 2], Name=AttrVar.([1,2]))
r = ACSetTransformation(K, R, Player=[2,1], Team=[1, 2], Name=AttrVar.([2,1])) # swap

# Alternatively we could use automated search, as there are the only two maps 
# K-&gt;L (same as K-&gt;R because L=R) that do not merge the two players together 
l, r = homomorphisms(K, L; monic=true) # (&#39;monic&#39; = &quot;no merging allowed&quot;)</code></pre><h4 id="Colimit-of-representables-instantiation-(@acset_colim)"><a class="docs-heading-anchor" href="#Colimit-of-representables-instantiation-(@acset_colim)">Colimit-of-representables instantiation (<code>@acset_colim</code>)</a><a id="Colimit-of-representables-instantiation-(@acset_colim)-1"></a><a class="docs-heading-anchor-permalink" href="#Colimit-of-representables-instantiation-(@acset_colim)" title="Permalink"></a></h4><p>If using the <strong>colimit-of-representables</strong> approach, you only need to specify relevant objects and morphism parts. Shown here is the translation of the above rule using <code>@acset_colim</code>.</p><pre><code class="language-julia hljs">ySportsTeam = yoneda(SportsTeam{String})
L = R = @acset_colim ySportsTeam begin
  (p1, p2)::Player
  (t1, t2)::Team
  (m1, m2)::Member
  IsMember(m1) == p1
  IsMember(m2) == p2
  MemberOf(m1) == t1
  MemberOf(m2) == t2
  TeamHasName(t1) == &quot;Home&quot;
  TeamHasName(t2) == &quot;Away&quot;
end # we did not specify PlayerHasName, so it&#39;s left generic
K = @acset_colim ySportsTeam begin
  (t1, t2)::Team
  (p1, p2)::Player
  TeamHasName(t1) == &quot;Home&quot;
  TeamHasName(t2) == &quot;Away&quot;
end
l, r = homomorphisms(K, L; monic=true) # same as above because K,L,R are the same</code></pre><h3 id="4.-Construct-the-rule"><a class="docs-heading-anchor" href="#4.-Construct-the-rule">4. Construct the rule</a><a id="4.-Construct-the-rule-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Construct-the-rule" title="Permalink"></a></h3><p>Use the <code>AlgebraicRewriting.Rule</code> constructor to create the rule. This assumes that a double-pushout (DPO) rewrite rule is being constructed. You may also construct an single-pushout (SPO), sesqui-pushout (SqPO), or pullback-pushout (PBPO) rule.</p><pre><code class="language-julia hljs">rule = Rule{:DPO}(l, r)</code></pre><h2 id="Apply-the-rule"><a class="docs-heading-anchor" href="#Apply-the-rule">Apply the rule</a><a id="Apply-the-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Apply-the-rule" title="Permalink"></a></h2><h3 id="5.-Define-the-initial-state."><a class="docs-heading-anchor" href="#5.-Define-the-initial-state.">5. Define the initial state.</a><a id="5.-Define-the-initial-state.-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Define-the-initial-state." title="Permalink"></a></h3><p>Similarly, you can choose to define the acset using the static approach or the colimit-of-representable approach.</p><ul><li>If using the <strong>static approach</strong>, you must fully specify the ACSet for the initial state.</li></ul><pre><code class="language-julia hljs">state = @acset SportsTeam{String} begin
  Player = 4; Member = 4; Team = 2
  IsMember = [1, 2, 3, 4]; MemberOf = [1, 1, 2, 2]
  TeamHasName = [&quot;Home&quot;, &quot;Away&quot;]
  PlayerHasName = [&quot;Jordan&quot;, &quot;Alex&quot;, &quot;Casey&quot;, &quot;Taylor&quot;]
end</code></pre><ul><li>If using the <strong>colimit-of-representable approach</strong>, you only need to specify relevant objects and morphism parts.</li></ul><pre><code class="language-julia hljs">state = @acset_colim ySportsTeam begin
  (p1, p2, p3, p4)::Player
  (m1, m2, m3, m4)::Member
  (t1, t2)::Team
  IsMember(m1) == p1; IsMember(m2) == p2; IsMember(m3) == p3; IsMember(m4) == p4
  MemberOf(m1) == t1; MemberOf(m2) == t1; MemberOf(m3) == t2; MemberOf(m4) == t2
  PlayerHasName(p1) == &quot;Jordan&quot;
  PlayerHasName(p2) == &quot;Alex&quot;
  PlayerHasName(p3) == &quot;Casey&quot;
  PlayerHasName(p4) == &quot;Taylor&quot;
  TeamHasName(t1) == &quot;Home&quot;
  TeamHasName(t2) == &quot;Away&quot;
end</code></pre><h3 id="6.-Identify-the-match-from-the-rule-to-the-state"><a class="docs-heading-anchor" href="#6.-Identify-the-match-from-the-rule-to-the-state">6. Identify the match from the rule to the state</a><a id="6.-Identify-the-match-from-the-rule-to-the-state-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Identify-the-match-from-the-rule-to-the-state" title="Permalink"></a></h3><p>This can be done manually or automatically. </p><ul><li>To <strong>manually</strong> identify the match, fully-specify an ACSet transformation. For this example, we would like to rule to swap <code>p2::Player</code> and <code>p3::Player</code></li></ul><pre><code class="language-julia hljs">pattern_match = ACSetTransformation(L, state, Player=[2, 3], Member=[2, 3], 
                                    Team=[1, 2], Name=[&quot;Alex&quot;, &quot;Casey&quot;])</code></pre><ul><li>To <strong>automatically</strong> identify the match, use the backtracking search algorithm provided by AlgebraicRewriting. This may return multiple matches, so you can provide logic for deciding which match to select. </li></ul><pre><code class="language-julia hljs">pattern_match = homomorphism(L, state; initial=(Name=[&quot;Alex&quot;, &quot;Casey&quot;],))

matches = get_matches(rule, state)# get all four possible matches, then pick one</code></pre><h3 id="7.-Apply-the-rewrite-rule"><a class="docs-heading-anchor" href="#7.-Apply-the-rewrite-rule">7. Apply the rewrite rule</a><a id="7.-Apply-the-rewrite-rule-1"></a><a class="docs-heading-anchor-permalink" href="#7.-Apply-the-rewrite-rule" title="Permalink"></a></h3><p>This executes the rewrite process using using the defined rule and match.</p><pre><code class="language-julia hljs">result = rewrite_match(rule, pattern_match)</code></pre><h1 id="Authors"><a class="docs-heading-anchor" href="#Authors">Authors</a><a id="Authors-1"></a><a class="docs-heading-anchor-permalink" href="#Authors" title="Permalink"></a></h1><p>This documentation is maintained by <a href="https://angelineaguinaldo.com/">Angeline Aguinaldo</a> and <a href="https://www.krisb.org/docs/research">Kristopher Brown</a>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="generated/full_demo/">Full Demo »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 1 June 2024 20:58">Saturday 1 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
